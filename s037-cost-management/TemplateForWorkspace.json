{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"workspaceName": {
			"type": "string",
			"metadata": "Workspace name",
			"defaultValue": "s037-cost-management"
		},
		"AzureDataLakeStorage1_accountKey": {
			"type": "secureString",
			"metadata": "Secure string for 'accountKey' of 'AzureDataLakeStorage1'"
		},
		"NewServiceNow_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 'NewServiceNow'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=smdatasqlprod.database.windows.net;Initial Catalog=ServiceNow"
		},
		"s037-cost-management-WorkspaceDefaultSqlServer_connectionString": {
			"type": "secureString",
			"metadata": "Secure string for 'connectionString' of 's037-cost-management-WorkspaceDefaultSqlServer'",
			"defaultValue": "Integrated Security=False;Encrypt=True;Connection Timeout=30;Data Source=tcp:s037-cost-management.sql.azuresynapse.net,1433;Initial Catalog=@{linkedService().DBName}"
		},
		"Ad-hoc Combined Extend AI column and WBS tags - Extended Parquet_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Ad-hoc Extend AI Column - Extended Parquet_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Azure AD Users_v1_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"Azure AD Users_v1_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Azure Advisor Recommendations_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Daily VM Utilization_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Extend Daily Actual Cost_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Extend Daily Amortized Cost_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Extend Daily Cost_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Extend Daily Cost_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Extend Monthly Cost_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Extend Monthly Cost_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"New API - Calculate Savings_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Populate Cost Code and Cost Type fields_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"RI Recommendations_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"RI Recommendations_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"VM-Performance_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"build-ri-recommendations_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"compute-hub-and-ri-savings_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"compute-hub-and-ri-savings_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"compute-hub-deployments_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"process-cost-and-refresh_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"process-cost-history_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"servicenow-applications-daily_pipelineSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"servicenow-applications-daily_pipelineStorageAccountVariable": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"servicenow-subscriptions-daily_pipelineStorageAccountParameter": {
			"type": "string",
			"defaultValue": "s037costmgmt"
		},
		"Adhoc_CSV_Source_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"AutofitCombometerSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"AutofitCombometerSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "CCM Storage"
		},
		"AzureAD_Users_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "MicrosoftGraphRESTAPI"
		},
		"AzureAdvisorRecommendationSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "AzureManagementAPI"
		},
		"AzureAdvisorRecommendationsSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"AzureSubscriptionResources_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "AzureManagementAPIMetricsReader"
		},
		"CSV_Source_File_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"CleanedCSVDestSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Monthly_Parquet_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"NewServiceNowSinkDataset_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"New_API_Format_Parquet_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Older_Files_For_Deletion_Binary_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Parquet_File_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Parquet_Monthly_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Parquet_for_Deletion_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"PricesheetExportSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"PricesheetExportSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"RIPurchaseSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"RIPurchasesSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ReservationFileTransform_dst_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037CSVSourceDataset_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037Parquet_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037_Cleaned_CSV_Dest_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037_New_Format_Usage_Data_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037_Usage_DataSet_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"S037_reservation_data_parquet_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"SQLDeploymentSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"SQLDeploymentSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"SQLDisableSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"SQLDisableSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"ServiceNowAppJson_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ServiceNowApplicationData_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ServiceNowApplicationsDataset_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "NewServiceNow"
		},
		"ServiceNowLinkedService_Application_View_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "ServiceNowLinkedService"
		},
		"ServiceNowSubscriptionsDataset_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "NewServiceNow"
		},
		"ServiceNowSubscriptionsDatasetSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"SubscriptionResourceLocations_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"TestADFBinaryFile_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"TestADFCleanedCSV_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"TestADFDataset_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"TestRawCSVSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"VMDeploymentSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"VMDeploymentsSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"VMDisableSink_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"VMDisableSource_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "HUB Storage Account"
		},
		"ds_CSV_File_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ds_Daily_Parquet_File_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ds_Test_delete_file_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ds_json_file_blank_destination_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ds_test_delete_files_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"ms_billing_output_file_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "ms_billing_cost_report_download"
		},
		"retrieve_cost_report_ms_billing_source_dataSetLinkedServiceName": {
			"type": "string",
			"defaultValue": "ms_consumption_api_rest"
		},
		"AzureDataLakeStorage1_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://s037costmgmt.dfs.core.windows.net/"
		},
		"AzureManagementAPI_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://management.azure.com/"
		},
		"AzureManagementAPIMetricsReader_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://management.azure.com/"
		},
		"FinOpsHubsTest_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://myfinopshub5f2xqvwwmha5y.dfs.core.windows.net/"
		},
		"HUB Storage Account_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://hubautomation.dfs.core.windows.net/"
		},
		"MicrosoftGraphRESTAPI_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://graph.microsoft.com/v1.0/"
		},
		"Pricesheet API_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "@{concat('https://consumption.azure.com/v3/enrollments/57950773/billingPeriods/',formatDateTime(utcNow(),'yyyyMM'),'/pricesheet')}"
		},
		"S926FinOpsHubTest_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://myfinopshub5f2xqvwwmha5y.dfs.core.windows.net/"
		},
		"ServiceNowLinkedService_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://api.gateway.equinor.com/api/x_stasa_serv_mgnt/v1/"
		},
		"ms_billing_cost_report_download_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "@{linkedService().blobPath}"
		},
		"ms_consumption_api_http_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "@{linkedService().baseUrl}"
		},
		"ms_consumption_api_rest_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "@{linkedService().baseUrl}"
		},
		"ms_management_api_rest_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://management.azure.com"
		},
		"omniaacdcdlsprod_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://omniaacdcdlsprod.dfs.core.windows.net"
		},
		"s037-cost-management-WorkspaceDefaultStorage_linkedServiceUrl": {
			"type": "string",
			"defaultValue": "https://s037costmgmt.dfs.core.windows.net"
		},
		"Remove First Two Lines_sourceDataflowLinkedServiceNameRef": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"Remove First Two Lines_sinkDataflowLinkedServiceNameRef": {
			"type": "string",
			"defaultValue": "s037-cost-management-WorkspaceDefaultStorage"
		},
		"AdHoc Extend AI column and WBS tags_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"AdHoc Extend AI column and WBS tags_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"AdHoc Extend AI column and WBS tags_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Anomaly_Detection_v1_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Anomaly_Detection_v1_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Anomaly_Detection_v1_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Anomaly_Detection_v2_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Anomaly_Detection_v2_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Anomaly_Detection_v2_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"CostTagExpansion_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"CostTagExpansion_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"CostTagExpansion_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Daily Extend AI column and WBS tags_v1_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Daily Extend AI column and WBS tags_v1_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Daily Extend AI column and WBS tags_v1_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Extend Cost File_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Extend Cost File_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Extend Cost File_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Extend Cost File_v2_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Extend Cost File_v2_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Extend Cost File_v2_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Get RI Recommendations_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"Get RI Recommendations_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"Get RI Recommendations_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"HUB Savings_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"HUB Savings_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"HUB Savings_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"HUB_Daily_File_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"HUB_Daily_File_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"HUB_Daily_File_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_v2_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_v2_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Monthly Extend AI column and WBS tags_v2_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"New API - Calculate Savings_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"New API - Calculate Savings_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"New API - Calculate Savings_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"Populate Cost Code and Cost Type fields_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"Populate Cost Code and Cost Type fields_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"Populate Cost Code and Cost Type fields_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Prod_Calendar_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"Prod_Calendar_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"Prod_Calendar_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"Prod_import_most_recent_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"Prod_import_most_recent_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"Prod_import_most_recent_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"RI VM Savings_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"RI VM Savings_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"RI VM Savings_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"Run Notebook on Previous Dates_v1_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"Run Notebook on Previous Dates_v1_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"Run Notebook on Previous Dates_v1_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"VM-Performance_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"VM-Performance_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"VM-Performance_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"VM-utilization-aggregation_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"VM-utilization-aggregation_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"VM-utilization-aggregation_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"VM-utilization-fetch_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"VM-utilization-fetch_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"VM-utilization-fetch_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"VM-utilization-historic_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"VM-utilization-historic_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"VM-utilization-historic_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"advisor-recommendations-processing_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"advisor-recommendations-processing_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"advisor-recommendations-processing_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"calculate-missing-application-cost_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"calculate-missing-application-cost_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"calculate-missing-application-cost_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"check-hub-deployment_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"check-hub-deployment_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"check-hub-deployment_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"check-subscription-diff_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"check-subscription-diff_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"check-subscription-diff_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"check-subscription-quality_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"check-subscription-quality_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"check-subscription-quality_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"combine-recommendations-and-autofitcombometer_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"combine-recommendations-and-autofitcombometer_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"combine-recommendations-and-autofitcombometer_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"compute-cumulative-cost_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"compute-cumulative-cost_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"compute-cumulative-cost_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"compute-hub-and-ri-savings_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"compute-hub-and-ri-savings_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"compute-hub-and-ri-savings_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"compute-overcharged-cost_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"compute-overcharged-cost_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"compute-overcharged-cost_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"compute-savings-plan-savings_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"compute-savings-plan-savings_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"compute-savings-plan-savings_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"cost-extend-utilities_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"cost-extend-utilities_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"cost-extend-utilities_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"daily-cost-extend-v3_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"daily-cost-extend-v3_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"daily-cost-extend-v3_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"fetch-billing-periods_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"fetch-billing-periods_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"fetch-billing-periods_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"monthly-cost-extend-v3_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"monthly-cost-extend-v3_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"monthly-cost-extend-v3_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"persist-latest-pricesheet_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"persist-latest-pricesheet_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"persist-latest-pricesheet_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"predict-service-cost_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"predict-service-cost_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"predict-service-cost_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"process-azure-services_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"process-azure-services_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"process-azure-services_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"process-benefit-purchases_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"process-benefit-purchases_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"process-benefit-purchases_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"servicenow-application-processing_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"servicenow-application-processing_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"servicenow-application-processing_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"servicenow-subscription-processing_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"servicenow-subscription-processing_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"servicenow-subscription-processing_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"sql-hub-deployments_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"sql-hub-deployments_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"sql-hub-deployments_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"test-core-assignment_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"test-core-assignment_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"test-core-assignment_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"usersWithBusinessAreaSnapshot_v1_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"usersWithBusinessAreaSnapshot_v1_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"usersWithBusinessAreaSnapshot_v1_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"usersWithManagerSnapshot_v1_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"usersWithManagerSnapshot_v1_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"usersWithManagerSnapshot_v1_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"validate-historic-total-cost_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sparkpool32"
		},
		"validate-historic-total-cost_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sparkpool32"
		},
		"validate-historic-total-cost_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sparkpool32"
		},
		"vm-hub-deployments_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"vm-hub-deployments_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"vm-hub-deployments_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"wbs-owner-lookup_notebookSparkPoolNameRef": {
			"type": "string",
			"defaultValue": "sprkpool33large"
		},
		"wbs-owner-lookup_notebookSparkPoolIdRef": {
			"type": "string",
			"defaultValue": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Synapse/workspaces/s037-cost-management/bigDataPools/sprkpool33large"
		},
		"wbs-owner-lookup_notebookSparkPoolEndpointRef": {
			"type": "string",
			"defaultValue": "https://s037-cost-management.dev.azuresynapse.net/livyApi/versions/2019-11-01-preview/sparkPools/sprkpool33large"
		},
		"sparkpool32_delayInMinutes": {
			"type": "int",
			"defaultValue": 15
		},
		"sparkpool32_maxNodeCount": {
			"type": "int",
			"defaultValue": 5
		},
		"sparkpool32_minNodeCount": {
			"type": "int",
			"defaultValue": 3
		},
		"sparkpool32_nodeCount": {
			"type": "int",
			"defaultValue": 0
		},
		"sparkpool32_nodeSize": {
			"type": "string",
			"defaultValue": "Medium"
		},
		"sparkpool32_sparkVersion": {
			"type": "string",
			"defaultValue": "3.2"
		},
		"sprkpool33large_delayInMinutes": {
			"type": "int",
			"defaultValue": 10
		},
		"sprkpool33large_maxNodeCount": {
			"type": "int",
			"defaultValue": 12
		},
		"sprkpool33large_minNodeCount": {
			"type": "int",
			"defaultValue": 3
		},
		"sprkpool33large_nodeCount": {
			"type": "int",
			"defaultValue": 3
		},
		"sprkpool33large_nodeSize": {
			"type": "string",
			"defaultValue": "Large"
		},
		"sprkpool33large_sparkVersion": {
			"type": "string",
			"defaultValue": "3.3"
		}
	},
	"variables": {
		"workspaceId": "[concat('Microsoft.Synapse/workspaces/', parameters('workspaceName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('workspaceName'), '/Ad-hoc Combined Extend AI column and WBS tags - Extended Parquet')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Extend AI column and WBS tags",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "AdHoc Extend AI column and WBS tags",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"toDate": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"AmortizedCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyAmortizedCost/"
					},
					"Container": {
						"type": "String",
						"defaultValue": "usage"
					},
					"ActualCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyActualCost/"
					},
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Ad-hoc Combined Extend AI column and WBS tags - Extended Parquet_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-07-05T08:10:16Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/AdHoc Extend AI column and WBS tags')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Ad-hoc Convert CSV Cost files to Parquet')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Convert Amortised Cost CSV to Parquet",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Delete Amortized Cost Parquet",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": {
										"value": "@concat(variables('AmortizedCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Adhoc_CSV_Source",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Monthly_Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat(variables('AmortizedCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"Container": {
										"value": "@variables('Container')",
										"type": "Expression"
									},
									"toDate_fromDate": {
										"value": "@concat(variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Set toDate to be last day of month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "toDate",
							"value": {
								"value": "@replace(replace(adddays(formatDateTime(adddays(formatDateTime(concat(pipeline().parameters.Year,'-',pipeline().parameters.Month,'-01'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000',''),'-','')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set first day of month",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "fromDate",
							"value": {
								"value": "@concat(pipeline().parameters.Year,pipeline().parameters.Month,'01')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Convert Actual Cost CSV to Parquet",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Delete Actual Cost Parquet",
								"dependencyConditions": [
									"Completed"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": {
										"value": "@concat(variables('ActualCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Adhoc_CSV_Source",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Monthly_Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat(variables('ActualCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"Container": {
										"value": "@variables('Container')",
										"type": "Expression"
									},
									"toDate_fromDate": {
										"value": "@concat(variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Delete Actual Cost Parquet",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Set toDate to be last day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "Parquet_for_Deletion",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat(variables('ActualCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"Container": {
										"value": "@variables('Container')",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": false,
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Delete Amortized Cost Parquet",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Set toDate to be last day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "Parquet_for_Deletion",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat(variables('AmortizedCost_Path'),variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"Container": {
										"value": "@variables('Container')",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": false,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Month": {
						"type": "string",
						"defaultValue": "09"
					},
					"Year": {
						"type": "string",
						"defaultValue": "2018"
					}
				},
				"variables": {
					"toDate": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"AmortizedCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyAmortizedCost/"
					},
					"Container": {
						"type": "String",
						"defaultValue": "usage"
					},
					"ActualCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyActualCost/"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-12-21T10:43:26Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/Adhoc_CSV_Source')]",
				"[concat(variables('workspaceId'), '/datasets/Monthly_Parquet')]",
				"[concat(variables('workspaceId'), '/datasets/Parquet_for_Deletion')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Ad-hoc Extend AI Column - Extended Parquet')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set toDate to be last day of month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "toDate",
							"value": {
								"value": "@replace(replace(adddays(formatDateTime(adddays(formatDateTime(concat(pipeline().parameters.Year,'-',pipeline().parameters.Month,'-01'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000',''),'-','')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set first day of month",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "fromDate",
							"value": {
								"value": "@concat(pipeline().parameters.Year,pipeline().parameters.Month,'01')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Extend Cost File_v2",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Set toDate to be last day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Extend Cost File_v2",
								"type": "NotebookReference"
							},
							"parameters": {
								"toDate": {
									"value": {
										"value": "@variables('toDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"fromDate": {
									"value": {
										"value": "@variables('fromDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"amortizedCostPath": {
									"value": {
										"value": "@variables('AmortizedCost_Path')",
										"type": "Expression"
									},
									"type": "string"
								},
								"actualCostPath": {
									"value": {
										"value": "@variables('ActualCost_Path')",
										"type": "Expression"
									},
									"type": "string"
								},
								"container": {
									"value": {
										"value": "@variables('Container')",
										"type": "Expression"
									},
									"type": "string"
								},
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"executorSize": "Medium",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Medium"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Month": {
						"type": "string",
						"defaultValue": "11"
					},
					"Year": {
						"type": "string",
						"defaultValue": "2022"
					}
				},
				"variables": {
					"toDate": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"AmortizedCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyAmortizedCost/"
					},
					"Container": {
						"type": "String",
						"defaultValue": "usage"
					},
					"ActualCost_Path": {
						"type": "String",
						"defaultValue": "exports/monthly/ACMMonthlyActualCost/"
					},
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Ad-hoc Extend AI Column - Extended Parquet_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-07-19T12:40:34Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Extend Cost File_v2')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Authenticate FinOps Service Principal')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get SP client secret",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://acm-toolkit-kv.vault.azure.net/secrets/sp-password/127d0505066d4ae6913e286bab8cc79c?api-version=7.0",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Get client credentials token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get SP client secret",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/token",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('client_id=4c1cded2-f7a7-4c00-8d65-0a3287cbd682&client_secret=',activity('Get SP client secret').output.value,'&grant_type=client_credentials&resource=https://management.azure.com&scope=./default')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Azure AD Users_v1')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Azure AD Users",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "RestSource",
								"httpRequestTimeout": "00:01:40",
								"requestInterval": "00.00:00:00.010",
								"requestMethod": "GET",
								"paginationRules": {
									"supportRFC5988": "true",
									"AbsoluteUrl": "$['@odata.nextLink']"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "['employeeId']"
										},
										"sink": {
											"name": "employeeId",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['displayName']"
										},
										"sink": {
											"name": "displayName",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['userPrincipalName']"
										},
										"sink": {
											"name": "userPrincipalName",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['accountEnabled']"
										},
										"sink": {
											"name": "accountEnabled",
											"type": "Boolean"
										}
									},
									{
										"source": {
											"path": "['department']"
										},
										"sink": {
											"name": "department",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['officeLocation']"
										},
										"sink": {
											"name": "officeLocation",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['country']"
										},
										"sink": {
											"name": "country",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['city']"
										},
										"sink": {
											"name": "city",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['manager']['employeeId']"
										},
										"sink": {
											"name": "manager_employeeId",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['manager']['displayName']"
										},
										"sink": {
											"name": "manager_displayName",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['manager']['userPrincipalName']"
										},
										"sink": {
											"name": "manager_userPrincipalName",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "['manager']['department']"
										},
										"sink": {
											"name": "manager_department",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "AzureAD_Users",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Parquet_File",
								"type": "DatasetReference",
								"parameters": {
									"fileName": "AzureAD_EmployeesManagersSnapshot",
									"path": "AzureAD_BusinessAreaLevel/bronze/"
								}
							}
						]
					},
					{
						"name": "usersWithManagerSnapshot_1",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Azure AD Users",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 2,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "usersWithManagerSnapshot_v1",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('Azure AD Users_v1_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"driverSize": "Small",
							"numExecutors": null
						}
					},
					{
						"name": "usersWithBusinessAreaSnapshot_v1",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "usersWithManagerSnapshot_1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 2,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "usersWithBusinessAreaSnapshot_v1",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('Azure AD Users_v1_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"driverSize": "Small",
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('Azure AD Users_v1_pipelineStorageAccountParameter')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Microsoft Graph API"
				},
				"annotations": [],
				"lastPublishTime": "2023-09-07T09:35:20Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/AzureAD_Users')]",
				"[concat(variables('workspaceId'), '/datasets/Parquet_File')]",
				"[concat(variables('workspaceId'), '/notebooks/usersWithManagerSnapshot_v1')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('Azure AD Users_v1_pipelineSparkPoolNameRef'))]",
				"[concat(variables('workspaceId'), '/notebooks/usersWithBusinessAreaSnapshot_v1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Azure Advisor Recommendations')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Azure Subscriptions",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://management.azure.com/subscriptions?api-version=2022-12-01",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "ServicePrincipal",
								"userTenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
								"username": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
								"resource": "https://management.azure.com",
								"password": {
									"type": "AzureKeyVaultSecret",
									"store": {
										"referenceName": "ACM_Toolkit_kv",
										"type": "LinkedServiceReference"
									},
									"secretName": "sp-password"
								}
							}
						}
					},
					{
						"name": "Get advisor cost recommendations",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Azure Subscriptions",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Azure Subscriptions').output.value",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Azure Advisor Subscription Recommendations",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "RestSource",
											"additionalColumns": [
												{
													"name": "subscriptionId",
													"value": {
														"value": "@item().subscriptionId",
														"type": "Expression"
													}
												}
											],
											"httpRequestTimeout": "00:01:40",
											"requestInterval": "00.00:00:00.010",
											"requestMethod": "GET",
											"paginationRules": {
												"supportRFC5988": "true"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"path": "['properties']['category']"
													},
													"sink": {
														"name": "category",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['impact']"
													},
													"sink": {
														"name": "impact",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['impactField']"
													},
													"sink": {
														"name": "impactField",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['impactedValue']"
													},
													"sink": {
														"name": "impactedValue",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['lastUpdated']"
													},
													"sink": {
														"name": "lastUpdated",
														"type": "DateTimeOffset"
													}
												},
												{
													"source": {
														"path": "['properties']['recommendationTypeId']"
													},
													"sink": {
														"name": "recommendationTypeId",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['shortDescription']['problem']"
													},
													"sink": {
														"name": "problem",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['shortDescription']['solution']"
													},
													"sink": {
														"name": "solution",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['subId']"
													},
													"sink": {
														"name": "subId",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['sku']"
													},
													"sink": {
														"name": "sku",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['scope']"
													},
													"sink": {
														"name": "scope",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['commitment']"
													},
													"sink": {
														"name": "commitment",
														"type": "Double"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['annualSavingsAmount']"
													},
													"sink": {
														"name": "annualSavingsAmount",
														"type": "Int32"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['savingsAmount']"
													},
													"sink": {
														"name": "savingsAmount",
														"type": "Int32"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['savingsCurrency']"
													},
													"sink": {
														"name": "savingsCurrency",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['term']"
													},
													"sink": {
														"name": "term",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['lookbackPeriod']"
													},
													"sink": {
														"name": "lookbackPeriod",
														"type": "Int32"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['qty']"
													},
													"sink": {
														"name": "qty",
														"type": "Int32"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['reservedResourceType']"
													},
													"sink": {
														"name": "reservedResourceType",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['region']"
													},
													"sink": {
														"name": "region",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['properties']['extendedProperties']['targetResourceCount']"
													},
													"sink": {
														"name": "targetResourceCount",
														"type": "Int32"
													}
												},
												{
													"source": {
														"path": "['id']"
													},
													"sink": {
														"name": "id",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "['name']"
													},
													"sink": {
														"name": "name",
														"type": "String"
													}
												},
												{
													"source": {
														"path": "$['subscriptionId']"
													},
													"sink": {
														"name": "subscriptionId",
														"type": "String"
													}
												}
											],
											"collectionReference": "$['value']",
											"mapComplexValuesToString": false
										}
									},
									"inputs": [
										{
											"referenceName": "AzureAdvisorRecommendationSource",
											"type": "DatasetReference",
											"parameters": {
												"subscriptionId": {
													"value": "@item().subscriptionId",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "AzureAdvisorRecommendationsSink",
											"type": "DatasetReference",
											"parameters": {
												"subscriptionId": {
													"value": "@item().subscriptionId",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					},
					{
						"name": "Write recommendations to aggregate file",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Get advisor cost recommendations",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "advisor-recommendations-processing",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('Azure Advisor Recommendations_pipelineStorageAccountParameter')]"
					}
				},
				"variables": {
					"SubscriptionId": {
						"type": "String"
					},
					"recommendations": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/notebooks/advisor-recommendations-processing')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]",
				"[concat(variables('workspaceId'), '/datasets/AzureAdvisorRecommendationSource')]",
				"[concat(variables('workspaceId'), '/datasets/AzureAdvisorRecommendationsSink')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CSV_to_Parquet')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Convert Monthly CSV to Parquet",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"wildcardFolderPath": {
										"value": "@concat('/usage/monthly/',pipeline().parameters.Year_yyyy,'/',pipeline().parameters.Month_mm,'/')",
										"type": "Expression"
									},
									"wildcardFileName": "*-cleaned.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "AccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedQuantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedQuantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedServiceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedServiceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Cost",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Cost",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "DepartmentId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DepartmentId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InstanceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InstanceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Product",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Product",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceRate",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceRate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceAdministratorId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceAdministratorId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "StoreServiceIdentifier",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "StoreServiceIdentifier",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionGuid",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionGuid",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGuid",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGuid",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargesBilledSeparately",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargesBilledSeparately",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Location",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Location",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceTier",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceTier",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": false,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "CSV_Source_File",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Parquet_Monthly",
								"type": "DatasetReference",
								"parameters": {
									"Year_yyyy": {
										"value": "@pipeline().parameters.Year_yyyy",
										"type": "Expression"
									},
									"Month_mm": {
										"value": "@pipeline().parameters.Month_mm",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year_yyyy": {
						"type": "string"
					},
					"Month_mm": {
						"type": "string"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Tools"
				},
				"annotations": [],
				"lastPublishTime": "2022-09-16T16:05:28Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/CSV_Source_File')]",
				"[concat(variables('workspaceId'), '/datasets/Parquet_Monthly')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CSV_to_Parquet_Provide_Path_New_CSV_FileType')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Convert Monthly CSV to Parquet",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"wildcardFolderPath": {
										"value": "@concat('/usage/',pipeline().parameters.Path,'/')",
										"type": "Expression"
									},
									"wildcardFileName": {
										"value": "@concat(pipeline().parameters.Filename,'.csv')",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": false,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "CSV_Source_File",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Parquet_File",
								"type": "DatasetReference",
								"parameters": {
									"fileName": {
										"value": "@pipeline().parameters.Filename",
										"type": "Expression"
									},
									"path": {
										"value": "@pipeline().parameters.Path",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Path": {
						"type": "string",
						"defaultValue": "exports/monthly/ACMMonthlyActualCost/20220901-20220930"
					},
					"Filename": {
						"type": "string",
						"defaultValue": "ACMMonthlyActualCost_2775e2de-d323-4b84-8dcf-78ad47d2e0c5"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Tools"
				},
				"annotations": [],
				"lastPublishTime": "2022-10-06T10:12:20Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/CSV_Source_File')]",
				"[concat(variables('workspaceId'), '/datasets/Parquet_File')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Convert CSV to Parquet')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Convert CSV to Parquet",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": {
										"value": "@pipeline().parameters.Path",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Adhoc_CSV_Source",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Monthly_Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@pipeline().parameters.Path",
										"type": "Expression"
									},
									"Container": {
										"value": "@pipeline().parameters.Container",
										"type": "Expression"
									},
									"toDate_fromDate": null
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Path": {
						"type": "string",
						"defaultValue": "exports/monthly/ACMMonthlyAmortizedCost/2020*"
					},
					"Container": {
						"type": "string",
						"defaultValue": "usage"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-12-19T16:30:52Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/Adhoc_CSV_Source')]",
				"[concat(variables('workspaceId'), '/datasets/Monthly_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily VM Utilization')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get Azure Subscriptions",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://management.azure.com/subscriptions?api-version=2022-12-01",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "ServicePrincipal",
								"userTenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
								"username": "c282b841-bb78-4904-aba9-4aebf02ccb71",
								"resource": "https://management.azure.com",
								"password": {
									"type": "AzureKeyVaultSecret",
									"store": {
										"referenceName": "ACM_Toolkit_kv",
										"type": "LinkedServiceReference"
									},
									"secretName": "Azure-Cost-Management-Metrics-Reader-secret"
								}
							}
						}
					},
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Azure Subscriptions",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Azure Subscriptions').output.value",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Fetch and store VM utilization data",
									"type": "SynapseNotebook",
									"dependsOn": [
										{
											"activity": "Get resource locations in subscription",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"notebook": {
											"referenceName": "VM-utilization-fetch",
											"type": "NotebookReference"
										},
										"parameters": {
											"subscriptionId": {
												"value": {
													"value": "@item().subscriptionId",
													"type": "Expression"
												},
												"type": "string"
											},
											"startDate": {
												"value": {
													"value": "@formatDateTime(addDays(utcNow(), -1), 'yyyy-MM-dd')",
													"type": "Expression"
												},
												"type": "string"
											},
											"storageAccount": {
												"value": {
													"value": "@pipeline().parameters.storageAccount",
													"type": "Expression"
												},
												"type": "string"
											}
										},
										"snapshot": true,
										"conf": {
											"spark.dynamicAllocation.enabled": null,
											"spark.dynamicAllocation.minExecutors": null,
											"spark.dynamicAllocation.maxExecutors": null
										},
										"numExecutors": null
									}
								},
								{
									"name": "Get resource locations in subscription",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "RestSource",
											"httpRequestTimeout": "00:01:40",
											"requestInterval": "00.00:00:00.010",
											"requestMethod": "GET"
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"path": "['location']"
													},
													"sink": {
														"name": "location",
														"type": "String"
													}
												}
											],
											"collectionReference": "$['value']"
										}
									},
									"inputs": [
										{
											"referenceName": "AzureSubscriptionResources",
											"type": "DatasetReference",
											"parameters": {
												"subscriptionId": {
													"value": "@item().subscriptionId",
													"type": "Expression"
												},
												"resourceType": "'Microsoft.Compute/virtualMachines'"
											}
										}
									],
									"outputs": [
										{
											"referenceName": "SubscriptionResourceLocations",
											"type": "DatasetReference",
											"parameters": {
												"subscriptionId": {
													"value": "@item().subscriptionId",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					},
					{
						"name": "Run 3 month aggregation",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "ForEach1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "VM-utilization-aggregation",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								},
								"currentDate": {
									"value": {
										"value": "@formatDateTime(utcNow(), 'yyyy-MM-dd')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('Daily VM Utilization_pipelineStorageAccountParameter')]"
					}
				},
				"variables": {
					"resourceType": {
						"type": "String",
						"defaultValue": "'Microsoft.Compute/virtualMachines'"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/notebooks/VM-utilization-aggregation')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]",
				"[concat(variables('workspaceId'), '/notebooks/VM-utilization-fetch')]",
				"[concat(variables('workspaceId'), '/datasets/AzureSubscriptionResources')]",
				"[concat(variables('workspaceId'), '/datasets/SubscriptionResourceLocations')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Daily Actual Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Extend Actual Cost",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Extend Daily Cost",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"ReportType": "ActualCost"
							}
						}
					},
					{
						"name": "Run cumulative cost prediction",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Extend Actual Cost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "compute-cumulative-cost",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Extend Daily Actual Cost_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Daily Cost')]",
				"[concat(variables('workspaceId'), '/notebooks/compute-cumulative-cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Daily Amortized Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Extend Amortized COst",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Extend Daily Cost",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"ReportType": "AmortizedCost"
							}
						}
					},
					{
						"name": "Update 3year cost file",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Extend Amortized COst",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Prod_Extended_Amortized_Cost-Threeyears",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Update 1year cost file",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Update 3year cost file",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Prod_Extended_Amortized_Cost-Oneyear",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Run anomaly detection",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Update 1year cost file",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Anomaly_Detection_v2",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Extend Daily Amortized Cost_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Daily Cost')]",
				"[concat(variables('workspaceId'), '/notebooks/Prod_Extended_Amortized_Cost-Threeyears')]",
				"[concat(variables('workspaceId'), '/notebooks/Prod_Extended_Amortized_Cost-Oneyear')]",
				"[concat(variables('workspaceId'), '/notebooks/Anomaly_Detection_v2')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Daily Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set last day in Month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "toDate",
							"value": {
								"value": "@replace(replace(adddays(formatDateTime(adddays(formatDateTime(formatDateTime(utcnow(),'yyyy-MM-01'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000',''),'-','')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set first day of month",
						"description": "",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "fromDate",
							"value": {
								"value": "@concat(formatDateTime(utcnow(),'yyyyMM01'))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set Date Range",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set last day in Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "dateRange",
							"value": {
								"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Actual Cost Files modified more than 1 day ago",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Set Date Range",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "ds_test_delete_files",
								"type": "DatasetReference",
								"parameters": {
									"ReportType": {
										"value": "@pipeline().parameters.ReportType",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"modifiedDatetimeEnd": {
									"value": "@addHours(utcnow(),-12)",
									"type": "Expression"
								},
								"wildcardFileName": "*",
								"enablePartitionDiscovery": false
							}
						}
					},
					{
						"name": "Get Actual Cost folders modied more than 1 day ago",
						"type": "GetMetadata",
						"dependsOn": [
							{
								"activity": "Delete Actual Cost Files modified more than 1 day ago",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "Older_Files_For_Deletion_Binary",
								"type": "DatasetReference",
								"parameters": {
									"ReportType": {
										"value": "@pipeline().parameters.ReportType",
										"type": "Expression"
									}
								}
							},
							"fieldList": [
								"childItems"
							],
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": true,
								"modifiedDatetimeEnd": {
									"value": "@addHours(utcnow(),-12)",
									"type": "Expression"
								},
								"enablePartitionDiscovery": false
							},
							"formatSettings": {
								"type": "BinaryReadSettings"
							}
						}
					},
					{
						"name": "For Each AC Folder",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Get Actual Cost folders modied more than 1 day ago",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('Get Actual Cost folders modied more than 1 day ago').output.childItems",
								"type": "Expression"
							},
							"isSequential": false,
							"activities": [
								{
									"name": "Get AC Item Metadata",
									"type": "GetMetadata",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"dataset": {
											"referenceName": "ds_Test_delete_file",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@item().name",
													"type": "Expression"
												},
												"ReportType": {
													"value": "@pipeline().parameters.ReportType",
													"type": "Expression"
												}
											}
										},
										"fieldList": [
											"childItems"
										],
										"storeSettings": {
											"type": "AzureBlobFSReadSettings",
											"recursive": true,
											"enablePartitionDiscovery": false
										},
										"formatSettings": {
											"type": "BinaryReadSettings"
										}
									}
								},
								{
									"name": "If AC Folder Empty",
									"type": "IfCondition",
									"dependsOn": [
										{
											"activity": "Get AC Item Metadata",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"expression": {
											"value": "@empty(activity('Get AC Item Metadata').output.childItems)",
											"type": "Expression"
										},
										"ifTrueActivities": [
											{
												"name": "Delete Empty AC Folder",
												"type": "Delete",
												"dependsOn": [],
												"policy": {
													"timeout": "0.12:00:00",
													"retry": 0,
													"retryIntervalInSeconds": 30,
													"secureOutput": false,
													"secureInput": false
												},
												"userProperties": [],
												"typeProperties": {
													"dataset": {
														"referenceName": "ds_Test_delete_file",
														"type": "DatasetReference",
														"parameters": {
															"Path": {
																"value": "@item().name",
																"type": "Expression"
															},
															"ReportType": {
																"value": "@pipeline().parameters.ReportType",
																"type": "Expression"
															}
														}
													},
													"enableLogging": false,
													"storeSettings": {
														"type": "AzureBlobFSReadSettings",
														"recursive": true,
														"enablePartitionDiscovery": false
													}
												}
											}
										]
									}
								}
							]
						}
					},
					{
						"name": "Create Actual Cost Parquet File",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "For Each AC Folder",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"wildcardFolderPath": {
										"value": "@concat('exports/daily/ACMDaily',pipeline().parameters.ReportType, '/', variables('dateRange'))",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ds_CSV_File",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ds_Daily_Parquet_File",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat('exports/daily/ACMDaily',pipeline().parameters.ReportType)",
										"type": "Expression"
									},
									"reportType": {
										"value": "@pipeline().parameters.ReportType",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "If today is the 1st of the Month",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Create Actual Cost Parquet File",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@equals(dayOfMonth(utcnow()),1)",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "Get last day of previous month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Get first day of previous month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@concat(formatDateTime(addDays(utcnow(), -1),'yyyyMMdd'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Get first day of previous month",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(formatDateTime(addDays(utcnow(), -1),'yyyyMM01'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy daily file to Monthly folder",
									"description": "Copy daily file to monthly folder as it is 1st of the month. This places a file in the monthly folder so the union SQL queries will work. This file will be overwritten when Microsoft pushes the official monthly file on the 5th of every month.",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Get last day of previous month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "ParquetSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "ParquetReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "ds_Daily_Parquet_File",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@concat('exports/daily/ACMDaily',pipeline().parameters.ReportType)",
													"type": "Expression"
												},
												"reportType": {
													"value": "@pipeline().parameters.ReportType",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "Monthly_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.ReportType,'/',variables('fromDate'),'-',variables('toDate'))",
													"type": "Expression"
												},
												"Container": "usage",
												"toDate_fromDate": {
													"value": "@concat(variables('fromDate'),'-',variables('toDate'))",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					},
					{
						"name": "run cost extension v3 daily",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "If today is the 1st of the Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "daily-cost-extend-v3",
								"type": "NotebookReference"
							},
							"parameters": {
								"toDate": {
									"value": {
										"value": "@variables('toDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"fromDate": {
									"value": {
										"value": "@variables('fromDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								},
								"reportType": {
									"value": {
										"value": "@pipeline().parameters.ReportType",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('Extend Daily Cost_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Medium",
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"driverSize": "Medium",
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"ReportType": {
						"type": "string"
					}
				},
				"variables": {
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					},
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Extend Daily Cost_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ds_test_delete_files')]",
				"[concat(variables('workspaceId'), '/datasets/Older_Files_For_Deletion_Binary')]",
				"[concat(variables('workspaceId'), '/datasets/ds_CSV_File')]",
				"[concat(variables('workspaceId'), '/datasets/ds_Daily_Parquet_File')]",
				"[concat(variables('workspaceId'), '/notebooks/daily-cost-extend-v3')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('Extend Daily Cost_pipelineSparkPoolNameRef'))]",
				"[concat(variables('workspaceId'), '/datasets/ds_Test_delete_file')]",
				"[concat(variables('workspaceId'), '/datasets/Monthly_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Monthly Actual Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Extend Monthly Actual Cost",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Extend Monthly Cost",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"reportType": "ActualCost"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Monthly Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Monthly Amortized Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Extend Monthly Amortized Cost",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "Extend Monthly Cost",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"reportType": "AmortizedCost"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Monthly Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Monthly Cost')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set Month",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Month",
							"value": {
								"value": "@if(\n    equals(int(formatdatetime(utcnow(),'MM')),1),\n    '12',\n    if(\n        less(sub(int(formatdatetime(utcnow(),'MM')),10),1),\n            concat('0',string(sub(int(formatdatetime(utcnow(),'MM')),1))),\n            string(sub(int(formatdatetime(utcnow(),'MM')),1))))\n",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set Year",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Year",
							"value": {
								"value": "@if(\n    equals(int(formatDateTime(utcNow(), 'MM')), 01),\n     string(sub(int(formatDateTime(utcNow(), 'yyyy')),1)),\n     string(int(formatDateTime(utcNow(), 'yyyy'))))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set first day of month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set Year",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "fromDate",
							"value": {
								"value": "@concat(variables('Year'),variables('Month'),'01')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set last day of the month date",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "toDate",
							"value": {
								"value": "@replace(replace(adddays(formatDateTime(adddays(formatDateTime(concat(variables('Year'),'-',variables('Month'),'-01'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000',''),'-','')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Convert Amortised Cost CSV to Parquet",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set last day of the month date",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": {
										"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.reportType,'/',variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "Adhoc_CSV_Source",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "Monthly_Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.reportType,'/',variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									},
									"Container": {
										"value": "@variables('Container')",
										"type": "Expression"
									},
									"toDate_fromDate": {
										"value": "@concat(variables('fromDate'),'-',variables('toDate'))",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Extend cost data v3",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Convert Amortised Cost CSV to Parquet",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "monthly-cost-extend-v3",
								"type": "NotebookReference"
							},
							"parameters": {
								"toDate": {
									"value": {
										"value": "@variables('toDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"fromDate": {
									"value": {
										"value": "@variables('fromDate')",
										"type": "Expression"
									},
									"type": "string"
								},
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								},
								"reportType": {
									"value": {
										"value": "@pipeline().parameters.reportType",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('Extend Monthly Cost_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Large",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Large"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"reportType": {
						"type": "string",
						"defaultValue": "ActualCost"
					}
				},
				"variables": {
					"Month": {
						"type": "String"
					},
					"Year": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Container": {
						"type": "String",
						"defaultValue": "usage"
					},
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('Extend Monthly Cost_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/Adhoc_CSV_Source')]",
				"[concat(variables('workspaceId'), '/datasets/Monthly_Parquet')]",
				"[concat(variables('workspaceId'), '/notebooks/monthly-cost-extend-v3')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('Extend Monthly Cost_pipelineSparkPoolNameRef'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Loop - Get Daily Usage Data')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Post Consumption Request",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get Bearer",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@{concat('Bearer ',activity('Get Bearer').output.value)}",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://consumption.azure.com/v3/enrollments/57950773/usagedetails/submit?startTime=',pipeline().parameters.day,'&endTime=',pipeline().parameters.day)",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": "{}"
						}
					},
					{
						"name": "Until Data Ready",
						"type": "Until",
						"dependsOn": [
							{
								"activity": "Post Consumption Request",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@bool(not(empty(activity('Check Status').output.blobPath)))",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "Check Status",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "GET",
										"headers": {
											"Authorization": {
												"value": "@{concat('Bearer ',activity('Get Bearer').output.value)}",
												"type": "Expression"
											}
										},
										"url": {
											"value": "@activity('Post Consumption Request').output.reportUrl",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										}
									}
								},
								{
									"name": "Waiting for Data",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "Check Status",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 30
									}
								}
							],
							"timeout": "0.01:00:00"
						}
					},
					{
						"name": "Set blobPath",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Until Data Ready",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "blobPath",
							"value": {
								"value": "@activity('Check Status').output.blobPath",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Get Bearer",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://acm-toolkit-kv.vault.azure.net/secrets/EA-API-PRI-KEY/d222708c46d54a0abd273cc0877b6aad?api-version=7.0",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Copy file from MS to Synapse datastore_copy1",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set blobPath",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "HttpReadSettings",
									"requestMethod": "GET",
									"requestTimeout": ""
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ms_billing_output_file",
								"type": "DatasetReference",
								"parameters": {
									"blobPath": {
										"value": "@variables('blobPath')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "S037_Usage_DataSet",
								"type": "DatasetReference",
								"parameters": {
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"Scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "CSV to Parquet remove first 2 rows",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy file from MS to Synapse datastore_copy1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"wildcardFolderPath": "daily",
									"wildcardFileName": {
										"value": "@concat(pipeline().parameters.day,'-raw.csv')",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings",
									"skipLineCount": 1
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "AccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedQuantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedQuantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedServiceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedServiceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Cost",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Cost",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "DepartmentId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DepartmentId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InstanceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InstanceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Product",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Product",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceRate",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceRate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceAdministratorId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceAdministratorId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "StoreServiceIdentifier",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "StoreServiceIdentifier",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionGuid",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionGuid",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGuid",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGuid",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargesBilledSeparately",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargesBilledSeparately",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Location",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Location",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceTier",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceTier",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "S037CSVSourceDataset",
								"type": "DatasetReference",
								"parameters": {
									"Year": {
										"value": "\"NA\"",
										"type": "Expression"
									},
									"Month": {
										"value": "NA",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									},
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "S037Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Year": {
										"value": "NA",
										"type": "Expression"
									},
									"Month": {
										"value": "NA",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"Scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Cleaned Parquet to CSV",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "CSV to Parquet remove first 2 rows",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "ParquetSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"enablePartitionDiscovery": false
								}
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "S037Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Year": {
										"value": "NA",
										"type": "Expression"
									},
									"Month": {
										"value": "NA",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"Scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "S037_Cleaned_CSV_Dest",
								"type": "DatasetReference",
								"parameters": {
									"Year": {
										"value": "NA",
										"type": "Expression"
									},
									"Month": {
										"value": "NA",
										"type": "Expression"
									},
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"Scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "Delete Raw File",
						"type": "Delete",
						"dependsOn": [
							{
								"activity": "Cleaned Parquet to CSV",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataset": {
								"referenceName": "S037_Usage_DataSet",
								"type": "DatasetReference",
								"parameters": {
									"fromDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"toDate": {
										"value": "@pipeline().parameters.day",
										"type": "Expression"
									},
									"Scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									}
								}
							},
							"enableLogging": false,
							"storeSettings": {
								"type": "AzureBlobFSReadSettings",
								"recursive": false,
								"enablePartitionDiscovery": false
							}
						}
					}
				],
				"concurrency": 3,
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"day": {
						"type": "string"
					}
				},
				"variables": {
					"blobPath": {
						"type": "String"
					},
					"Scope": {
						"type": "String",
						"defaultValue": "daily"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Consumption API (Old)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-18T13:45:17Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ms_billing_output_file')]",
				"[concat(variables('workspaceId'), '/datasets/S037_Usage_DataSet')]",
				"[concat(variables('workspaceId'), '/datasets/S037CSVSourceDataset')]",
				"[concat(variables('workspaceId'), '/datasets/S037Parquet')]",
				"[concat(variables('workspaceId'), '/datasets/S037_Cleaned_CSV_Dest')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - ActualCost - Histrorical Pull')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Post Consumption Request",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
									"type": "Expression"
								},
								"Content-type": "application/json"
							},
							"url": {
								"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"metric\": \"ActualCost\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,pipeline().parameters.Month,'\"\n  }')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set blobPath",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Post Consumption Request",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "blobPath",
							"value": {
								"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Copy file from MS to Synapse datastore",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Set blobPath",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Set ActualUsage Path",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "BinarySource",
								"storeSettings": {
									"type": "HttpReadSettings",
									"requestMethod": "GET"
								},
								"formatSettings": {
									"type": "BinaryReadSettings"
								}
							},
							"sink": {
								"type": "BinarySink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								}
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "ms_billing_output_file",
								"type": "DatasetReference",
								"parameters": {
									"blobPath": {
										"value": "@variables('blobPath')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "S037_New_Format_Usage_Data",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@variables('Path')",
										"type": "Expression"
									},
									"dateRange": {
										"value": "@variables('dateRange')",
										"type": "Expression"
									},
									"ReportType": "ActualCost"
								}
							}
						]
					},
					{
						"name": "CSV to Parquet",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Copy file from MS to Synapse datastore",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": false,
									"wildcardFolderPath": {
										"value": "@variables('Path')",
										"type": "Expression"
									},
									"wildcardFileName": {
										"value": "@concat('ACMMonthlyActualCost_',variables('dateRange'),'.csv')",
										"type": "Expression"
									},
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Date",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "Date",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterSubCategory",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "MeterRegion",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitOfMeasure",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EffectivePrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "EffectivePrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostInBillingCurrency",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostInBillingCurrency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ConsumedService",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Tags",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Tags",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "OfferId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AdditionalInfo",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo1",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceInfo2",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "UnitPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "UnitPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ProductOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PublisherName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ChargeType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Frequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PricingModel",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AvailabilityZone",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingAccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingCurrencyCode",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodStartDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingPeriodEndDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingProfileName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InvoiceSectionId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "IsAzureCreditEligible",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PartNumber",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PayGPrice",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "PayGPrice",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PlanName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ServiceFamily",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostAllocationRuleName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "benefitName",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "S037CSVSourceDataset",
								"type": "DatasetReference",
								"parameters": {
									"Year": {
										"value": "@variables('Year')",
										"type": "Expression"
									},
									"Month": {
										"value": "@variables('Month')",
										"type": "Expression"
									},
									"toDate": {
										"value": "@variables('toDate')",
										"type": "Expression"
									},
									"scope": {
										"value": "@variables('Scope')",
										"type": "Expression"
									},
									"fromDate": {
										"value": "@variables('fromDate')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "New_API_Format_Parquet",
								"type": "DatasetReference",
								"parameters": {
									"Path": {
										"value": "@variables('Path')",
										"type": "Expression"
									},
									"dateRange": {
										"value": "@variables('dateRange')",
										"type": "Expression"
									},
									"ReportType": "ActualCost"
								}
							}
						]
					},
					{
						"name": "Set last day in Month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "toDate",
							"value": {
								"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set first day of month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set Year",
								"dependencyConditions": [
									"Succeeded"
								]
							},
							{
								"activity": "Set Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "fromDate",
							"value": {
								"value": "@concat(variables('Year'),'-',variables('Month'),'-01')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set Month",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Month",
							"value": {
								"value": "@pipeline().parameters.Month",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set Year",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Year",
							"value": {
								"value": "@pipeline().parameters.Year",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set ActualUsage Path",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set ActualUsage Date Range",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Path",
							"value": {
								"value": "@concat('exports/monthly/ACMMonthlyActualCost/',variables('dateRange'))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set ActualUsage Date Range",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set last day in Month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "dateRange",
							"value": {
								"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year": {
						"type": "string",
						"defaultValue": "2022"
					},
					"Month": {
						"type": "string",
						"defaultValue": "0"
					},
					"Bearer": {
						"type": "string",
						"defaultValue": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ii1LSTNROW5OUjdiUm9meG1lWm9YcWJIWkdldyIsImtpZCI6Ii1LSTNROW5OUjdiUm9meG1lWm9YcWJIWkdldyJ9.eyJhdWQiOiJodHRwczovL21hbmFnZW1lbnQuY29yZS53aW5kb3dzLm5ldCIsImlzcyI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0LzNhYTRhMjM1LWI2ZTItNDhkNS05MTk1LTdmY2YwNWI0NTliMC8iLCJpYXQiOjE2NzM0NDY0MjAsIm5iZiI6MTY3MzQ0NjQyMCwiZXhwIjoxNjczNDUxNjY0LCJhY3IiOiIxIiwiYWlvIjoiQVZRQXEvOFRBQUFBZXQxV1RSSXlIV3FOUjN4R2kzWEwwMytWcjU3cjFCdGhGOFIyOGlyZkRTdFV4TUZBcnZLOCt4blpBVitSYnZYbHk4Z0t4RXE4Wm1sYUE5MzJGSnB4cEJIdE9icTU0MWl4ZTk4NjhuWHExWWM9IiwiYW1yIjpbInB3ZCIsIm1mYSJdLCJhcHBpZCI6IjE4ZmJjYTE2LTIyMjQtNDVmNi04NWIwLWY3YmYyYjM5YjNmMyIsImFwcGlkYWNyIjoiMCIsImZhbWlseV9uYW1lIjoiRmxvb2QiLCJnaXZlbl9uYW1lIjoiRGF2aWQiLCJncm91cHMiOlsiNmEwZjczMDEtMDM4ZS00MjMxLWFkNTYtNmQwMWFkY2I4NGVmIiwiZDg2MmNhMDItOWQ5OC00NzNkLTk3NjAtNTFjOGVmNjliZWZmIiwiZmZhZWE2MDMtNzU5YS00NDkwLTkzN2MtODc1MjZmNDJkMzFlIiwiZmFjYjA0MDYtYTk5ZS00YjFjLTliZDEtYjU4OTAzYWQ2MGM5IiwiY2JiOWZjMDYtYzVkNi00ODcyLThjODUtNDgwMjRlODljNjQ5IiwiOWViMjYzMDktMzVlMC00YTgwLTk2YWQtZTRjOWVjNTcxMWJlIiwiOTYyOWEyMGEtZWFlYy00OWIzLTk3ODQtMGFlOWE2NTcwZmM5IiwiMWRiNmJhMGMtMWQyZi00ZDc2LTlkYWUtMDg4MWU1OTEzYzVjIiwiY2IzOGMyMGQtZjRhMy00ZWMzLWIyNTgtZWQwMmM5MzY4NGYwIiwiMTkzY2YxMGQtN2RkMC00NmQ3LWExMDEtNDU1ODIwMjM0YTU2IiwiZjYzODQ4MGYtYjI5NS00NzdmLWJkZWEtYjk5ZWQ0MjFkYmEyIiwiMzE5ODllMGYtZDZlNS00OGU3LTk5NTItMTBhN2ZmYWUzYmI4IiwiMDc3ZTM4MTEtNzgzYS00YjlhLTlhNGItNWI5OWU3ZTY3MWMwIiwiMzEwMDQ3MTItZDkwZS00OWY2LTllNzktMmU5N2Y2OGY2ZDUwIiwiMDQ3ZmIwMTItNjk0Yy00NGMzLThkNDgtOTI3Y2IzNDk3ODhjIiwiYjcyYjY4MTQtZDE3Mi00ZTM2LWJiOTAtMGIzZjE1YTkxOTc3IiwiZjJjOTg4MTUtZTE2Ni00ZjkwLWE1ZjQtMWY1MzVmNWVkY2M4IiwiMDViOTZkMTYtYjY0NC00ZmNmLThhZTUtZmYwYzBmODI1YjVmIiwiYmMzOWYyMTctNDQxOS00MjkxLTk1MjctMzU2MTQ3N2EyZmI3IiwiMDAwMzExMWItMGMyZS00MDQxLWIxZGQtMGIyZWQxZWY2Zjc4IiwiMzA3MjhlMWUtNDZmMC00YjYxLWEwYmMtNmJjM2Y3MzYwYjhhIiwiYzY4ZTUwMWYtNmQxZi00YjRiLThmMzctMGM0NjgxNTZkZGYyIiwiNWFmMDk5MjEtZmQ2YS00NjExLTllYTktYTNiZmIxZjM1YmJlIiwiN2VmMzZjMjMtM2Y2Yi00MzIxLWIwMjgtYjgxYTliNDU5OTkxIiwiZGY2NWVhMjMtODhjMy00MzFhLWE4N2YtNjA1NWNmOWJkNTQ5IiwiM2I5NWRhMjctMzM3YS00NGMxLWI2OWQtNTY0NGI1MWE0ODM2IiwiOGZhM2JiMjgtODRmOS00YjA2LWE0ZDUtMDg5MDdlOGRkNmZhIiwiZTA0MGM0MjgtYWM1Ny00NTQyLWEzMjgtMmY2NzJhMzRjY2I4IiwiZTFjYWE0MmEtYmY2OS00MzkxLTlhNWUtYzhjZmRhZTFiNDE3IiwiOWZlNmU2MmEtMzExOC00NzA0LWFmYmUtODM0ODIyY2IwZDQzIiwiMGIxMDJiMmMtM2M5Ny00Yjc2LWI0ZGYtZTAzOTg2ODZhZjU2IiwiNzQ4YTAyMmUtOTY4ZS00YTk0LWFkZTMtOTI0ZTI2YmFkYWE4IiwiZGE1YTMzMmUtMTQ3MC00MGYzLTk4MDMtNDk3NWU1Njk0ZTViIiwiNGY2ZjRlMmYtYjIyMy00ZTczLWIzMzMtNWJiMWY3NjAxNGY0IiwiMjllMDM1MzAtZjgxOC00MDM2LWIyOGItOTdiOGI5NGYyNjUwIiwiYWQ1Nzc4MzItYTBlMS00YTA4LWJiZjQtMTI3MjQzYzZhNzUyIiwiMWRmZWJkMzUtN2U0ZC00ZjM5LTkyMjUtMDExZGFkZGRkZWIwIiwiMzA0OTRlMzYtMjA0MS00MDk2LWFjZjgtYjM2ODRhNjMwOWU0IiwiNWRkNTVjMzctMGI4NC00MGI0LTg3NjEtNTNiYjlhOTNhYzhmIiwiMzkyNzA5M2EtOGQ1OS00MTE5LTgzM2UtZTdhMDJmYjg4NzhjIiwiNjEyYWNiM2YtZTJkOC00YjU2LWI1NTAtMGZlNTU2ODk0Mjg0IiwiYjQwNzRmNDItNDAxYi00YzVlLTgxN2UtNmVmODMzNTliN2JmIiwiODQ5Y2Y0NDMtOWM1Yy00ZTMyLWEyZWEtNTVlYWVkZDllNmE2IiwiMjYxNTQwNDQtMmE3OC00YzgyLTk5OTMtMTZlMDg0NWM1NTgyIiwiYjM2YjI5NDUtMWQyNC00YzgzLTliYTUtMjUxNGE1NmY0OWEzIiwiNmM0YTI1NDktODBlYi00NmE5LTk5NzItOTI3MTc4ZjRjNGZmIiwiYzVkMjYyNGItNjVmOC00M2Q0LWExYTgtNTI4ZjFjNTI5N2QzIiwiMjQxZjFjNGMtNjIxMS00OGFjLWEwODgtYjYyZTFjMGIzM2FjIiwiNDUyMmE0NGQtNjYwZC00NGVjLTgwNzMtYWZkYzE2ZTRhZDdiIiwiNTMwMWI0NGQtZjUwNS00NDA3LTg3NmQtZWZhZTViN2JlOTgwIiwiNGM3MGZjNGYtYWI5NS00NzE0LThmMTctZGZkNzUwNmNmYjIwIiwiZTcxNjc3NTAtNWM1Yi00Yjc2LTg4YjItNjU4ZWJmMjEzZjFlIiwiOTFhNGFiNTAtYzQ0MS00YTlkLWJlNDMtYTAyYzQ4NWY5NWYzIiwiMWFiMzE4NTEtYzM2Yy00OTZmLThkNGMtM2E3YWE0NTkzNGM4IiwiMzJkYWQ4NTEtMGI2YS00NTMxLWI4MzUtMzA3MGNiZTkwYzUwIiwiNjQ4MGM0NTQtNWY2YS00ZDE5LWFkNGYtNWQwNGM4NjViYTg1IiwiYjFjMjYyNTYtOTZkZi00MzdmLWEzYWItOGUxNjYzZTY2YWIxIiwiZGRmYzI2NWEtMGJiZi00OWNlLWJiMDItNjdkNTEzYjc3YzJiIiwiZWFiNzdjNWItMGU2ZC00NWRmLTgzZjgtYTY1ZDk3MDcyMTVkIiwiZTJjZTkzNjAtZGJkNi00ZGQ0LTg1NTItODA2MmE1MTdiNWRkIiwiNzMyOTliNjAtNjAyMy00Y2ZkLTk4YzEtNWQ2NWUyZmNiNDdmIiwiMGZlMWVlNjAtNjMwNS00ZDBhLTliMTAtMzFiNTAyNmYyNWM3IiwiOTAwNzBmNjEtNjU3Mi00ZDRmLThkMDQtMjVhNGFlYjViMzc5IiwiM2UxMzY5NjMtMWYzOS00OGI4LWI1ZjItMjY0ZGEwMWE3YWE1IiwiYjAzMTU5NjQtOGNiMy00ZDEyLThhZDctOTRlODhjYTZiNzA3IiwiMTJlZWI5NjUtYzU1Zi00YmI0LThkYmItZjRlNmUwOGNjMzBhIiwiYjdiZTdjNjYtMDA2Yi00Njc4LWE1ZmQtMjNiNzI0NjBkOTE4IiwiOTM0NWU4NjYtZmFmZi00ZTdlLWI5YzAtNmRiMmQ2NThmNzkzIiwiNjhiNmQ0NmEtOTY5Mi00OWUxLWExYTYtYjA3NWY2YTJlOWQ5IiwiOWY2MmVjNmMtZWU0MS00NGU5LTkxMzEtOTliNzkyNTQxMzgyIiwiMWFjMTM3NmUtZjA0YS00NGI2LWJlNTgtYWExNjAwM2VhOTZlIiwiOWMzOGZhNmYtNGE4Zi00MjVkLWFiNDgtYjc3OTdhY2NmOGRlIiwiZmVjZTRhNzAtYTk2OC00YjdkLTk4YmEtOWFlMTMwOTc4YzljIiwiNmFjZDcxNzItNjA2Ni00NGFjLWIxOTAtOWNjZGE3YWI3YjY0IiwiMzc3NjYxNzMtY2Q4NS00NDc1LWExMWMtZWY2MWZjYTNhZmRjIiwiMGRmNTI5NzUtZGIxOS00ZmEzLWJjZDgtNjFkOGIyZTI4MmQ4IiwiZGFlZjA0NzctMzQxYi00ZGRlLTkzZmMtNGI4MTkwMTFiMjk0IiwiODk0OWEyNzctZGEzNC00YmIwLWFmMDEtYmRiZGZmNjVlYjZhIiwiYzQwZGUwNzktMmE1Ni00OTMyLThmMzUtMDUyOTc5YmRjMGZjIiwiMWI0YzhlN2ItYWMwYy00MTlhLWI4NzEtNzg5ZWZhNjFhNjdlIiwiMGRiNmJmN2ItNGIxYy00ZTljLWE1YjEtOTI4Yjk0MTI5YTZkIiwiZmI3YjY1N2UtYmE1OS00OGMzLTg2NTYtMjI0NGY3NzAzM2NkIiwiOGE4NTczN2YtMWYyZi00NjljLWFkZTUtNGQ5MDlhMjYzMjYxIiwiMzAwMTYwODAtMjg1Yy00N2M3LTg4ZDAtMjBmMmFiNThiNzMwIiwiNDczMTNmODEtMDZjZC00OTc5LTgwMDgtNDFjYTZhOTA3YWU3IiwiNDEyMTdhODYtZTU1ZS00ZDg4LWJjN2MtYTFlMTAxMWY3NjRiIiwiNzk4ZjljODgtMGUxYS00Mjg4LWI3MDQtMGQ2ODM0NTA3MGU0IiwiNTQyMGEyODgtYTNkZC00ZDgxLWE5MjctN2I2ZDk3NWFlZTE2IiwiYmYzYzBmOGEtYjQ5YS00M2M0LWI4N2EtOGQ4MmU0OGRkYThiIiwiZjJjOGNiOGItMjc2OS00YjQ2LWE5NjYtNjc4YTI1YTkxZDNjIiwiNmM1OGVmOGItYzRiMi00MzhmLTk0NzUtYjlkZjFjYWI4YzBmIiwiM2VhYjk5OGMtODI0ZC00YWI5LTg1YTUtZTQyNGEwYTIxMWMxIiwiZTQxMWMwOGQtNzA0My00ZDFiLWJiYzEtMTE2NTBlYzJlMmFlIiwiN2Q2M2RhOGQtNDczMC00YmEwLTk2YmUtYWVlYWJlNjZlZjgxIiwiMWFiY2IzOTAtODAxMi00NTBmLTg5ZGUtYjlmMGZkN2YyMDMyIiwiY2NjM2Y3OTAtMjZjMi00MjA4LWJjNWYtOTczZjZlY2NiZTQ3IiwiNmUzN2FhOTItNTlhZS00ZGMxLWFiZGYtOGFhMjkxODM5ZTQzIiwiMDAwNWQzOTItNzU3ZC00YWM1LTkzYzItZmE0MTU4NmJiM2JmIiwiYmIyM2ZhOTYtZTg1OS00MGZlLTllNWMtMzk1ZmM2MGZhYmFkIiwiMDA5YjUzOWMtZGNlMy00NzNhLTg2NDMtN2RiOTRkMTYyODQ0IiwiMzdiNDgzOWUtNWIwYy00MjkzLWFmODgtMWEyNWFhODAwZjY3IiwiYTYzNjI2OWYtYTk2Ny00NWIyLWJiNGUtM2UwMmRiYjYyNGEyIiwiZGY0MWU1YTUtOTc0OS00MzBmLWE0MDktMmI2MzUzNDMzMDNhIiwiZDYxMzA0YTYtMjQzNi00ODZlLThiNDAtZDUzNTEyZjNhNWJmIiwiMWMxNzQzYTgtODk3MS00NTJiLWIzZmQtNjlhZWEzYTk3NTIzIiwiZWQ4OTgzYTgtYWY3NC00MzQ2LTg1NmYtYjYzMThmMjViNjI4IiwiYjYyNzUxYWEtYjkwMy00ODE1LWJmNGEtNmNhMWZkNjQzZWU3IiwiZTUyNmVlYWMtYTQ0MC00MzY0LTkxNGQtMTA5Y2ZlMzc5NDFlIiwiYWZmNGIwYWQtN2MzYy00ZDk1LTgzZGYtYmI1NjE4ZjYxZDBiIiwiM2VkYjY4YWUtZmFkNC00NjZmLWExMmQtYTY3NTM0ODBmODdiIiwiMjhlNDYxYjEtMGRjZC00ZTZkLWIzNmYtNGY0NzQ3ZjcyOWFiIiwiNTI5MDM0YjMtYzQ1MC00MGE4LWJjYzUtYzQyMzgzMmY0NTYyIiwiMWJhZjY4YjQtMjVjOC00OTk4LWIxNTktY2FlOWQ0ODkzNzdlIiwiZmE0MTcxYjQtMjc0MC00YjM2LWEwMjYtODBkZWNjZWM1NTQwIiwiMjkzOTg0YjQtZTUxOS00Njc2LTlkMmEtNmZhM2Y2NzJiZDFjIiwiY2I0MjI1YjctMzVhZi00NTMzLTg4OWYtNzI0MWM5OWYxNTFjIiwiMGQ3YWRhYjktZjE5ZC00YWY5LTllNmItN2RkNWEzZDdkOTlmIiwiM2VhODM2YmMtNGEyNS00ZmRiLTllMTgtNDY1NDc1NDkzZDZmIiwiOGY5NGY5YmMtMmE0My00NzAxLWExMmQtYzkzZTgwZGJkMjQyIiwiMTZmODEwYmUtZTI3OS00ZTIyLTgxYzEtNjJmNDk0NmNhNTA2IiwiYTUxMGNlYmYtMWU3OS00YzliLWIyMWUtNjk5ZjlkNzUxOWY5IiwiYmQ2M2Y2YzAtY2M2MS00NWViLWJiMGEtOTc1MTg1ZmM2MDFmIiwiNWYwNmRjYzEtMzI2My00MWY2LTliZmEtZmE2ZjBjZWI4NmQ5IiwiNGY2MDgwYzktY2UzOC00ZDVlLWIxNjctZWM1Mzc3YmRkZjg5IiwiYjQ5YjE0Y2EtMDNjNi00ZWMzLWJjYTUtMGQ0MzY5MzUwNmFiIiwiZGEzMzcxY2EtODA2Mi00NjcxLWIwYzgtNTM4YTljNmYyYWRkIiwiZTg5MTQ4Y2ItNGExZC00MzY3LThhYTQtYzdhYTY0NDJmNDcxIiwiYjRjNDcxY2ItZjI2My00ZTIyLWEwMzYtMTZkOGQxNjQ0NmZlIiwiYTg2YjgxY2MtYTBmYS00ZGNkLWE0NzAtYzlkNGZmYjRkMzQ3IiwiNzEzMzdhZDMtMWY2Yi00OTdlLTlhNDUtZmM2ZTk3ODIzNzhiIiwiYTkzYTEzZDktNjMxMS00MWUxLWIzYjYtZjk5ZDRmYjAyZWFkIiwiZjE2Nzk2ZGEtMzRmMy00ZjZhLWFjNDMtYzZhMTY5MWZiYjNjIiwiZmEyMDYyZGMtNjA2OC00NjFjLTkyYWQtYmJmZjYwMTI2ZDE5IiwiYmQyNWM0ZGQtNzFiOC00NWQzLTg3MDItOThjNDdmZTAwMTlkIiwiMDk0NWM0ZGYtMDFmMS00ZDFjLTkxOTctNmFhN2FmNGNlNzM3IiwiNjFjOTczZTAtYTAzMy00YmJhLTlhMzktNGRmZmE4YTMxMmQyIiwiYjhhM2IzZTMtZDlkZi00OTU2LTlmYTctNmRhYTY1MDYyNTc4IiwiMWFiM2M5ZTctZGRlMC00YWYxLWFkODktZTdmZGViN2JiOGQ4IiwiMmVmMzJhZWQtMGY4Yy00MTQzLThlMjItYzUxZjg2MWIzNTc3IiwiMjZiM2JkZWUtMWM4Zi00NGVjLTg5YmQtMDZmODAzYjE3Nzg3IiwiZDk5Y2VkZWYtYmM4Ny00MWNhLWJhYWQtNTczZmMzZWYyMGVkIiwiODJmOGYzZWYtOTA2MC00YTJmLWE1ODctNWY0N2NhMjM4YWI3IiwiY2E0NWY5ZWYtYTE3OS00OGY4LTgzMWQtOTQxYzRlYzIyMTEzIiwiYjBhY2I3ZjAtNGJkZC00ZDgzLWFjYjAtMjRkZDg2Y2FkOTA0IiwiMjExNTQyZjMtY2NiZC00ZDlhLTkzYTYtYzVmYmJkOTIxOWEzIiwiY2I1N2YwZjctZGYyYy00ZmFlLWE2YTAtNzMwNGJiMzcyN2JiIiwiOWU1OWY4ZjctY2Q2Ni00YTYzLWExMWUtYTI4NTVmZTJiOTg2IiwiNTY3ZmI2ZjgtNzA1OC00OTk2LWE1M2ItMmYyYzFiZDIxODRkIiwiMmY0YWIzZjktNjgyZC00NmQ2LTkyMDQtN2ViZGE3YmJkNDFjIiwiOTYwMTg4ZmEtNDA4ZS00OTAxLTk1MGUtZDZlMTlmZWQ1NGVmIiwiOTBiNmQ3ZmEtZmEyNi00YTg1LTkyZTMtOWRhMjA1ZWQ0NmM1IiwiYWFjMzdiZmItN2U4MS00MzFjLWJiNzAtNWNlNGU4MGJjYmRkIiwiOTllNjJhZmYtNGY3Ni00NjBhLWE2MTEtZjhhNDhlOThmNzQxIl0sImlwYWRkciI6IjkwLjI1MC45LjQ4IiwibmFtZSI6IkRhdmlkIEZsb29kIiwib2lkIjoiZDU0ZWE4OWUtN2UyZC00M2E0LWJlNDUtNTZjMzUwOWVkM2E2Iiwib25wcmVtX3NpZCI6IlMtMS01LTIxLTIyMDUyMzM4OC0xMDg1MDMxMjE0LTcyNTM0NTU0My0yMjIyMjgxIiwicHVpZCI6IjEwMDMzRkZGOERCQzVFMDciLCJyaCI6IjAuQVFJQU5hS2tPdUsyMVVpUmxYX1BCYlJac0VaSWYza0F1dGRQdWtQYXdmajJNQk1DQUowLiIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6IndvbE1sYkFpa0QtTG4td0FINHQ1d2dxMGo0Ql96VG9mbXhhZGlZdEstS0EiLCJ0aWQiOiIzYWE0YTIzNS1iNmUyLTQ4ZDUtOTE5NS03ZmNmMDViNDU5YjAiLCJ1bmlxdWVfbmFtZSI6IkRGTE9PQGVxdWlub3IuY29tIiwidXBuIjoiREZMT09AZXF1aW5vci5jb20iLCJ1dGkiOiJUQVh4Z3JwZ3kwcWZwQ1dBSzJmdkFRIiwidmVyIjoiMS4wIiwid2lkcyI6WyJiNzlmYmY0ZC0zZWY5LTQ2ODktODE0My03NmIxOTRlODU1MDkiXSwieG1zX3RjZHQiOjEzNDQ1ODM2MDJ9.fjM8U0Sj4r7vr6o4NyIyHbfJEyYokFsgbrdfy9xeUrk8k6V7ns7JVUrmaxRyuLna4iEvnd6zRBswFEWiW2FaSdzHkesAjtKiBgchivZBrR9nk9raq_uEL8S3zlhoesagOYSRhmDBp8PrUh7BU6jzXAZOGrbLEPD0QKTBoc-ZMhf2RzIiFpdurV0pR7jWaTXJHyrzs780Wv5j0gNbs4ihuj38CEQWil5A7mF80uCJ5kfK15p0y2FY-O38wwuF6IBbZdDEN6KI0Vay_qhW61seHC59FftdrBn1kdP8yemGQ0-P9FaMNdgr7KcKpgIRo9_inTegYDIp9nsoIJJFsh6YAw"
					}
				},
				"variables": {
					"Loop-Count": {
						"type": "String"
					},
					"Bearer": {
						"type": "String"
					},
					"blobPath": {
						"type": "String"
					},
					"daily": {
						"type": "String"
					},
					"Scope": {
						"type": "String",
						"defaultValue": "monthly"
					},
					"Year": {
						"type": "String"
					},
					"Month": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Path": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					},
					"Months": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-01-11T14:32:28Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ms_billing_output_file')]",
				"[concat(variables('workspaceId'), '/datasets/S037_New_Format_Usage_Data')]",
				"[concat(variables('workspaceId'), '/datasets/S037CSVSourceDataset')]",
				"[concat(variables('workspaceId'), '/datasets/New_API_Format_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - AmortisedCost - 2018-2021')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set Months",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Months",
							"value": [
								"01",
								"02",
								"03",
								"04",
								"05",
								"06",
								"07",
								"08",
								"09",
								"10",
								"11",
								"12"
							]
						}
					},
					{
						"name": "ForEachMonth",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set Months",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Post Consumption Request",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
												"type": "Expression"
											},
											"Content-type": "application/json"
										},
										"url": {
											"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@concat('{\n  \"metric\": \"',pipeline().parameters.ReportType,'\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,item(),'\"\n  }')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set blobPath",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Post Consumption Request",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "blobPath",
										"value": {
											"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy file from MS to Synapse datastore",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set blobPath",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Amortized Usage Path",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "HttpReadSettings",
												"requestMethod": "GET"
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "ms_billing_output_file",
											"type": "DatasetReference",
											"parameters": {
												"blobPath": {
													"value": "@variables('blobPath')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "S037_New_Format_Usage_Data",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": "na"
											}
										}
									]
								},
								{
									"name": "CSV to Parquet",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Copy file from MS to Synapse datastore",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"wildcardFolderPath": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"wildcardFileName": {
													"value": "@concat('ACMMonthlyAmortizedCost_',variables('dateRange'),'.csv')",
													"type": "Expression"
												},
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Date",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Date",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Quantity",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "Quantity",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "EffectivePrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "EffectivePrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostInBillingCurrency",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostInBillingCurrency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Tags",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Tags",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Term",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Term",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PayGPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "PayGPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "UTF8"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "S037CSVSourceDataset",
											"type": "DatasetReference",
											"parameters": {
												"Year": {
													"value": "@variables('Year')",
													"type": "Expression"
												},
												"Month": {
													"value": "@variables('Month')",
													"type": "Expression"
												},
												"toDate": {
													"value": "@variables('toDate')",
													"type": "Expression"
												},
												"scope": {
													"value": "@variables('Scope')",
													"type": "Expression"
												},
												"fromDate": {
													"value": "@variables('fromDate')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "New_API_Format_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Set last day in Month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Month",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Year",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Month",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Month",
										"value": {
											"value": "@item()",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": "2021"
									}
								},
								{
									"name": "Set Amortized Usage Path",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Amortized Usage Date Range",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.ReportType,'/',variables('dateRange'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Amortized Usage Date Range",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait 1 min",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "CSV to Parquet",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 60
									}
								}
							]
						}
					},
					{
						"name": "ForEachMonth_copy1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachMonth",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Post Consumption Request_copy1",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
												"type": "Expression"
											},
											"Content-type": "application/json"
										},
										"url": {
											"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@concat('{\n  \"metric\": \"',pipeline().parameters.ReportType,'\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,item(),'\"\n  }')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set blobPath_copy1",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Post Consumption Request_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "blobPath",
										"value": {
											"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy file from MS to Synapse datastore_copy1",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set blobPath_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Amortized Usage Path_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "HttpReadSettings",
												"requestMethod": "GET"
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "ms_billing_output_file",
											"type": "DatasetReference",
											"parameters": {
												"blobPath": {
													"value": "@variables('blobPath')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "S037_New_Format_Usage_Data",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": "na"
											}
										}
									]
								},
								{
									"name": "CSV to Parquet_copy1",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Copy file from MS to Synapse datastore_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"wildcardFolderPath": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"wildcardFileName": {
													"value": "@concat('ACMMonthlyAmortizedCost_',variables('dateRange'),'.csv')",
													"type": "Expression"
												},
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Date",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Date",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Quantity",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "Quantity",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "EffectivePrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "EffectivePrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostInBillingCurrency",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostInBillingCurrency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Tags",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Tags",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Term",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Term",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PayGPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "PayGPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "UTF8"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "S037CSVSourceDataset",
											"type": "DatasetReference",
											"parameters": {
												"Year": {
													"value": "@variables('Year')",
													"type": "Expression"
												},
												"Month": {
													"value": "@variables('Month')",
													"type": "Expression"
												},
												"toDate": {
													"value": "@variables('toDate')",
													"type": "Expression"
												},
												"scope": {
													"value": "@variables('Scope')",
													"type": "Expression"
												},
												"fromDate": {
													"value": "@variables('fromDate')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "New_API_Format_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Set last day in Month_copy1",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month_copy1",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Month_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Year_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Month_copy1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Month",
										"value": {
											"value": "@item()",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year_copy1",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": "2020"
									}
								},
								{
									"name": "Set Amortized Usage Path_copy1",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Amortized Usage Date Range_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.ReportType,'/',variables('dateRange'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Amortized Usage Date Range_copy1",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait 1 min_copy1",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "CSV to Parquet_copy1",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 60
									}
								}
							]
						}
					},
					{
						"name": "ForEachMonth_copy2",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "ForEachMonth_copy1",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Post Consumption Request_copy2",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
												"type": "Expression"
											},
											"Content-type": "application/json"
										},
										"url": {
											"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@concat('{\n  \"metric\": \"',pipeline().parameters.ReportType,'\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,item(),'\"\n  }')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set blobPath_copy2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Post Consumption Request_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "blobPath",
										"value": {
											"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy file from MS to Synapse datastore_copy2",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set blobPath_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Amortized Usage Path_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "HttpReadSettings",
												"requestMethod": "GET"
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "ms_billing_output_file",
											"type": "DatasetReference",
											"parameters": {
												"blobPath": {
													"value": "@variables('blobPath')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "S037_New_Format_Usage_Data",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": "na"
											}
										}
									]
								},
								{
									"name": "CSV to Parquet_copy2",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Copy file from MS to Synapse datastore_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"wildcardFolderPath": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"wildcardFileName": {
													"value": "@concat('ACMMonthlyAmortizedCost_',variables('dateRange'),'.csv')",
													"type": "Expression"
												},
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Date",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Date",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Quantity",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "Quantity",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "EffectivePrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "EffectivePrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostInBillingCurrency",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostInBillingCurrency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Tags",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Tags",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Term",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Term",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PayGPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "PayGPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "UTF8"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "S037CSVSourceDataset",
											"type": "DatasetReference",
											"parameters": {
												"Year": {
													"value": "@variables('Year')",
													"type": "Expression"
												},
												"Month": {
													"value": "@variables('Month')",
													"type": "Expression"
												},
												"toDate": {
													"value": "@variables('toDate')",
													"type": "Expression"
												},
												"scope": {
													"value": "@variables('Scope')",
													"type": "Expression"
												},
												"fromDate": {
													"value": "@variables('fromDate')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "New_API_Format_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Set last day in Month_copy2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month_copy2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Month_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Year_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Month_copy2",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Month",
										"value": {
											"value": "@item()",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year_copy2",
									"description": "",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": "2019"
									}
								},
								{
									"name": "Set Amortized Usage Path_copy2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Amortized Usage Date Range_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.ReportType,'/',variables('dateRange'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Amortized Usage Date Range_copy2",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait 1 min_copy2",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "CSV to Parquet_copy2",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 60
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year": {
						"type": "string",
						"defaultValue": "2018"
					},
					"Bearer": {
						"type": "string",
						"defaultValue": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSIsImtpZCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSJ9.eyJhdWQiOiJodHRwczovL21hbmFnZW1lbnQuY29yZS53aW5kb3dzLm5ldCIsImlzcyI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0LzNhYTRhMjM1LWI2ZTItNDhkNS05MTk1LTdmY2YwNWI0NTliMC8iLCJpYXQiOjE2Njk0MDU4MTAsIm5iZiI6MTY2OTQwNTgxMCwiZXhwIjoxNjY5NDExMDg3LCJhY3IiOiIxIiwiYWlvIjoiQVZRQXEvOFRBQUFBNUxjRnp1Z3JHOHRoTVJ2QzIrZjNRZ1BRcm5OL1lGSkduV0hMQ1JFSllXeXZTME9MWTZrS2NvQVBDc2tFSlFPWEliK3VMVFZpYThrVFF1aHc1dGZ2eFYySkR1MDdwNWZSSEVXZDFQY045emc9IiwiYW1yIjpbInB3ZCIsIm1mYSJdLCJhcHBpZCI6IjE4ZmJjYTE2LTIyMjQtNDVmNi04NWIwLWY3YmYyYjM5YjNmMyIsImFwcGlkYWNyIjoiMCIsImZhbWlseV9uYW1lIjoiRmxvb2QiLCJnaXZlbl9uYW1lIjoiRGF2aWQiLCJncm91cHMiOlsiNmEwZjczMDEtMDM4ZS00MjMxLWFkNTYtNmQwMWFkY2I4NGVmIiwiZDg2MmNhMDItOWQ5OC00NzNkLTk3NjAtNTFjOGVmNjliZWZmIiwiZmZhZWE2MDMtNzU5YS00NDkwLTkzN2MtODc1MjZmNDJkMzFlIiwiZmFjYjA0MDYtYTk5ZS00YjFjLTliZDEtYjU4OTAzYWQ2MGM5IiwiY2JiOWZjMDYtYzVkNi00ODcyLThjODUtNDgwMjRlODljNjQ5IiwiOWViMjYzMDktMzVlMC00YTgwLTk2YWQtZTRjOWVjNTcxMWJlIiwiOTYyOWEyMGEtZWFlYy00OWIzLTk3ODQtMGFlOWE2NTcwZmM5IiwiMWRiNmJhMGMtMWQyZi00ZDc2LTlkYWUtMDg4MWU1OTEzYzVjIiwiY2IzOGMyMGQtZjRhMy00ZWMzLWIyNTgtZWQwMmM5MzY4NGYwIiwiMTkzY2YxMGQtN2RkMC00NmQ3LWExMDEtNDU1ODIwMjM0YTU2IiwiZjYzODQ4MGYtYjI5NS00NzdmLWJkZWEtYjk5ZWQ0MjFkYmEyIiwiMzE5ODllMGYtZDZlNS00OGU3LTk5NTItMTBhN2ZmYWUzYmI4IiwiMDc3ZTM4MTEtNzgzYS00YjlhLTlhNGItNWI5OWU3ZTY3MWMwIiwiMzEwMDQ3MTItZDkwZS00OWY2LTllNzktMmU5N2Y2OGY2ZDUwIiwiMDQ3ZmIwMTItNjk0Yy00NGMzLThkNDgtOTI3Y2IzNDk3ODhjIiwiYjcyYjY4MTQtZDE3Mi00ZTM2LWJiOTAtMGIzZjE1YTkxOTc3IiwiZjJjOTg4MTUtZTE2Ni00ZjkwLWE1ZjQtMWY1MzVmNWVkY2M4IiwiMDViOTZkMTYtYjY0NC00ZmNmLThhZTUtZmYwYzBmODI1YjVmIiwiYmMzOWYyMTctNDQxOS00MjkxLTk1MjctMzU2MTQ3N2EyZmI3IiwiMDAwMzExMWItMGMyZS00MDQxLWIxZGQtMGIyZWQxZWY2Zjc4IiwiMzA3MjhlMWUtNDZmMC00YjYxLWEwYmMtNmJjM2Y3MzYwYjhhIiwiYzY4ZTUwMWYtNmQxZi00YjRiLThmMzctMGM0NjgxNTZkZGYyIiwiNWFmMDk5MjEtZmQ2YS00NjExLTllYTktYTNiZmIxZjM1YmJlIiwiN2VmMzZjMjMtM2Y2Yi00MzIxLWIwMjgtYjgxYTliNDU5OTkxIiwiZGY2NWVhMjMtODhjMy00MzFhLWE4N2YtNjA1NWNmOWJkNTQ5IiwiM2I5NWRhMjctMzM3YS00NGMxLWI2OWQtNTY0NGI1MWE0ODM2IiwiOGZhM2JiMjgtODRmOS00YjA2LWE0ZDUtMDg5MDdlOGRkNmZhIiwiZTA0MGM0MjgtYWM1Ny00NTQyLWEzMjgtMmY2NzJhMzRjY2I4IiwiZTFjYWE0MmEtYmY2OS00MzkxLTlhNWUtYzhjZmRhZTFiNDE3IiwiOWZlNmU2MmEtMzExOC00NzA0LWFmYmUtODM0ODIyY2IwZDQzIiwiMGIxMDJiMmMtM2M5Ny00Yjc2LWI0ZGYtZTAzOTg2ODZhZjU2IiwiNzQ4YTAyMmUtOTY4ZS00YTk0LWFkZTMtOTI0ZTI2YmFkYWE4IiwiZGE1YTMzMmUtMTQ3MC00MGYzLTk4MDMtNDk3NWU1Njk0ZTViIiwiNGY2ZjRlMmYtYjIyMy00ZTczLWIzMzMtNWJiMWY3NjAxNGY0IiwiMjllMDM1MzAtZjgxOC00MDM2LWIyOGItOTdiOGI5NGYyNjUwIiwiYWQ1Nzc4MzItYTBlMS00YTA4LWJiZjQtMTI3MjQzYzZhNzUyIiwiMWRmZWJkMzUtN2U0ZC00ZjM5LTkyMjUtMDExZGFkZGRkZWIwIiwiMzA0OTRlMzYtMjA0MS00MDk2LWFjZjgtYjM2ODRhNjMwOWU0IiwiNWRkNTVjMzctMGI4NC00MGI0LTg3NjEtNTNiYjlhOTNhYzhmIiwiMzkyNzA5M2EtOGQ1OS00MTE5LTgzM2UtZTdhMDJmYjg4NzhjIiwiNjEyYWNiM2YtZTJkOC00YjU2LWI1NTAtMGZlNTU2ODk0Mjg0IiwiYjQwNzRmNDItNDAxYi00YzVlLTgxN2UtNmVmODMzNTliN2JmIiwiODQ5Y2Y0NDMtOWM1Yy00ZTMyLWEyZWEtNTVlYWVkZDllNmE2IiwiMjYxNTQwNDQtMmE3OC00YzgyLTk5OTMtMTZlMDg0NWM1NTgyIiwiYjM2YjI5NDUtMWQyNC00YzgzLTliYTUtMjUxNGE1NmY0OWEzIiwiNmM0YTI1NDktODBlYi00NmE5LTk5NzItOTI3MTc4ZjRjNGZmIiwiYzVkMjYyNGItNjVmOC00M2Q0LWExYTgtNTI4ZjFjNTI5N2QzIiwiMjQxZjFjNGMtNjIxMS00OGFjLWEwODgtYjYyZTFjMGIzM2FjIiwiNDUyMmE0NGQtNjYwZC00NGVjLTgwNzMtYWZkYzE2ZTRhZDdiIiwiNTMwMWI0NGQtZjUwNS00NDA3LTg3NmQtZWZhZTViN2JlOTgwIiwiNGM3MGZjNGYtYWI5NS00NzE0LThmMTctZGZkNzUwNmNmYjIwIiwiZTcxNjc3NTAtNWM1Yi00Yjc2LTg4YjItNjU4ZWJmMjEzZjFlIiwiOTFhNGFiNTAtYzQ0MS00YTlkLWJlNDMtYTAyYzQ4NWY5NWYzIiwiMWFiMzE4NTEtYzM2Yy00OTZmLThkNGMtM2E3YWE0NTkzNGM4IiwiMzJkYWQ4NTEtMGI2YS00NTMxLWI4MzUtMzA3MGNiZTkwYzUwIiwiNjQ4MGM0NTQtNWY2YS00ZDE5LWFkNGYtNWQwNGM4NjViYTg1IiwiNzZmZTAwNTUtMWQyNS00ZDE3LTk4ZGItNTVlMDY2N2Y2Y2JmIiwiYjFjMjYyNTYtOTZkZi00MzdmLWEzYWItOGUxNjYzZTY2YWIxIiwiZGRmYzI2NWEtMGJiZi00OWNlLWJiMDItNjdkNTEzYjc3YzJiIiwiZWFiNzdjNWItMGU2ZC00NWRmLTgzZjgtYTY1ZDk3MDcyMTVkIiwiZTJjZTkzNjAtZGJkNi00ZGQ0LTg1NTItODA2MmE1MTdiNWRkIiwiNzMyOTliNjAtNjAyMy00Y2ZkLTk4YzEtNWQ2NWUyZmNiNDdmIiwiMGZlMWVlNjAtNjMwNS00ZDBhLTliMTAtMzFiNTAyNmYyNWM3IiwiOTAwNzBmNjEtNjU3Mi00ZDRmLThkMDQtMjVhNGFlYjViMzc5IiwiM2UxMzY5NjMtMWYzOS00OGI4LWI1ZjItMjY0ZGEwMWE3YWE1IiwiYjAzMTU5NjQtOGNiMy00ZDEyLThhZDctOTRlODhjYTZiNzA3IiwiMTJlZWI5NjUtYzU1Zi00YmI0LThkYmItZjRlNmUwOGNjMzBhIiwiYjdiZTdjNjYtMDA2Yi00Njc4LWE1ZmQtMjNiNzI0NjBkOTE4IiwiOTM0NWU4NjYtZmFmZi00ZTdlLWI5YzAtNmRiMmQ2NThmNzkzIiwiNjhiNmQ0NmEtOTY5Mi00OWUxLWExYTYtYjA3NWY2YTJlOWQ5IiwiOWY2MmVjNmMtZWU0MS00NGU5LTkxMzEtOTliNzkyNTQxMzgyIiwiMWFjMTM3NmUtZjA0YS00NGI2LWJlNTgtYWExNjAwM2VhOTZlIiwiOWMzOGZhNmYtNGE4Zi00MjVkLWFiNDgtYjc3OTdhY2NmOGRlIiwiZmVjZTRhNzAtYTk2OC00YjdkLTk4YmEtOWFlMTMwOTc4YzljIiwiNmFjZDcxNzItNjA2Ni00NGFjLWIxOTAtOWNjZGE3YWI3YjY0IiwiMzc3NjYxNzMtY2Q4NS00NDc1LWExMWMtZWY2MWZjYTNhZmRjIiwiMGRmNTI5NzUtZGIxOS00ZmEzLWJjZDgtNjFkOGIyZTI4MmQ4IiwiZGFlZjA0NzctMzQxYi00ZGRlLTkzZmMtNGI4MTkwMTFiMjk0IiwiODk0OWEyNzctZGEzNC00YmIwLWFmMDEtYmRiZGZmNjVlYjZhIiwiYzQwZGUwNzktMmE1Ni00OTMyLThmMzUtMDUyOTc5YmRjMGZjIiwiMWI0YzhlN2ItYWMwYy00MTlhLWI4NzEtNzg5ZWZhNjFhNjdlIiwiMGRiNmJmN2ItNGIxYy00ZTljLWE1YjEtOTI4Yjk0MTI5YTZkIiwiZmI3YjY1N2UtYmE1OS00OGMzLTg2NTYtMjI0NGY3NzAzM2NkIiwiOGE4NTczN2YtMWYyZi00NjljLWFkZTUtNGQ5MDlhMjYzMjYxIiwiMzAwMTYwODAtMjg1Yy00N2M3LTg4ZDAtMjBmMmFiNThiNzMwIiwiNDczMTNmODEtMDZjZC00OTc5LTgwMDgtNDFjYTZhOTA3YWU3IiwiNDEyMTdhODYtZTU1ZS00ZDg4LWJjN2MtYTFlMTAxMWY3NjRiIiwiNzk4ZjljODgtMGUxYS00Mjg4LWI3MDQtMGQ2ODM0NTA3MGU0IiwiNTQyMGEyODgtYTNkZC00ZDgxLWE5MjctN2I2ZDk3NWFlZTE2IiwiYmYzYzBmOGEtYjQ5YS00M2M0LWI4N2EtOGQ4MmU0OGRkYThiIiwiNmM1OGVmOGItYzRiMi00MzhmLTk0NzUtYjlkZjFjYWI4YzBmIiwiM2VhYjk5OGMtODI0ZC00YWI5LTg1YTUtZTQyNGEwYTIxMWMxIiwiZTQxMWMwOGQtNzA0My00ZDFiLWJiYzEtMTE2NTBlYzJlMmFlIiwiN2Q2M2RhOGQtNDczMC00YmEwLTk2YmUtYWVlYWJlNjZlZjgxIiwiMWFiY2IzOTAtODAxMi00NTBmLTg5ZGUtYjlmMGZkN2YyMDMyIiwiNmUzN2FhOTItNTlhZS00ZGMxLWFiZGYtOGFhMjkxODM5ZTQzIiwiMDAwNWQzOTItNzU3ZC00YWM1LTkzYzItZmE0MTU4NmJiM2JmIiwiYmIyM2ZhOTYtZTg1OS00MGZlLTllNWMtMzk1ZmM2MGZhYmFkIiwiMDA5YjUzOWMtZGNlMy00NzNhLTg2NDMtN2RiOTRkMTYyODQ0IiwiMzdiNDgzOWUtNWIwYy00MjkzLWFmODgtMWEyNWFhODAwZjY3IiwiYTYzNjI2OWYtYTk2Ny00NWIyLWJiNGUtM2UwMmRiYjYyNGEyIiwiZGY0MWU1YTUtOTc0OS00MzBmLWE0MDktMmI2MzUzNDMzMDNhIiwiZDYxMzA0YTYtMjQzNi00ODZlLThiNDAtZDUzNTEyZjNhNWJmIiwiMWMxNzQzYTgtODk3MS00NTJiLWIzZmQtNjlhZWEzYTk3NTIzIiwiZWQ4OTgzYTgtYWY3NC00MzQ2LTg1NmYtYjYzMThmMjViNjI4IiwiYjYyNzUxYWEtYjkwMy00ODE1LWJmNGEtNmNhMWZkNjQzZWU3IiwiZTUyNmVlYWMtYTQ0MC00MzY0LTkxNGQtMTA5Y2ZlMzc5NDFlIiwiYWZmNGIwYWQtN2MzYy00ZDk1LTgzZGYtYmI1NjE4ZjYxZDBiIiwiM2VkYjY4YWUtZmFkNC00NjZmLWExMmQtYTY3NTM0ODBmODdiIiwiMjhlNDYxYjEtMGRjZC00ZTZkLWIzNmYtNGY0NzQ3ZjcyOWFiIiwiMWJhZjY4YjQtMjVjOC00OTk4LWIxNTktY2FlOWQ0ODkzNzdlIiwiZmE0MTcxYjQtMjc0MC00YjM2LWEwMjYtODBkZWNjZWM1NTQwIiwiMjkzOTg0YjQtZTUxOS00Njc2LTlkMmEtNmZhM2Y2NzJiZDFjIiwiY2I0MjI1YjctMzVhZi00NTMzLTg4OWYtNzI0MWM5OWYxNTFjIiwiMGQ3YWRhYjktZjE5ZC00YWY5LTllNmItN2RkNWEzZDdkOTlmIiwiM2VhODM2YmMtNGEyNS00ZmRiLTllMTgtNDY1NDc1NDkzZDZmIiwiOGY5NGY5YmMtMmE0My00NzAxLWExMmQtYzkzZTgwZGJkMjQyIiwiMTZmODEwYmUtZTI3OS00ZTIyLTgxYzEtNjJmNDk0NmNhNTA2IiwiYTUxMGNlYmYtMWU3OS00YzliLWIyMWUtNjk5ZjlkNzUxOWY5IiwiYmQ2M2Y2YzAtY2M2MS00NWViLWJiMGEtOTc1MTg1ZmM2MDFmIiwiNWYwNmRjYzEtMzI2My00MWY2LTliZmEtZmE2ZjBjZWI4NmQ5IiwiNGY2MDgwYzktY2UzOC00ZDVlLWIxNjctZWM1Mzc3YmRkZjg5IiwiYjQ5YjE0Y2EtMDNjNi00ZWMzLWJjYTUtMGQ0MzY5MzUwNmFiIiwiZGEzMzcxY2EtODA2Mi00NjcxLWIwYzgtNTM4YTljNmYyYWRkIiwiZTg5MTQ4Y2ItNGExZC00MzY3LThhYTQtYzdhYTY0NDJmNDcxIiwiYjRjNDcxY2ItZjI2My00ZTIyLWEwMzYtMTZkOGQxNjQ0NmZlIiwiYTg2YjgxY2MtYTBmYS00ZGNkLWE0NzAtYzlkNGZmYjRkMzQ3IiwiNzEzMzdhZDMtMWY2Yi00OTdlLTlhNDUtZmM2ZTk3ODIzNzhiIiwiYTkzYTEzZDktNjMxMS00MWUxLWIzYjYtZjk5ZDRmYjAyZWFkIiwiZjE2Nzk2ZGEtMzRmMy00ZjZhLWFjNDMtYzZhMTY5MWZiYjNjIiwiZmEyMDYyZGMtNjA2OC00NjFjLTkyYWQtYmJmZjYwMTI2ZDE5IiwiYmQyNWM0ZGQtNzFiOC00NWQzLTg3MDItOThjNDdmZTAwMTlkIiwiMDk0NWM0ZGYtMDFmMS00ZDFjLTkxOTctNmFhN2FmNGNlNzM3IiwiNjFjOTczZTAtYTAzMy00YmJhLTlhMzktNGRmZmE4YTMxMmQyIiwiYjhhM2IzZTMtZDlkZi00OTU2LTlmYTctNmRhYTY1MDYyNTc4IiwiMWFiM2M5ZTctZGRlMC00YWYxLWFkODktZTdmZGViN2JiOGQ4IiwiMmVmMzJhZWQtMGY4Yy00MTQzLThlMjItYzUxZjg2MWIzNTc3IiwiMjZiM2JkZWUtMWM4Zi00NGVjLTg5YmQtMDZmODAzYjE3Nzg3IiwiZDk5Y2VkZWYtYmM4Ny00MWNhLWJhYWQtNTczZmMzZWYyMGVkIiwiODJmOGYzZWYtOTA2MC00YTJmLWE1ODctNWY0N2NhMjM4YWI3IiwiY2E0NWY5ZWYtYTE3OS00OGY4LTgzMWQtOTQxYzRlYzIyMTEzIiwiYjBhY2I3ZjAtNGJkZC00ZDgzLWFjYjAtMjRkZDg2Y2FkOTA0IiwiMjExNTQyZjMtY2NiZC00ZDlhLTkzYTYtYzVmYmJkOTIxOWEzIiwiY2I1N2YwZjctZGYyYy00ZmFlLWE2YTAtNzMwNGJiMzcyN2JiIiwiOWU1OWY4ZjctY2Q2Ni00YTYzLWExMWUtYTI4NTVmZTJiOTg2IiwiNTY3ZmI2ZjgtNzA1OC00OTk2LWE1M2ItMmYyYzFiZDIxODRkIiwiOGE1NjhkZjktMmI2Yy00NDA5LTk0M2ItOWVmYWU2NGM5Yzc0IiwiMmY0YWIzZjktNjgyZC00NmQ2LTkyMDQtN2ViZGE3YmJkNDFjIiwiOTYwMTg4ZmEtNDA4ZS00OTAxLTk1MGUtZDZlMTlmZWQ1NGVmIiwiOTBiNmQ3ZmEtZmEyNi00YTg1LTkyZTMtOWRhMjA1ZWQ0NmM1IiwiYWFjMzdiZmItN2U4MS00MzFjLWJiNzAtNWNlNGU4MGJjYmRkIiwiOTllNjJhZmYtNGY3Ni00NjBhLWE2MTEtZjhhNDhlOThmNzQxIl0sImlwYWRkciI6IjkwLjI1MC45LjQ4IiwibmFtZSI6IkRhdmlkIEZsb29kIiwib2lkIjoiZDU0ZWE4OWUtN2UyZC00M2E0LWJlNDUtNTZjMzUwOWVkM2E2Iiwib25wcmVtX3NpZCI6IlMtMS01LTIxLTIyMDUyMzM4OC0xMDg1MDMxMjE0LTcyNTM0NTU0My0yMjIyMjgxIiwicHVpZCI6IjEwMDMzRkZGOERCQzVFMDciLCJyaCI6IjAuQVFJQU5hS2tPdUsyMVVpUmxYX1BCYlJac0VaSWYza0F1dGRQdWtQYXdmajJNQk1DQUowLiIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6IndvbE1sYkFpa0QtTG4td0FINHQ1d2dxMGo0Ql96VG9mbXhhZGlZdEstS0EiLCJ0aWQiOiIzYWE0YTIzNS1iNmUyLTQ4ZDUtOTE5NS03ZmNmMDViNDU5YjAiLCJ1bmlxdWVfbmFtZSI6IkRGTE9PQGVxdWlub3IuY29tIiwidXBuIjoiREZMT09AZXF1aW5vci5jb20iLCJ1dGkiOiJrWUtHb25xUmgwMkw3ZTk4T3lpTkFBIiwidmVyIjoiMS4wIiwid2lkcyI6WyJiNzlmYmY0ZC0zZWY5LTQ2ODktODE0My03NmIxOTRlODU1MDkiXSwieG1zX3RjZHQiOjEzNDQ1ODM2MDJ9.kFx5XSQL3V7v7zJ1JkIPXvgJ2mUCJS_DPC1mmcd3Y3WQRZk5rbFzip9o25ZpO4ddycJ9Hcl7g_uBDOpZm1e1kMszUXXiqpu6PfLvtXEW9-JUht3GXnfo5G5R3FmXiauHUBdNcQBs1H0ah6y8wj2R5LhGH-bgOXOsq1JEitvGQmUTfmEgA_T_R4pYDss4wKNCphcme113AyUGsic6YdWGTNW-ogMhhOmk4LbnJNA0jMSArzndwh_OhjoHuwdcH3eC7Q2f1Tkmh13UZY7CeSftFoW9wMtztO7Q0iDmcHPPKLdvLJ5LKurh_Mr0_x_55CICPytJsE1MRKsVSJtgSSBraw"
					},
					"ReportType": {
						"type": "string",
						"defaultValue": "AmortizedCost"
					}
				},
				"variables": {
					"Loop-Count": {
						"type": "String"
					},
					"Bearer": {
						"type": "String"
					},
					"blobPath": {
						"type": "String"
					},
					"daily": {
						"type": "String"
					},
					"Scope": {
						"type": "String",
						"defaultValue": "monthly"
					},
					"Year": {
						"type": "String"
					},
					"Month": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Path": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					},
					"Months": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-27T16:38:14Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ms_billing_output_file')]",
				"[concat(variables('workspaceId'), '/datasets/S037_New_Format_Usage_Data')]",
				"[concat(variables('workspaceId'), '/datasets/S037CSVSourceDataset')]",
				"[concat(variables('workspaceId'), '/datasets/New_API_Format_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - AmortisedCost - Histrorical Pull')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set Months",
						"description": "[\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\"]",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Months",
							"value": [
								"01",
								"02",
								"03",
								"04",
								"05",
								"06",
								"07",
								"08",
								"09",
								"10",
								"11",
								"12"
							]
						}
					},
					{
						"name": "ForEachMonth",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set Months",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Post Consumption Request",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
												"type": "Expression"
											},
											"Content-type": "application/json"
										},
										"url": {
											"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@concat('{\n  \"metric\": \"',pipeline().parameters.ReportType,'\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,item(),'\"\n  }')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set blobPath",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Post Consumption Request",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "blobPath",
										"value": {
											"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy file from MS to Synapse datastore",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set blobPath",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Amortized Usage Path",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "HttpReadSettings",
												"requestMethod": "GET"
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "ms_billing_output_file",
											"type": "DatasetReference",
											"parameters": {
												"blobPath": {
													"value": "@variables('blobPath')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "S037_New_Format_Usage_Data",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": "ActualCost"
											}
										}
									]
								},
								{
									"name": "CSV to Parquet",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Copy file from MS to Synapse datastore",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"wildcardFolderPath": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"wildcardFileName": {
													"value": "@concat('ACMMonthly',pipeline().parameters.ReportType,'_',variables('dateRange'),'.csv')",
													"type": "Expression"
												},
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Date",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Date",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Quantity",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "Quantity",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "EffectivePrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "EffectivePrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostInBillingCurrency",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostInBillingCurrency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Tags",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Tags",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Term",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Term",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PayGPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "PayGPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "UTF8"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "S037CSVSourceDataset",
											"type": "DatasetReference",
											"parameters": {
												"Year": {
													"value": "@variables('Year')",
													"type": "Expression"
												},
												"Month": {
													"value": "@variables('Month')",
													"type": "Expression"
												},
												"toDate": {
													"value": "@variables('toDate')",
													"type": "Expression"
												},
												"scope": {
													"value": "@variables('Scope')",
													"type": "Expression"
												},
												"fromDate": {
													"value": "@variables('fromDate')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "New_API_Format_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": {
													"value": "@pipeline().parameters.ReportType",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Set last day in Month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Month",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Year",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Month",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Month",
										"value": {
											"value": "@item()",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": {
											"value": "@pipeline().parameters.Year",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Amortized Usage Path",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Amortized Usage Date Range",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@concat('exports/monthly/ACMMonthly',pipeline().parameters.ReportType,'/',variables('dateRange'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Amortized Usage Date Range",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait 1 min",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "CSV to Parquet",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 60
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year": {
						"type": "string",
						"defaultValue": "2018"
					},
					"Bearer": {
						"type": "string",
						"defaultValue": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSIsImtpZCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSJ9.eyJhdWQiOiJodHRwczovL21hbmFnZW1lbnQuY29yZS53aW5kb3dzLm5ldCIsImlzcyI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0LzNhYTRhMjM1LWI2ZTItNDhkNS05MTk1LTdmY2YwNWI0NTliMC8iLCJpYXQiOjE2Njk1NDY2MTEsIm5iZiI6MTY2OTU0NjYxMSwiZXhwIjoxNjY5NTUxMjU4LCJhY3IiOiIxIiwiYWlvIjoiQVZRQXEvOFRBQUFBVUc1ZDMwZmtHZkNCNnhSNm14UUlWRGxpL1RhbURFYWh3ZWpnL2l3eVdtb2lrbTNVb1lpQlJHRFZQNDU2T3JZa2dwS3dPOCtwQkw5TlNrMFVlMUFjaTV6VHlOdjducjhsdndSUTZGbVNYbWs9IiwiYW1yIjpbInB3ZCIsIm1mYSJdLCJhcHBpZCI6IjE4ZmJjYTE2LTIyMjQtNDVmNi04NWIwLWY3YmYyYjM5YjNmMyIsImFwcGlkYWNyIjoiMCIsImZhbWlseV9uYW1lIjoiRmxvb2QiLCJnaXZlbl9uYW1lIjoiRGF2aWQiLCJncm91cHMiOlsiNmEwZjczMDEtMDM4ZS00MjMxLWFkNTYtNmQwMWFkY2I4NGVmIiwiZDg2MmNhMDItOWQ5OC00NzNkLTk3NjAtNTFjOGVmNjliZWZmIiwiZmZhZWE2MDMtNzU5YS00NDkwLTkzN2MtODc1MjZmNDJkMzFlIiwiZmFjYjA0MDYtYTk5ZS00YjFjLTliZDEtYjU4OTAzYWQ2MGM5IiwiY2JiOWZjMDYtYzVkNi00ODcyLThjODUtNDgwMjRlODljNjQ5IiwiOWViMjYzMDktMzVlMC00YTgwLTk2YWQtZTRjOWVjNTcxMWJlIiwiOTYyOWEyMGEtZWFlYy00OWIzLTk3ODQtMGFlOWE2NTcwZmM5IiwiMWRiNmJhMGMtMWQyZi00ZDc2LTlkYWUtMDg4MWU1OTEzYzVjIiwiY2IzOGMyMGQtZjRhMy00ZWMzLWIyNTgtZWQwMmM5MzY4NGYwIiwiMTkzY2YxMGQtN2RkMC00NmQ3LWExMDEtNDU1ODIwMjM0YTU2IiwiZjYzODQ4MGYtYjI5NS00NzdmLWJkZWEtYjk5ZWQ0MjFkYmEyIiwiMzE5ODllMGYtZDZlNS00OGU3LTk5NTItMTBhN2ZmYWUzYmI4IiwiMDc3ZTM4MTEtNzgzYS00YjlhLTlhNGItNWI5OWU3ZTY3MWMwIiwiMzEwMDQ3MTItZDkwZS00OWY2LTllNzktMmU5N2Y2OGY2ZDUwIiwiMDQ3ZmIwMTItNjk0Yy00NGMzLThkNDgtOTI3Y2IzNDk3ODhjIiwiYjcyYjY4MTQtZDE3Mi00ZTM2LWJiOTAtMGIzZjE1YTkxOTc3IiwiZjJjOTg4MTUtZTE2Ni00ZjkwLWE1ZjQtMWY1MzVmNWVkY2M4IiwiMDViOTZkMTYtYjY0NC00ZmNmLThhZTUtZmYwYzBmODI1YjVmIiwiYmMzOWYyMTctNDQxOS00MjkxLTk1MjctMzU2MTQ3N2EyZmI3IiwiMDAwMzExMWItMGMyZS00MDQxLWIxZGQtMGIyZWQxZWY2Zjc4IiwiMzA3MjhlMWUtNDZmMC00YjYxLWEwYmMtNmJjM2Y3MzYwYjhhIiwiYzY4ZTUwMWYtNmQxZi00YjRiLThmMzctMGM0NjgxNTZkZGYyIiwiNWFmMDk5MjEtZmQ2YS00NjExLTllYTktYTNiZmIxZjM1YmJlIiwiN2VmMzZjMjMtM2Y2Yi00MzIxLWIwMjgtYjgxYTliNDU5OTkxIiwiZGY2NWVhMjMtODhjMy00MzFhLWE4N2YtNjA1NWNmOWJkNTQ5IiwiM2I5NWRhMjctMzM3YS00NGMxLWI2OWQtNTY0NGI1MWE0ODM2IiwiOGZhM2JiMjgtODRmOS00YjA2LWE0ZDUtMDg5MDdlOGRkNmZhIiwiZTA0MGM0MjgtYWM1Ny00NTQyLWEzMjgtMmY2NzJhMzRjY2I4IiwiZTFjYWE0MmEtYmY2OS00MzkxLTlhNWUtYzhjZmRhZTFiNDE3IiwiOWZlNmU2MmEtMzExOC00NzA0LWFmYmUtODM0ODIyY2IwZDQzIiwiMGIxMDJiMmMtM2M5Ny00Yjc2LWI0ZGYtZTAzOTg2ODZhZjU2IiwiNzQ4YTAyMmUtOTY4ZS00YTk0LWFkZTMtOTI0ZTI2YmFkYWE4IiwiZGE1YTMzMmUtMTQ3MC00MGYzLTk4MDMtNDk3NWU1Njk0ZTViIiwiNGY2ZjRlMmYtYjIyMy00ZTczLWIzMzMtNWJiMWY3NjAxNGY0IiwiMjllMDM1MzAtZjgxOC00MDM2LWIyOGItOTdiOGI5NGYyNjUwIiwiYWQ1Nzc4MzItYTBlMS00YTA4LWJiZjQtMTI3MjQzYzZhNzUyIiwiMWRmZWJkMzUtN2U0ZC00ZjM5LTkyMjUtMDExZGFkZGRkZWIwIiwiMzA0OTRlMzYtMjA0MS00MDk2LWFjZjgtYjM2ODRhNjMwOWU0IiwiNWRkNTVjMzctMGI4NC00MGI0LTg3NjEtNTNiYjlhOTNhYzhmIiwiMzkyNzA5M2EtOGQ1OS00MTE5LTgzM2UtZTdhMDJmYjg4NzhjIiwiNjEyYWNiM2YtZTJkOC00YjU2LWI1NTAtMGZlNTU2ODk0Mjg0IiwiYjQwNzRmNDItNDAxYi00YzVlLTgxN2UtNmVmODMzNTliN2JmIiwiODQ5Y2Y0NDMtOWM1Yy00ZTMyLWEyZWEtNTVlYWVkZDllNmE2IiwiMjYxNTQwNDQtMmE3OC00YzgyLTk5OTMtMTZlMDg0NWM1NTgyIiwiYjM2YjI5NDUtMWQyNC00YzgzLTliYTUtMjUxNGE1NmY0OWEzIiwiNmM0YTI1NDktODBlYi00NmE5LTk5NzItOTI3MTc4ZjRjNGZmIiwiYzVkMjYyNGItNjVmOC00M2Q0LWExYTgtNTI4ZjFjNTI5N2QzIiwiMjQxZjFjNGMtNjIxMS00OGFjLWEwODgtYjYyZTFjMGIzM2FjIiwiNDUyMmE0NGQtNjYwZC00NGVjLTgwNzMtYWZkYzE2ZTRhZDdiIiwiNTMwMWI0NGQtZjUwNS00NDA3LTg3NmQtZWZhZTViN2JlOTgwIiwiNGM3MGZjNGYtYWI5NS00NzE0LThmMTctZGZkNzUwNmNmYjIwIiwiZTcxNjc3NTAtNWM1Yi00Yjc2LTg4YjItNjU4ZWJmMjEzZjFlIiwiOTFhNGFiNTAtYzQ0MS00YTlkLWJlNDMtYTAyYzQ4NWY5NWYzIiwiMWFiMzE4NTEtYzM2Yy00OTZmLThkNGMtM2E3YWE0NTkzNGM4IiwiMzJkYWQ4NTEtMGI2YS00NTMxLWI4MzUtMzA3MGNiZTkwYzUwIiwiNjQ4MGM0NTQtNWY2YS00ZDE5LWFkNGYtNWQwNGM4NjViYTg1IiwiNzZmZTAwNTUtMWQyNS00ZDE3LTk4ZGItNTVlMDY2N2Y2Y2JmIiwiYjFjMjYyNTYtOTZkZi00MzdmLWEzYWItOGUxNjYzZTY2YWIxIiwiZGRmYzI2NWEtMGJiZi00OWNlLWJiMDItNjdkNTEzYjc3YzJiIiwiZWFiNzdjNWItMGU2ZC00NWRmLTgzZjgtYTY1ZDk3MDcyMTVkIiwiZTJjZTkzNjAtZGJkNi00ZGQ0LTg1NTItODA2MmE1MTdiNWRkIiwiNzMyOTliNjAtNjAyMy00Y2ZkLTk4YzEtNWQ2NWUyZmNiNDdmIiwiMGZlMWVlNjAtNjMwNS00ZDBhLTliMTAtMzFiNTAyNmYyNWM3IiwiOTAwNzBmNjEtNjU3Mi00ZDRmLThkMDQtMjVhNGFlYjViMzc5IiwiM2UxMzY5NjMtMWYzOS00OGI4LWI1ZjItMjY0ZGEwMWE3YWE1IiwiYjAzMTU5NjQtOGNiMy00ZDEyLThhZDctOTRlODhjYTZiNzA3IiwiMTJlZWI5NjUtYzU1Zi00YmI0LThkYmItZjRlNmUwOGNjMzBhIiwiYjdiZTdjNjYtMDA2Yi00Njc4LWE1ZmQtMjNiNzI0NjBkOTE4IiwiOTM0NWU4NjYtZmFmZi00ZTdlLWI5YzAtNmRiMmQ2NThmNzkzIiwiNjhiNmQ0NmEtOTY5Mi00OWUxLWExYTYtYjA3NWY2YTJlOWQ5IiwiOWY2MmVjNmMtZWU0MS00NGU5LTkxMzEtOTliNzkyNTQxMzgyIiwiMWFjMTM3NmUtZjA0YS00NGI2LWJlNTgtYWExNjAwM2VhOTZlIiwiOWMzOGZhNmYtNGE4Zi00MjVkLWFiNDgtYjc3OTdhY2NmOGRlIiwiZmVjZTRhNzAtYTk2OC00YjdkLTk4YmEtOWFlMTMwOTc4YzljIiwiNmFjZDcxNzItNjA2Ni00NGFjLWIxOTAtOWNjZGE3YWI3YjY0IiwiMzc3NjYxNzMtY2Q4NS00NDc1LWExMWMtZWY2MWZjYTNhZmRjIiwiMGRmNTI5NzUtZGIxOS00ZmEzLWJjZDgtNjFkOGIyZTI4MmQ4IiwiZGFlZjA0NzctMzQxYi00ZGRlLTkzZmMtNGI4MTkwMTFiMjk0IiwiODk0OWEyNzctZGEzNC00YmIwLWFmMDEtYmRiZGZmNjVlYjZhIiwiYzQwZGUwNzktMmE1Ni00OTMyLThmMzUtMDUyOTc5YmRjMGZjIiwiMWI0YzhlN2ItYWMwYy00MTlhLWI4NzEtNzg5ZWZhNjFhNjdlIiwiMGRiNmJmN2ItNGIxYy00ZTljLWE1YjEtOTI4Yjk0MTI5YTZkIiwiZmI3YjY1N2UtYmE1OS00OGMzLTg2NTYtMjI0NGY3NzAzM2NkIiwiOGE4NTczN2YtMWYyZi00NjljLWFkZTUtNGQ5MDlhMjYzMjYxIiwiMzAwMTYwODAtMjg1Yy00N2M3LTg4ZDAtMjBmMmFiNThiNzMwIiwiNDczMTNmODEtMDZjZC00OTc5LTgwMDgtNDFjYTZhOTA3YWU3IiwiNDEyMTdhODYtZTU1ZS00ZDg4LWJjN2MtYTFlMTAxMWY3NjRiIiwiNzk4ZjljODgtMGUxYS00Mjg4LWI3MDQtMGQ2ODM0NTA3MGU0IiwiNTQyMGEyODgtYTNkZC00ZDgxLWE5MjctN2I2ZDk3NWFlZTE2IiwiYmYzYzBmOGEtYjQ5YS00M2M0LWI4N2EtOGQ4MmU0OGRkYThiIiwiNmM1OGVmOGItYzRiMi00MzhmLTk0NzUtYjlkZjFjYWI4YzBmIiwiM2VhYjk5OGMtODI0ZC00YWI5LTg1YTUtZTQyNGEwYTIxMWMxIiwiZTQxMWMwOGQtNzA0My00ZDFiLWJiYzEtMTE2NTBlYzJlMmFlIiwiN2Q2M2RhOGQtNDczMC00YmEwLTk2YmUtYWVlYWJlNjZlZjgxIiwiMWFiY2IzOTAtODAxMi00NTBmLTg5ZGUtYjlmMGZkN2YyMDMyIiwiNmUzN2FhOTItNTlhZS00ZGMxLWFiZGYtOGFhMjkxODM5ZTQzIiwiMDAwNWQzOTItNzU3ZC00YWM1LTkzYzItZmE0MTU4NmJiM2JmIiwiYmIyM2ZhOTYtZTg1OS00MGZlLTllNWMtMzk1ZmM2MGZhYmFkIiwiMDA5YjUzOWMtZGNlMy00NzNhLTg2NDMtN2RiOTRkMTYyODQ0IiwiMzdiNDgzOWUtNWIwYy00MjkzLWFmODgtMWEyNWFhODAwZjY3IiwiYTYzNjI2OWYtYTk2Ny00NWIyLWJiNGUtM2UwMmRiYjYyNGEyIiwiZGY0MWU1YTUtOTc0OS00MzBmLWE0MDktMmI2MzUzNDMzMDNhIiwiZDYxMzA0YTYtMjQzNi00ODZlLThiNDAtZDUzNTEyZjNhNWJmIiwiMWMxNzQzYTgtODk3MS00NTJiLWIzZmQtNjlhZWEzYTk3NTIzIiwiZWQ4OTgzYTgtYWY3NC00MzQ2LTg1NmYtYjYzMThmMjViNjI4IiwiYjYyNzUxYWEtYjkwMy00ODE1LWJmNGEtNmNhMWZkNjQzZWU3IiwiZTUyNmVlYWMtYTQ0MC00MzY0LTkxNGQtMTA5Y2ZlMzc5NDFlIiwiYWZmNGIwYWQtN2MzYy00ZDk1LTgzZGYtYmI1NjE4ZjYxZDBiIiwiM2VkYjY4YWUtZmFkNC00NjZmLWExMmQtYTY3NTM0ODBmODdiIiwiMjhlNDYxYjEtMGRjZC00ZTZkLWIzNmYtNGY0NzQ3ZjcyOWFiIiwiMWJhZjY4YjQtMjVjOC00OTk4LWIxNTktY2FlOWQ0ODkzNzdlIiwiZmE0MTcxYjQtMjc0MC00YjM2LWEwMjYtODBkZWNjZWM1NTQwIiwiMjkzOTg0YjQtZTUxOS00Njc2LTlkMmEtNmZhM2Y2NzJiZDFjIiwiY2I0MjI1YjctMzVhZi00NTMzLTg4OWYtNzI0MWM5OWYxNTFjIiwiMGQ3YWRhYjktZjE5ZC00YWY5LTllNmItN2RkNWEzZDdkOTlmIiwiM2VhODM2YmMtNGEyNS00ZmRiLTllMTgtNDY1NDc1NDkzZDZmIiwiOGY5NGY5YmMtMmE0My00NzAxLWExMmQtYzkzZTgwZGJkMjQyIiwiMTZmODEwYmUtZTI3OS00ZTIyLTgxYzEtNjJmNDk0NmNhNTA2IiwiYTUxMGNlYmYtMWU3OS00YzliLWIyMWUtNjk5ZjlkNzUxOWY5IiwiYmQ2M2Y2YzAtY2M2MS00NWViLWJiMGEtOTc1MTg1ZmM2MDFmIiwiNWYwNmRjYzEtMzI2My00MWY2LTliZmEtZmE2ZjBjZWI4NmQ5IiwiNGY2MDgwYzktY2UzOC00ZDVlLWIxNjctZWM1Mzc3YmRkZjg5IiwiYjQ5YjE0Y2EtMDNjNi00ZWMzLWJjYTUtMGQ0MzY5MzUwNmFiIiwiZGEzMzcxY2EtODA2Mi00NjcxLWIwYzgtNTM4YTljNmYyYWRkIiwiZTg5MTQ4Y2ItNGExZC00MzY3LThhYTQtYzdhYTY0NDJmNDcxIiwiYjRjNDcxY2ItZjI2My00ZTIyLWEwMzYtMTZkOGQxNjQ0NmZlIiwiYTg2YjgxY2MtYTBmYS00ZGNkLWE0NzAtYzlkNGZmYjRkMzQ3IiwiNzEzMzdhZDMtMWY2Yi00OTdlLTlhNDUtZmM2ZTk3ODIzNzhiIiwiYTkzYTEzZDktNjMxMS00MWUxLWIzYjYtZjk5ZDRmYjAyZWFkIiwiZjE2Nzk2ZGEtMzRmMy00ZjZhLWFjNDMtYzZhMTY5MWZiYjNjIiwiZmEyMDYyZGMtNjA2OC00NjFjLTkyYWQtYmJmZjYwMTI2ZDE5IiwiYmQyNWM0ZGQtNzFiOC00NWQzLTg3MDItOThjNDdmZTAwMTlkIiwiMDk0NWM0ZGYtMDFmMS00ZDFjLTkxOTctNmFhN2FmNGNlNzM3IiwiNjFjOTczZTAtYTAzMy00YmJhLTlhMzktNGRmZmE4YTMxMmQyIiwiYjhhM2IzZTMtZDlkZi00OTU2LTlmYTctNmRhYTY1MDYyNTc4IiwiMWFiM2M5ZTctZGRlMC00YWYxLWFkODktZTdmZGViN2JiOGQ4IiwiMmVmMzJhZWQtMGY4Yy00MTQzLThlMjItYzUxZjg2MWIzNTc3IiwiMjZiM2JkZWUtMWM4Zi00NGVjLTg5YmQtMDZmODAzYjE3Nzg3IiwiZDk5Y2VkZWYtYmM4Ny00MWNhLWJhYWQtNTczZmMzZWYyMGVkIiwiODJmOGYzZWYtOTA2MC00YTJmLWE1ODctNWY0N2NhMjM4YWI3IiwiY2E0NWY5ZWYtYTE3OS00OGY4LTgzMWQtOTQxYzRlYzIyMTEzIiwiYjBhY2I3ZjAtNGJkZC00ZDgzLWFjYjAtMjRkZDg2Y2FkOTA0IiwiMjExNTQyZjMtY2NiZC00ZDlhLTkzYTYtYzVmYmJkOTIxOWEzIiwiY2I1N2YwZjctZGYyYy00ZmFlLWE2YTAtNzMwNGJiMzcyN2JiIiwiOWU1OWY4ZjctY2Q2Ni00YTYzLWExMWUtYTI4NTVmZTJiOTg2IiwiNTY3ZmI2ZjgtNzA1OC00OTk2LWE1M2ItMmYyYzFiZDIxODRkIiwiOGE1NjhkZjktMmI2Yy00NDA5LTk0M2ItOWVmYWU2NGM5Yzc0IiwiMmY0YWIzZjktNjgyZC00NmQ2LTkyMDQtN2ViZGE3YmJkNDFjIiwiOTYwMTg4ZmEtNDA4ZS00OTAxLTk1MGUtZDZlMTlmZWQ1NGVmIiwiOTBiNmQ3ZmEtZmEyNi00YTg1LTkyZTMtOWRhMjA1ZWQ0NmM1IiwiYWFjMzdiZmItN2U4MS00MzFjLWJiNzAtNWNlNGU4MGJjYmRkIiwiOTllNjJhZmYtNGY3Ni00NjBhLWE2MTEtZjhhNDhlOThmNzQxIl0sImlwYWRkciI6IjkwLjI1MC45LjQ4IiwibmFtZSI6IkRhdmlkIEZsb29kIiwib2lkIjoiZDU0ZWE4OWUtN2UyZC00M2E0LWJlNDUtNTZjMzUwOWVkM2E2Iiwib25wcmVtX3NpZCI6IlMtMS01LTIxLTIyMDUyMzM4OC0xMDg1MDMxMjE0LTcyNTM0NTU0My0yMjIyMjgxIiwicHVpZCI6IjEwMDMzRkZGOERCQzVFMDciLCJyaCI6IjAuQVFJQU5hS2tPdUsyMVVpUmxYX1BCYlJac0VaSWYza0F1dGRQdWtQYXdmajJNQk1DQUowLiIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6IndvbE1sYkFpa0QtTG4td0FINHQ1d2dxMGo0Ql96VG9mbXhhZGlZdEstS0EiLCJ0aWQiOiIzYWE0YTIzNS1iNmUyLTQ4ZDUtOTE5NS03ZmNmMDViNDU5YjAiLCJ1bmlxdWVfbmFtZSI6IkRGTE9PQGVxdWlub3IuY29tIiwidXBuIjoiREZMT09AZXF1aW5vci5jb20iLCJ1dGkiOiJFZFc4eXJ3eDdVS01MdzlhNmN3T0FBIiwidmVyIjoiMS4wIiwid2lkcyI6WyJiNzlmYmY0ZC0zZWY5LTQ2ODktODE0My03NmIxOTRlODU1MDkiXSwieG1zX3RjZHQiOjEzNDQ1ODM2MDJ9.BNe4iO40n7t2exoCtJX_z2j4u8YmhNa5uCXgpeAM1w4_HWYeC5AUbb9CmWEsI5l_MgDYpW1xsnmKtP31Zwjkv10MHOXZiA_9bh_Ne-noEjR02Qh81Lx6pd_z1CrQOPAXUzCwAdmvTQdUFjpD6z8h1VhUpS1nhJMuPtVNtF4wlOzpDuAH6BMynkSrIDp1uDytGxV681f210s5Z-EZcAYmVaQyNV39UzpRYA5KYd6WHlNUqwPxut5cD81Hes1JdkNCxAWcNc2BeYQt7vBPZ4zu4dt-JxP2B-gWe_OaGbbWMe6_47ferq__kLG99l1xW2IWOYc5Dtw0_usE1gobXLaPzA"
					},
					"ReportType": {
						"type": "string",
						"defaultValue": "AmortizedCost"
					}
				},
				"variables": {
					"Loop-Count": {
						"type": "String"
					},
					"Bearer": {
						"type": "String"
					},
					"blobPath": {
						"type": "String"
					},
					"daily": {
						"type": "String"
					},
					"Scope": {
						"type": "String",
						"defaultValue": "monthly"
					},
					"Year": {
						"type": "String"
					},
					"Month": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Path": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					},
					"Months": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-27T16:38:07Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ms_billing_output_file')]",
				"[concat(variables('workspaceId'), '/datasets/S037_New_Format_Usage_Data')]",
				"[concat(variables('workspaceId'), '/datasets/S037CSVSourceDataset')]",
				"[concat(variables('workspaceId'), '/datasets/New_API_Format_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - Automated ActualCost - Histrorical Pull')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set Months",
						"description": "[\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\"]",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Months",
							"value": [
								"10",
								"01",
								"02",
								"03",
								"04",
								"05",
								"06",
								"07",
								"08",
								"09"
							]
						}
					},
					{
						"name": "ForEachMonth",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Set Months",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "Post Consumption Request",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": true
									},
									"userProperties": [],
									"typeProperties": {
										"method": "POST",
										"headers": {
											"Authorization": {
												"value": "@concat('Bearer ',pipeline().parameters.Bearer)",
												"type": "Expression"
											},
											"Content-type": "application/json"
										},
										"url": {
											"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/generateCostDetailsReport?api-version=2022-05-01",
											"type": "Expression"
										},
										"connectVia": {
											"referenceName": "AutoResolveIntegrationRuntime",
											"type": "IntegrationRuntimeReference"
										},
										"body": {
											"value": "@concat('{\n  \"metric\": \"',pipeline().parameters.ReportType,'\",\n  \"billingPeriod\": \"',pipeline().parameters.Year,item(),'\"\n  }')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set blobPath",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Post Consumption Request",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "blobPath",
										"value": {
											"value": "@activity('Post Consumption Request').output.manifest.blobs[0].blobLink",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Copy file from MS to Synapse datastore",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Set blobPath",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set ActualUsage Path",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "BinarySource",
											"storeSettings": {
												"type": "HttpReadSettings",
												"requestMethod": "GET"
											},
											"formatSettings": {
												"type": "BinaryReadSettings"
											}
										},
										"sink": {
											"type": "BinarySink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "ms_billing_output_file",
											"type": "DatasetReference",
											"parameters": {
												"blobPath": {
													"value": "@variables('blobPath')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "S037_New_Format_Usage_Data",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"ReportType": {
													"value": "@pipeline().parameters.ReportType",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "CSV to Parquet",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Copy file from MS to Synapse datastore",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": false,
												"wildcardFolderPath": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"wildcardFileName": {
													"value": "@concat('ACMMonthlyActualCost_',variables('dateRange'),'.csv')",
													"type": "Expression"
												},
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "ParquetSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "ParquetWriteSettings"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"mappings": [
												{
													"source": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AccountOwnerId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "SubscriptionName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceGroup",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceLocation",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Date",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Date",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterSubCategory",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "MeterRegion",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitOfMeasure",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Quantity",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "Quantity",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "EffectivePrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "EffectivePrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostInBillingCurrency",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostInBillingCurrency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostCenter",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ConsumedService",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Tags",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Tags",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "OfferId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AdditionalInfo",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo1",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceInfo2",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ResourceName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ReservationName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "UnitPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "UnitPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ProductOrderName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Term",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Term",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PublisherName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ChargeType",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "Frequency",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PricingModel",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "AvailabilityZone",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingAccountName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingCurrencyCode",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodStartDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingPeriodEndDate",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "BillingProfileName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "InvoiceSectionId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "IsAzureCreditEligible",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PartNumber",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PayGPrice",
														"type": "Double",
														"physicalType": "String"
													},
													"sink": {
														"name": "PayGPrice",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "PlanName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "ServiceFamily",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "CostAllocationRuleName",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitId",
														"type": "String",
														"physicalType": "UTF8"
													}
												},
												{
													"source": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "String"
													},
													"sink": {
														"name": "benefitName",
														"type": "String",
														"physicalType": "UTF8"
													}
												}
											],
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "S037CSVSourceDataset",
											"type": "DatasetReference",
											"parameters": {
												"Year": {
													"value": "@variables('Year')",
													"type": "Expression"
												},
												"Month": {
													"value": "@variables('Month')",
													"type": "Expression"
												},
												"toDate": {
													"value": "@variables('toDate')",
													"type": "Expression"
												},
												"scope": {
													"value": "@variables('Scope')",
													"type": "Expression"
												},
												"fromDate": {
													"value": "@variables('fromDate')",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "New_API_Format_Parquet",
											"type": "DatasetReference",
											"parameters": {
												"Path": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"dateRange": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Set last day in Month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Month",
											"dependencyConditions": [
												"Succeeded"
											]
										},
										{
											"activity": "Set Year",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Month",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Month",
										"value": {
											"value": "@item()",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": {
											"value": "@pipeline().parameters.Year",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set ActualUsage Path",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set ActualUsage Date Range",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@concat('exports/monthly/ACMMonthlyActualCost/',variables('dateRange'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set ActualUsage Date Range",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Wait 1 min",
									"type": "Wait",
									"dependsOn": [
										{
											"activity": "CSV to Parquet",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"userProperties": [],
									"typeProperties": {
										"waitTimeInSeconds": 60
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year": {
						"type": "string",
						"defaultValue": "2018"
					},
					"Bearer": {
						"type": "string",
						"defaultValue": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSIsImtpZCI6IjJaUXBKM1VwYmpBWVhZR2FYRUpsOGxWMFRPSSJ9.eyJhdWQiOiJodHRwczovL21hbmFnZW1lbnQuY29yZS53aW5kb3dzLm5ldCIsImlzcyI6Imh0dHBzOi8vc3RzLndpbmRvd3MubmV0LzNhYTRhMjM1LWI2ZTItNDhkNS05MTk1LTdmY2YwNWI0NTliMC8iLCJpYXQiOjE2Njk1NjcxNjksIm5iZiI6MTY2OTU2NzE2OSwiZXhwIjoxNjY5NTcxNTYyLCJhY3IiOiIxIiwiYWlvIjoiQVZRQXEvOFRBQUFBVU4rdFJZTnEvSXMzRTZyZFRoZWYvNXBMQVJ4Ky81enV4NnB2RXRxajJvckJLOCttOFVxVjloaHpuaVlJUzYweDUrWEMyaG5UOTdBeXEraktpeVdueXd1OW55VEIzWGo4TFVGNFRXbjJhbnc9IiwiYW1yIjpbInB3ZCIsIm1mYSJdLCJhcHBpZCI6IjE4ZmJjYTE2LTIyMjQtNDVmNi04NWIwLWY3YmYyYjM5YjNmMyIsImFwcGlkYWNyIjoiMCIsImZhbWlseV9uYW1lIjoiRmxvb2QiLCJnaXZlbl9uYW1lIjoiRGF2aWQiLCJncm91cHMiOlsiNmEwZjczMDEtMDM4ZS00MjMxLWFkNTYtNmQwMWFkY2I4NGVmIiwiZDg2MmNhMDItOWQ5OC00NzNkLTk3NjAtNTFjOGVmNjliZWZmIiwiZmZhZWE2MDMtNzU5YS00NDkwLTkzN2MtODc1MjZmNDJkMzFlIiwiZmFjYjA0MDYtYTk5ZS00YjFjLTliZDEtYjU4OTAzYWQ2MGM5IiwiY2JiOWZjMDYtYzVkNi00ODcyLThjODUtNDgwMjRlODljNjQ5IiwiOWViMjYzMDktMzVlMC00YTgwLTk2YWQtZTRjOWVjNTcxMWJlIiwiOTYyOWEyMGEtZWFlYy00OWIzLTk3ODQtMGFlOWE2NTcwZmM5IiwiMWRiNmJhMGMtMWQyZi00ZDc2LTlkYWUtMDg4MWU1OTEzYzVjIiwiY2IzOGMyMGQtZjRhMy00ZWMzLWIyNTgtZWQwMmM5MzY4NGYwIiwiMTkzY2YxMGQtN2RkMC00NmQ3LWExMDEtNDU1ODIwMjM0YTU2IiwiZjYzODQ4MGYtYjI5NS00NzdmLWJkZWEtYjk5ZWQ0MjFkYmEyIiwiMzE5ODllMGYtZDZlNS00OGU3LTk5NTItMTBhN2ZmYWUzYmI4IiwiMDc3ZTM4MTEtNzgzYS00YjlhLTlhNGItNWI5OWU3ZTY3MWMwIiwiMzEwMDQ3MTItZDkwZS00OWY2LTllNzktMmU5N2Y2OGY2ZDUwIiwiMDQ3ZmIwMTItNjk0Yy00NGMzLThkNDgtOTI3Y2IzNDk3ODhjIiwiYjcyYjY4MTQtZDE3Mi00ZTM2LWJiOTAtMGIzZjE1YTkxOTc3IiwiZjJjOTg4MTUtZTE2Ni00ZjkwLWE1ZjQtMWY1MzVmNWVkY2M4IiwiMDViOTZkMTYtYjY0NC00ZmNmLThhZTUtZmYwYzBmODI1YjVmIiwiYmMzOWYyMTctNDQxOS00MjkxLTk1MjctMzU2MTQ3N2EyZmI3IiwiMDAwMzExMWItMGMyZS00MDQxLWIxZGQtMGIyZWQxZWY2Zjc4IiwiMzA3MjhlMWUtNDZmMC00YjYxLWEwYmMtNmJjM2Y3MzYwYjhhIiwiYzY4ZTUwMWYtNmQxZi00YjRiLThmMzctMGM0NjgxNTZkZGYyIiwiNWFmMDk5MjEtZmQ2YS00NjExLTllYTktYTNiZmIxZjM1YmJlIiwiN2VmMzZjMjMtM2Y2Yi00MzIxLWIwMjgtYjgxYTliNDU5OTkxIiwiZGY2NWVhMjMtODhjMy00MzFhLWE4N2YtNjA1NWNmOWJkNTQ5IiwiM2I5NWRhMjctMzM3YS00NGMxLWI2OWQtNTY0NGI1MWE0ODM2IiwiOGZhM2JiMjgtODRmOS00YjA2LWE0ZDUtMDg5MDdlOGRkNmZhIiwiZTA0MGM0MjgtYWM1Ny00NTQyLWEzMjgtMmY2NzJhMzRjY2I4IiwiZTFjYWE0MmEtYmY2OS00MzkxLTlhNWUtYzhjZmRhZTFiNDE3IiwiOWZlNmU2MmEtMzExOC00NzA0LWFmYmUtODM0ODIyY2IwZDQzIiwiMGIxMDJiMmMtM2M5Ny00Yjc2LWI0ZGYtZTAzOTg2ODZhZjU2IiwiNzQ4YTAyMmUtOTY4ZS00YTk0LWFkZTMtOTI0ZTI2YmFkYWE4IiwiZGE1YTMzMmUtMTQ3MC00MGYzLTk4MDMtNDk3NWU1Njk0ZTViIiwiNGY2ZjRlMmYtYjIyMy00ZTczLWIzMzMtNWJiMWY3NjAxNGY0IiwiMjllMDM1MzAtZjgxOC00MDM2LWIyOGItOTdiOGI5NGYyNjUwIiwiYWQ1Nzc4MzItYTBlMS00YTA4LWJiZjQtMTI3MjQzYzZhNzUyIiwiMWRmZWJkMzUtN2U0ZC00ZjM5LTkyMjUtMDExZGFkZGRkZWIwIiwiMzA0OTRlMzYtMjA0MS00MDk2LWFjZjgtYjM2ODRhNjMwOWU0IiwiNWRkNTVjMzctMGI4NC00MGI0LTg3NjEtNTNiYjlhOTNhYzhmIiwiMzkyNzA5M2EtOGQ1OS00MTE5LTgzM2UtZTdhMDJmYjg4NzhjIiwiNjEyYWNiM2YtZTJkOC00YjU2LWI1NTAtMGZlNTU2ODk0Mjg0IiwiYjQwNzRmNDItNDAxYi00YzVlLTgxN2UtNmVmODMzNTliN2JmIiwiODQ5Y2Y0NDMtOWM1Yy00ZTMyLWEyZWEtNTVlYWVkZDllNmE2IiwiMjYxNTQwNDQtMmE3OC00YzgyLTk5OTMtMTZlMDg0NWM1NTgyIiwiYjM2YjI5NDUtMWQyNC00YzgzLTliYTUtMjUxNGE1NmY0OWEzIiwiNmM0YTI1NDktODBlYi00NmE5LTk5NzItOTI3MTc4ZjRjNGZmIiwiYzVkMjYyNGItNjVmOC00M2Q0LWExYTgtNTI4ZjFjNTI5N2QzIiwiMjQxZjFjNGMtNjIxMS00OGFjLWEwODgtYjYyZTFjMGIzM2FjIiwiNDUyMmE0NGQtNjYwZC00NGVjLTgwNzMtYWZkYzE2ZTRhZDdiIiwiNTMwMWI0NGQtZjUwNS00NDA3LTg3NmQtZWZhZTViN2JlOTgwIiwiNGM3MGZjNGYtYWI5NS00NzE0LThmMTctZGZkNzUwNmNmYjIwIiwiZTcxNjc3NTAtNWM1Yi00Yjc2LTg4YjItNjU4ZWJmMjEzZjFlIiwiOTFhNGFiNTAtYzQ0MS00YTlkLWJlNDMtYTAyYzQ4NWY5NWYzIiwiMWFiMzE4NTEtYzM2Yy00OTZmLThkNGMtM2E3YWE0NTkzNGM4IiwiMzJkYWQ4NTEtMGI2YS00NTMxLWI4MzUtMzA3MGNiZTkwYzUwIiwiNjQ4MGM0NTQtNWY2YS00ZDE5LWFkNGYtNWQwNGM4NjViYTg1IiwiNzZmZTAwNTUtMWQyNS00ZDE3LTk4ZGItNTVlMDY2N2Y2Y2JmIiwiYjFjMjYyNTYtOTZkZi00MzdmLWEzYWItOGUxNjYzZTY2YWIxIiwiZGRmYzI2NWEtMGJiZi00OWNlLWJiMDItNjdkNTEzYjc3YzJiIiwiZWFiNzdjNWItMGU2ZC00NWRmLTgzZjgtYTY1ZDk3MDcyMTVkIiwiZTJjZTkzNjAtZGJkNi00ZGQ0LTg1NTItODA2MmE1MTdiNWRkIiwiNzMyOTliNjAtNjAyMy00Y2ZkLTk4YzEtNWQ2NWUyZmNiNDdmIiwiMGZlMWVlNjAtNjMwNS00ZDBhLTliMTAtMzFiNTAyNmYyNWM3IiwiOTAwNzBmNjEtNjU3Mi00ZDRmLThkMDQtMjVhNGFlYjViMzc5IiwiM2UxMzY5NjMtMWYzOS00OGI4LWI1ZjItMjY0ZGEwMWE3YWE1IiwiYjAzMTU5NjQtOGNiMy00ZDEyLThhZDctOTRlODhjYTZiNzA3IiwiMTJlZWI5NjUtYzU1Zi00YmI0LThkYmItZjRlNmUwOGNjMzBhIiwiYjdiZTdjNjYtMDA2Yi00Njc4LWE1ZmQtMjNiNzI0NjBkOTE4IiwiOTM0NWU4NjYtZmFmZi00ZTdlLWI5YzAtNmRiMmQ2NThmNzkzIiwiNjhiNmQ0NmEtOTY5Mi00OWUxLWExYTYtYjA3NWY2YTJlOWQ5IiwiOWY2MmVjNmMtZWU0MS00NGU5LTkxMzEtOTliNzkyNTQxMzgyIiwiMWFjMTM3NmUtZjA0YS00NGI2LWJlNTgtYWExNjAwM2VhOTZlIiwiOWMzOGZhNmYtNGE4Zi00MjVkLWFiNDgtYjc3OTdhY2NmOGRlIiwiZmVjZTRhNzAtYTk2OC00YjdkLTk4YmEtOWFlMTMwOTc4YzljIiwiNmFjZDcxNzItNjA2Ni00NGFjLWIxOTAtOWNjZGE3YWI3YjY0IiwiMzc3NjYxNzMtY2Q4NS00NDc1LWExMWMtZWY2MWZjYTNhZmRjIiwiMGRmNTI5NzUtZGIxOS00ZmEzLWJjZDgtNjFkOGIyZTI4MmQ4IiwiZGFlZjA0NzctMzQxYi00ZGRlLTkzZmMtNGI4MTkwMTFiMjk0IiwiODk0OWEyNzctZGEzNC00YmIwLWFmMDEtYmRiZGZmNjVlYjZhIiwiYzQwZGUwNzktMmE1Ni00OTMyLThmMzUtMDUyOTc5YmRjMGZjIiwiMWI0YzhlN2ItYWMwYy00MTlhLWI4NzEtNzg5ZWZhNjFhNjdlIiwiMGRiNmJmN2ItNGIxYy00ZTljLWE1YjEtOTI4Yjk0MTI5YTZkIiwiZmI3YjY1N2UtYmE1OS00OGMzLTg2NTYtMjI0NGY3NzAzM2NkIiwiOGE4NTczN2YtMWYyZi00NjljLWFkZTUtNGQ5MDlhMjYzMjYxIiwiMzAwMTYwODAtMjg1Yy00N2M3LTg4ZDAtMjBmMmFiNThiNzMwIiwiNDczMTNmODEtMDZjZC00OTc5LTgwMDgtNDFjYTZhOTA3YWU3IiwiNDEyMTdhODYtZTU1ZS00ZDg4LWJjN2MtYTFlMTAxMWY3NjRiIiwiNzk4ZjljODgtMGUxYS00Mjg4LWI3MDQtMGQ2ODM0NTA3MGU0IiwiNTQyMGEyODgtYTNkZC00ZDgxLWE5MjctN2I2ZDk3NWFlZTE2IiwiYmYzYzBmOGEtYjQ5YS00M2M0LWI4N2EtOGQ4MmU0OGRkYThiIiwiNmM1OGVmOGItYzRiMi00MzhmLTk0NzUtYjlkZjFjYWI4YzBmIiwiM2VhYjk5OGMtODI0ZC00YWI5LTg1YTUtZTQyNGEwYTIxMWMxIiwiZTQxMWMwOGQtNzA0My00ZDFiLWJiYzEtMTE2NTBlYzJlMmFlIiwiN2Q2M2RhOGQtNDczMC00YmEwLTk2YmUtYWVlYWJlNjZlZjgxIiwiMWFiY2IzOTAtODAxMi00NTBmLTg5ZGUtYjlmMGZkN2YyMDMyIiwiNmUzN2FhOTItNTlhZS00ZGMxLWFiZGYtOGFhMjkxODM5ZTQzIiwiMDAwNWQzOTItNzU3ZC00YWM1LTkzYzItZmE0MTU4NmJiM2JmIiwiYmIyM2ZhOTYtZTg1OS00MGZlLTllNWMtMzk1ZmM2MGZhYmFkIiwiMDA5YjUzOWMtZGNlMy00NzNhLTg2NDMtN2RiOTRkMTYyODQ0IiwiMzdiNDgzOWUtNWIwYy00MjkzLWFmODgtMWEyNWFhODAwZjY3IiwiYTYzNjI2OWYtYTk2Ny00NWIyLWJiNGUtM2UwMmRiYjYyNGEyIiwiZGY0MWU1YTUtOTc0OS00MzBmLWE0MDktMmI2MzUzNDMzMDNhIiwiZDYxMzA0YTYtMjQzNi00ODZlLThiNDAtZDUzNTEyZjNhNWJmIiwiMWMxNzQzYTgtODk3MS00NTJiLWIzZmQtNjlhZWEzYTk3NTIzIiwiZWQ4OTgzYTgtYWY3NC00MzQ2LTg1NmYtYjYzMThmMjViNjI4IiwiYjYyNzUxYWEtYjkwMy00ODE1LWJmNGEtNmNhMWZkNjQzZWU3IiwiZTUyNmVlYWMtYTQ0MC00MzY0LTkxNGQtMTA5Y2ZlMzc5NDFlIiwiYWZmNGIwYWQtN2MzYy00ZDk1LTgzZGYtYmI1NjE4ZjYxZDBiIiwiM2VkYjY4YWUtZmFkNC00NjZmLWExMmQtYTY3NTM0ODBmODdiIiwiMjhlNDYxYjEtMGRjZC00ZTZkLWIzNmYtNGY0NzQ3ZjcyOWFiIiwiMWJhZjY4YjQtMjVjOC00OTk4LWIxNTktY2FlOWQ0ODkzNzdlIiwiZmE0MTcxYjQtMjc0MC00YjM2LWEwMjYtODBkZWNjZWM1NTQwIiwiMjkzOTg0YjQtZTUxOS00Njc2LTlkMmEtNmZhM2Y2NzJiZDFjIiwiY2I0MjI1YjctMzVhZi00NTMzLTg4OWYtNzI0MWM5OWYxNTFjIiwiMGQ3YWRhYjktZjE5ZC00YWY5LTllNmItN2RkNWEzZDdkOTlmIiwiM2VhODM2YmMtNGEyNS00ZmRiLTllMTgtNDY1NDc1NDkzZDZmIiwiOGY5NGY5YmMtMmE0My00NzAxLWExMmQtYzkzZTgwZGJkMjQyIiwiMTZmODEwYmUtZTI3OS00ZTIyLTgxYzEtNjJmNDk0NmNhNTA2IiwiYTUxMGNlYmYtMWU3OS00YzliLWIyMWUtNjk5ZjlkNzUxOWY5IiwiYmQ2M2Y2YzAtY2M2MS00NWViLWJiMGEtOTc1MTg1ZmM2MDFmIiwiNWYwNmRjYzEtMzI2My00MWY2LTliZmEtZmE2ZjBjZWI4NmQ5IiwiNGY2MDgwYzktY2UzOC00ZDVlLWIxNjctZWM1Mzc3YmRkZjg5IiwiYjQ5YjE0Y2EtMDNjNi00ZWMzLWJjYTUtMGQ0MzY5MzUwNmFiIiwiZGEzMzcxY2EtODA2Mi00NjcxLWIwYzgtNTM4YTljNmYyYWRkIiwiZTg5MTQ4Y2ItNGExZC00MzY3LThhYTQtYzdhYTY0NDJmNDcxIiwiYjRjNDcxY2ItZjI2My00ZTIyLWEwMzYtMTZkOGQxNjQ0NmZlIiwiYTg2YjgxY2MtYTBmYS00ZGNkLWE0NzAtYzlkNGZmYjRkMzQ3IiwiNzEzMzdhZDMtMWY2Yi00OTdlLTlhNDUtZmM2ZTk3ODIzNzhiIiwiYTkzYTEzZDktNjMxMS00MWUxLWIzYjYtZjk5ZDRmYjAyZWFkIiwiZjE2Nzk2ZGEtMzRmMy00ZjZhLWFjNDMtYzZhMTY5MWZiYjNjIiwiZmEyMDYyZGMtNjA2OC00NjFjLTkyYWQtYmJmZjYwMTI2ZDE5IiwiYmQyNWM0ZGQtNzFiOC00NWQzLTg3MDItOThjNDdmZTAwMTlkIiwiMDk0NWM0ZGYtMDFmMS00ZDFjLTkxOTctNmFhN2FmNGNlNzM3IiwiNjFjOTczZTAtYTAzMy00YmJhLTlhMzktNGRmZmE4YTMxMmQyIiwiYjhhM2IzZTMtZDlkZi00OTU2LTlmYTctNmRhYTY1MDYyNTc4IiwiMWFiM2M5ZTctZGRlMC00YWYxLWFkODktZTdmZGViN2JiOGQ4IiwiMmVmMzJhZWQtMGY4Yy00MTQzLThlMjItYzUxZjg2MWIzNTc3IiwiMjZiM2JkZWUtMWM4Zi00NGVjLTg5YmQtMDZmODAzYjE3Nzg3IiwiZDk5Y2VkZWYtYmM4Ny00MWNhLWJhYWQtNTczZmMzZWYyMGVkIiwiODJmOGYzZWYtOTA2MC00YTJmLWE1ODctNWY0N2NhMjM4YWI3IiwiY2E0NWY5ZWYtYTE3OS00OGY4LTgzMWQtOTQxYzRlYzIyMTEzIiwiYjBhY2I3ZjAtNGJkZC00ZDgzLWFjYjAtMjRkZDg2Y2FkOTA0IiwiMjExNTQyZjMtY2NiZC00ZDlhLTkzYTYtYzVmYmJkOTIxOWEzIiwiY2I1N2YwZjctZGYyYy00ZmFlLWE2YTAtNzMwNGJiMzcyN2JiIiwiOWU1OWY4ZjctY2Q2Ni00YTYzLWExMWUtYTI4NTVmZTJiOTg2IiwiNTY3ZmI2ZjgtNzA1OC00OTk2LWE1M2ItMmYyYzFiZDIxODRkIiwiOGE1NjhkZjktMmI2Yy00NDA5LTk0M2ItOWVmYWU2NGM5Yzc0IiwiMmY0YWIzZjktNjgyZC00NmQ2LTkyMDQtN2ViZGE3YmJkNDFjIiwiOTYwMTg4ZmEtNDA4ZS00OTAxLTk1MGUtZDZlMTlmZWQ1NGVmIiwiOTBiNmQ3ZmEtZmEyNi00YTg1LTkyZTMtOWRhMjA1ZWQ0NmM1IiwiYWFjMzdiZmItN2U4MS00MzFjLWJiNzAtNWNlNGU4MGJjYmRkIiwiOTllNjJhZmYtNGY3Ni00NjBhLWE2MTEtZjhhNDhlOThmNzQxIl0sImlwYWRkciI6IjkwLjI1MC45LjQ4IiwibmFtZSI6IkRhdmlkIEZsb29kIiwib2lkIjoiZDU0ZWE4OWUtN2UyZC00M2E0LWJlNDUtNTZjMzUwOWVkM2E2Iiwib25wcmVtX3NpZCI6IlMtMS01LTIxLTIyMDUyMzM4OC0xMDg1MDMxMjE0LTcyNTM0NTU0My0yMjIyMjgxIiwicHVpZCI6IjEwMDMzRkZGOERCQzVFMDciLCJyaCI6IjAuQVFJQU5hS2tPdUsyMVVpUmxYX1BCYlJac0VaSWYza0F1dGRQdWtQYXdmajJNQk1DQUowLiIsInNjcCI6InVzZXJfaW1wZXJzb25hdGlvbiIsInN1YiI6IndvbE1sYkFpa0QtTG4td0FINHQ1d2dxMGo0Ql96VG9mbXhhZGlZdEstS0EiLCJ0aWQiOiIzYWE0YTIzNS1iNmUyLTQ4ZDUtOTE5NS03ZmNmMDViNDU5YjAiLCJ1bmlxdWVfbmFtZSI6IkRGTE9PQGVxdWlub3IuY29tIiwidXBuIjoiREZMT09AZXF1aW5vci5jb20iLCJ1dGkiOiJMaGxtTkNGci1VLVM4aXFmbElIa0FBIiwidmVyIjoiMS4wIiwid2lkcyI6WyJiNzlmYmY0ZC0zZWY5LTQ2ODktODE0My03NmIxOTRlODU1MDkiXSwieG1zX3RjZHQiOjEzNDQ1ODM2MDJ9.ZqVIYzHaNehMqOsI-2Qs-1ejLh_5kfOhLFj2g2D3h-l3vklgM_BhvxuAYTy95P6mkdzBeDZGPqzf2DRAauHwlBjkWUcaVR6r08hLOkRy_Z_wMmQF-dci9RsOQuY_Z69MwZTQr2zy69jSmMu0uXZ0oG3owgRx3OvSwVko87wdWia4cdxRrmxx5C90nMm446Bw3OREiI7nq7xQL-GGYLP6UmcvcujlNwPQ2Evvn7tKSjhgSJX0IYGmFIX9SKFLnTiI-7XROI5JFknEyh713WHx95YrOxaOvtSseyz7mj8nyOl0l0WZNhNiPUBti25FLkApSQ9suz63AyNNKEWAdzzv9A"
					},
					"ReportType": {
						"type": "string",
						"defaultValue": "ActualCost"
					}
				},
				"variables": {
					"Loop-Count": {
						"type": "String"
					},
					"Bearer": {
						"type": "String"
					},
					"blobPath": {
						"type": "String"
					},
					"daily": {
						"type": "String"
					},
					"Scope": {
						"type": "String",
						"defaultValue": "monthly"
					},
					"Year": {
						"type": "String"
					},
					"Month": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Path": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					},
					"Months": {
						"type": "Array"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-27T16:45:59Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/datasets/ms_billing_output_file')]",
				"[concat(variables('workspaceId'), '/datasets/S037_New_Format_Usage_Data')]",
				"[concat(variables('workspaceId'), '/datasets/S037CSVSourceDataset')]",
				"[concat(variables('workspaceId'), '/datasets/New_API_Format_Parquet')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - Calculate Savings')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "ForEach1",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "Months",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@variables('Months')",
								"type": "Expression"
							},
							"activities": [
								{
									"name": "New API Calculate RI Savings",
									"type": "SynapseNotebook",
									"dependsOn": [
										{
											"activity": "Set ActualUsage Path",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"notebook": {
											"referenceName": "New API - Calculate Savings",
											"type": "NotebookReference"
										},
										"parameters": {
											"Path": {
												"value": {
													"value": "@variables('Path')",
													"type": "Expression"
												},
												"type": "string"
											},
											"year": {
												"value": {
													"value": "@pipeline().parameters.Year",
													"type": "Expression"
												},
												"type": "string"
											},
											"month": {
												"value": {
													"value": "@item()",
													"type": "Expression"
												},
												"type": "string"
											},
											"dateRange": {
												"value": {
													"value": "@variables('dateRange')",
													"type": "Expression"
												},
												"type": "string"
											},
											"reportType": {
												"value": {
													"value": "@pipeline().parameters.reportType",
													"type": "Expression"
												},
												"type": "string"
											},
											"storageAccount": {
												"value": {
													"value": "@pipeline().parameters.storageAccount",
													"type": "Expression"
												},
												"type": "string"
											}
										},
										"snapshot": true,
										"executorSize": null,
										"conf": {
											"spark.dynamicAllocation.enabled": null,
											"spark.dynamicAllocation.minExecutors": null,
											"spark.dynamicAllocation.maxExecutors": null
										},
										"driverSize": null,
										"numExecutors": null
									}
								},
								{
									"name": "Set last day in Month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set first day of month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "toDate",
										"value": {
											"value": "@replace(adddays(formatDateTime(adddays(formatDateTime(variables('fromDate'), 'yyyy-MM-28'),5), 'yyyy-MM-01'),-1),'T00:00:00.0000000','')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set first day of month",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set Year",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "fromDate",
										"value": {
											"value": "@concat(variables('Year'),'-',item(),'-01')",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set Year",
									"type": "SetVariable",
									"dependsOn": [],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Year",
										"value": {
											"value": "@pipeline().parameters.Year",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set ActualUsage Path",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set ActualUsage Date Range",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "Path",
										"value": {
											"value": "@if(equals(pipeline().parameters.reportType,'ActualCost'),concat('exports/monthly/ACMMonthlyActualCost/',variables('dateRange')),if(equals(pipeline().parameters.reportType,'AmortizedCost'),concat('exports/monthly/ACMMonthlyAmortizedCost/',variables('dateRange')),'Not Found'))",
											"type": "Expression"
										}
									}
								},
								{
									"name": "Set ActualUsage Date Range",
									"type": "SetVariable",
									"dependsOn": [
										{
											"activity": "Set last day in Month",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"variableName": "dateRange",
										"value": {
											"value": "@concat(replace(variables('fromDate'),'-',''),'-',replace(variables('toDate'),'-',''))",
											"type": "Expression"
										}
									}
								}
							]
						}
					},
					{
						"name": "Months",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "Months",
							"value": [
								"01",
								"02",
								"03",
								"04",
								"05",
								"06",
								"07",
								"08",
								"09",
								"10",
								"11",
								"12"
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Year": {
						"type": "string",
						"defaultValue": "2022"
					},
					"reportType": {
						"type": "string",
						"defaultValue": "ActualCost"
					},
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('New API - Calculate Savings_pipelineStorageAccountParameter')]"
					}
				},
				"variables": {
					"Months": {
						"type": "Array"
					},
					"Year": {
						"type": "String"
					},
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					},
					"Path": {
						"type": "String"
					},
					"dateRange": {
						"type": "String"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-03-08T15:35:11Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/New API - Calculate Savings')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API Create Export S909 Subscription Scope_copy1')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get SP Secret",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/token",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('client_id=1810d95a-5adb-4a43-b31f-44a7bdc0bbcd&client_secret=',activity('Get SP Secret').output.value,'&grant_type=client_credentials&resource=https://management.azure.com&scope=./default')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Get SP Secret",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://acm-toolkit-kv.vault.azure.net/secrets/ACM-Billing-Reader-PW/bb760feaba3f4d5385a40b68541dafa5?api-version=7.0",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Create Export - ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/ActualCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - ActualCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/ActualCost/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export ActualCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/ActualCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					},
					{
						"name": "Create Export - AmortisedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/AmortizedCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"AmortizedCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export  - AmortisedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - AmortisedCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/AmortizedCost/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"AmortizedCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - AmortizedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export  - AmortisedCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/AmortizedCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					},
					{
						"name": "Create Export - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/Usage/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"Usage\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export  - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - Usage",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/Usage/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"Usage\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/',pipeline().parameters.subscriptionNo,'\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export  - Usage",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/Usage/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"from_date": {
						"type": "string",
						"defaultValue": "2022-08-01"
					},
					"to_date": {
						"type": "string",
						"defaultValue": "2022-08-31"
					},
					"subscriptionId": {
						"type": "string",
						"defaultValue": "a6abe45d-e638-4325-a7e9-5559450aa434"
					},
					"subscriptionNo": {
						"type": "string",
						"defaultValue": "S909"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-18T13:45:56Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API Run Export Billing Account Scope')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get SP Secret",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/token",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('client_id=1810d95a-5adb-4a43-b31f-44a7bdc0bbcd&client_secret=',activity('Get SP Secret').output.value,'&grant_type=client_credentials&resource=https://management.azure.com&scope=./default')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Get SP Secret",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://acm-toolkit-kv.vault.azure.net/secrets/ACM-Billing-Reader-PW/bb760feaba3f4d5385a40b68541dafa5?api-version=7.0",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Run Export",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "https://management.azure.com/providers/Microsoft.Billing/billingAccounts/57950773/providers/Microsoft.CostManagement/exports/ACMMonthlyActualCost/run?api-version=2021-10-01",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"2022-01-01T00:00:00.000Z\",\n        \"to\": \"2022-01-02T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"Test-Export\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-18T13:45:51Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API Run Export Subscription Scope')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get SP Secret",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/token",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('client_id=1810d95a-5adb-4a43-b31f-44a7bdc0bbcd&client_secret=',activity('Get SP Secret').output.value,'&grant_type=client_credentials&resource=https://management.azure.com&scope=./default')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Get SP Secret",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": "https://acm-toolkit-kv.vault.azure.net/secrets/ACM-Billing-Reader-PW/bb760feaba3f4d5385a40b68541dafa5?api-version=7.0",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Run Export",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/',pipeline().parameters.Export_Name,'/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"Test-Export\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Export_Name": {
						"type": "string",
						"defaultValue": "test"
					},
					"from_date": {
						"type": "string",
						"defaultValue": "2022-08-01"
					},
					"to_date": {
						"type": "string",
						"defaultValue": "2022-08-31"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-18T13:45:48Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Omnia1 Create Export S037 Subscription Scope')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get token",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get SP Secret",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Content-Type": "application/x-www-form-urlencoded"
							},
							"url": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/token",
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('client_id=',pipeline().parameters.clientId,'&client_secret=',activity('Get SP Secret').output.value,'&grant_type=client_credentials&resource=https://management.azure.com&scope=./default')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Get SP Secret",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": {
								"value": "@concat(pipeline().parameters.KV_Address,'?api-version=7.0')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					},
					{
						"name": "Create Export - ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/ActualCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - ActualCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/ActualCost/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"ActualCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - ActualCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export ActualCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/ActualCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					},
					{
						"name": "Create Export - AmortisedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/AmortizedCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"AmortizedCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export  - AmortisedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - AmortisedCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/AmortizedCost/run?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"AmortizedCost\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - AmortizedCost",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export  - AmortisedCost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/AmortizedCost/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					},
					{
						"name": "Create Export - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Get token",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"method": "PUT",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/',pipeline().parameters.subscriptionId,'/providers/Microsoft.CostManagement/exports/Usage/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"Usage\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Run Export  - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Create Export - Usage",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "POST",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/Usage/run?api-version=2021-10-01",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"body": {
								"value": "@concat('{\n  \"properties\": {\n    \"definition\": {\n      \"dataset\": {\n        \"granularity\": \"Daily\",\n        \"grouping\": []\n      },\n      \"timePeriod\": {\n        \"from\": \"',pipeline().parameters.from_date,'T00:00:00.000Z\",\n        \"to\": \"',pipeline().parameters.to_date,'T00:00:00.000Z\"\n      },\n      \"timeframe\": \"Custom\",\n      \"type\": \"Usage\"\n    },\n    \"deliveryInfo\": {\n      \"destination\": {\n        \"container\": \"usage\",\n        \"rootFolderPath\": \"exports/S037-Test\",\n        \"resourceId\": \"/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt\"\n      }\n    },\n    \"format\": \"Csv\",\n    \"partitionData\": false\n  }\n}')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Delete Export - Usage",
						"type": "WebActivity",
						"dependsOn": [
							{
								"activity": "Run Export  - Usage",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "DELETE",
							"headers": {
								"Authorization": {
									"value": "@concat('Bearer ',activity('Get token').output.access_token)",
									"type": "Expression"
								}
							},
							"url": {
								"value": "@concat('https://management.azure.com/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/providers/Microsoft.CostManagement/exports/Usage/?api-version=2021-10-01')",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"from_date": {
						"type": "string",
						"defaultValue": "2022-08-01"
					},
					"to_date": {
						"type": "string",
						"defaultValue": "2022-08-31"
					},
					"KV_Address": {
						"type": "string",
						"defaultValue": "https://acm-toolkit-kv.vault.azure.net/secrets/Omnia-Cost-Management-Reporting/b6c969f1651040e1a29288275394d776"
					},
					"clientId": {
						"type": "string",
						"defaultValue": "0dd0cea7-0ff9-4dd4-99aa-99d63d3afeec"
					},
					"subscriptionId": {
						"type": "string",
						"defaultValue": "13d66f54-0a19-4912-b4f3-54d15897368d"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep"
				},
				"annotations": [],
				"lastPublishTime": "2022-11-18T13:46:02Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Populate Cost Code and Cost Type fields')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Populate Cost Code and Cost Type fields",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Populate Cost Code and Cost Type fields",
								"type": "NotebookReference"
							},
							"parameters": {
								"year": {
									"value": {
										"value": "@pipeline().parameters.year",
										"type": "Expression"
									},
									"type": "string"
								},
								"month": {
									"value": {
										"value": "@pipeline().parameters.month",
										"type": "Expression"
									},
									"type": "string"
								},
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"year": {
						"type": "string",
						"defaultValue": "2022"
					},
					"month": {
						"type": "string",
						"defaultValue": "01"
					},
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('Populate Cost Code and Cost Type fields_pipelineStorageAccountParameter')]"
					}
				},
				"variables": {
					"fromDate": {
						"type": "String"
					},
					"toDate": {
						"type": "String"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-05-01T09:40:53Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Populate Cost Code and Cost Type fields')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Recommendations')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Get RI Recommendations",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Get RI Recommendations",
								"type": "NotebookReference"
							},
							"parameters": {
								"scope": {
									"value": {
										"value": "@pipeline().parameters.scope",
										"type": "Expression"
									},
									"type": "string"
								},
								"resourceType": {
									"value": {
										"value": "@pipeline().parameters.resourceType",
										"type": "Expression"
									},
									"type": "string"
								},
								"lookBackPeriod": {
									"value": {
										"value": "@pipeline().parameters.lookBackPeriod",
										"type": "Expression"
									},
									"type": "string"
								},
								"billingAccount": {
									"value": {
										"value": "@pipeline().parameters.billingAccount",
										"type": "Expression"
									},
									"type": "string"
								},
								"term": {
									"value": {
										"value": "@pipeline().parameters.term",
										"type": "Expression"
									},
									"type": "string"
								},
								"filename": {
									"value": {
										"value": "@concat(\n    'abfss://', \n    pipeline().parameters.container,\n    's037costmgmt.dfs.core.windows.net/',\n    pipeline().parameters.folder,\n    '/',\n    if(equals(pipeline().parameters.resourceType,'VirtualMachines'),\n        'VM',\n        pipeline().parameters.resourceType),\n    '-RI-Recommendations-',\n    pipeline().parameters.scope,\n    '-Scope.csv')\n",
										"type": "Expression"
									},
									"type": "string"
								},
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('RI Recommendations_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Small",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Small"
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"scope": {
						"type": "string",
						"defaultValue": "Shared"
					},
					"lookBackPeriod": {
						"type": "string",
						"defaultValue": "Last30Days"
					},
					"resourceType": {
						"type": "string",
						"defaultValue": "VirtualMachines"
					},
					"billingAccount": {
						"type": "string",
						"defaultValue": "57950773"
					},
					"term": {
						"type": "string",
						"defaultValue": "P3Y"
					},
					"container": {
						"type": "string",
						"defaultValue": "reservations"
					},
					"folder": {
						"type": "string",
						"defaultValue": "recommendations"
					},
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('RI Recommendations_pipelineStorageAccountParameter')]"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Keep/Management API (New)"
				},
				"annotations": [],
				"lastPublishTime": "2023-01-26T10:22:30Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Get RI Recommendations')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('RI Recommendations_pipelineSparkPoolNameRef'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM-Performance')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "VM-Performance",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "VM-Performance",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('VM-Performance_pipelineStorageAccountParameter')]"
					}
				},
				"folder": {
					"name": "PipelinesNotInUse/Performance"
				},
				"annotations": [],
				"lastPublishTime": "2023-03-09T13:13:15Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/VM-Performance')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/build-ri-recommendations')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Retrieve autofit combometer data from CCM blob storage",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "InstanceSizeFlexibilityGroup",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "InstanceSizeFlexibilityGroup",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ResourceLocation",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ArmSkuName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ArmSkuName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Ratio",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Ratio",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ComboMeter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ComboMeter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "HardwareMeter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "HardwareMeter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "SoftwareMeter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "SoftwareMeter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CompositeKey",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CompositeKey",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "NormalizedSKU",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "NormalizedSKU",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "AutofitCombometerSource",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "AutofitCombometerSink",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Combine RI recommendations and Autofit Combometer data",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Retrieve autofit combometer data from CCM blob storage",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "combine-recommendations-and-autofitcombometer",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('build-ri-recommendations_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/HUB and RI"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/AutofitCombometerSource')]",
				"[concat(variables('workspaceId'), '/datasets/AutofitCombometerSink')]",
				"[concat(variables('workspaceId'), '/notebooks/combine-recommendations-and-autofitcombometer')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-hub-and-ri-savings')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "HUB Daily File",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "HUB_Daily_File",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('compute-hub-and-ri-savings_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Medium",
							"conf": {
								"spark.dynamicAllocation.enabled": true
							},
							"driverSize": "Medium"
						}
					},
					{
						"name": "Compute HUB and RI Savings",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "HUB Daily File",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "compute-hub-and-ri-savings",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": "s037costmgmt",
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('compute-hub-and-ri-savings_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/HUB and RI"
				},
				"annotations": [],
				"lastPublishTime": "2023-08-17T22:03:18Z"
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/HUB_Daily_File')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('compute-hub-and-ri-savings_pipelineSparkPoolNameRef'))]",
				"[concat(variables('workspaceId'), '/notebooks/compute-hub-and-ri-savings')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-hub-deployments')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Compute VM HUB deployments",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Set todays date",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "vm-hub-deployments",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Compute SQL HUB deployments",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Set todays date",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "sql-hub-deployments",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Set todays date",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "today",
							"value": {
								"value": "@concat(formatDateTime(utcnow(),'yyyy-MM-dd'))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Persist VM logs",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Compute VM HUB deployments",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@activity('Compute VM HUB deployments').output.status.Output.result.exitValue",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "Persist VM deployment log",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "VMDeploymentsSource",
											"type": "DatasetReference",
											"parameters": {}
										}
									],
									"outputs": [
										{
											"referenceName": "VMDeploymentSink",
											"type": "DatasetReference",
											"parameters": {
												"today": {
													"value": "@variables('today')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Persist VM disable log",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Persist VM deployment log",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "VMDisableSource",
											"type": "DatasetReference",
											"parameters": {}
										}
									],
									"outputs": [
										{
											"referenceName": "VMDisableSink",
											"type": "DatasetReference",
											"parameters": {
												"today": {
													"value": "@variables('today')",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					},
					{
						"name": "Persist SQL logs",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "Compute SQL HUB deployments",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@activity('Compute SQL HUB deployments').output.status.Output.result.exitValue",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "Persist SQL deployment log",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "SQLDeploymentSource",
											"type": "DatasetReference",
											"parameters": {}
										}
									],
									"outputs": [
										{
											"referenceName": "SQLDeploymentSink",
											"type": "DatasetReference",
											"parameters": {
												"today": {
													"value": "@variables('today')",
													"type": "Expression"
												}
											}
										}
									]
								},
								{
									"name": "Persist SQL disable log",
									"type": "Copy",
									"dependsOn": [
										{
											"activity": "Persist SQL deployment log",
											"dependencyConditions": [
												"Succeeded"
											]
										}
									],
									"policy": {
										"timeout": "0.12:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "DelimitedTextSource",
											"storeSettings": {
												"type": "AzureBlobFSReadSettings",
												"recursive": true,
												"enablePartitionDiscovery": false
											},
											"formatSettings": {
												"type": "DelimitedTextReadSettings"
											}
										},
										"sink": {
											"type": "DelimitedTextSink",
											"storeSettings": {
												"type": "AzureBlobFSWriteSettings"
											},
											"formatSettings": {
												"type": "DelimitedTextWriteSettings",
												"quoteAllText": true,
												"fileExtension": ".txt"
											}
										},
										"enableStaging": false,
										"translator": {
											"type": "TabularTranslator",
											"typeConversion": true,
											"typeConversionSettings": {
												"allowDataTruncation": true,
												"treatBooleanAsNumber": false
											}
										}
									},
									"inputs": [
										{
											"referenceName": "SQLDisableSource",
											"type": "DatasetReference",
											"parameters": {}
										}
									],
									"outputs": [
										{
											"referenceName": "SQLDisableSink",
											"type": "DatasetReference",
											"parameters": {
												"today": {
													"value": "@variables('today')",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('compute-hub-deployments_pipelineStorageAccountParameter')]"
					}
				},
				"variables": {
					"today": {
						"type": "String"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/HUB and RI"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/vm-hub-deployments')]",
				"[concat(variables('workspaceId'), '/notebooks/sql-hub-deployments')]",
				"[concat(variables('workspaceId'), '/datasets/VMDeploymentsSource')]",
				"[concat(variables('workspaceId'), '/datasets/VMDeploymentSink')]",
				"[concat(variables('workspaceId'), '/datasets/VMDisableSource')]",
				"[concat(variables('workspaceId'), '/datasets/VMDisableSink')]",
				"[concat(variables('workspaceId'), '/datasets/SQLDeploymentSource')]",
				"[concat(variables('workspaceId'), '/datasets/SQLDeploymentSink')]",
				"[concat(variables('workspaceId'), '/datasets/SQLDisableSource')]",
				"[concat(variables('workspaceId'), '/datasets/SQLDisableSink')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/full-pbi-1yr-refresh')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Refresh 1yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-dataset-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"Database": {
									"value": "@variables('Database')",
									"type": "Expression"
								},
								"TableName": {
									"value": "@variables('TableName')",
									"type": "Expression"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"Database": {
						"type": "String",
						"defaultValue": "FinOps_DataFoundamental"
					},
					"TableName": {
						"type": "String",
						"defaultValue": "ACMMonthlyAmortizedCost_Detailed_Oneyear"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/PBI Refresh"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-dataset-refresh')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/full-pbi-3yr-refresh')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Refresh 3yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-dataset-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {
								"Database": {
									"value": "@variables('Database')",
									"type": "Expression"
								},
								"TableName": {
									"value": "@variables('TableName')",
									"type": "Expression"
								}
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"Database": {
						"type": "String",
						"defaultValue": "FinOps_DataFoundamental"
					},
					"TableName": {
						"type": "String",
						"defaultValue": "ACMMonthlyAmortizedCost_overview_Threeyear"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/PBI Refresh"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-dataset-refresh')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/full-pbi-dataset-refresh')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Run automation refresh script",
						"type": "WebHook",
						"dependsOn": [
							{
								"activity": "Get Webhook URL",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": true
						},
						"userProperties": [],
						"typeProperties": {
							"url": {
								"value": "@activity('Get Webhook URL').output.value",
								"type": "Expression"
							},
							"method": "POST",
							"headers": {},
							"body": {
								"value": "@json(\n\tconcat(' \n\t\t{\"Database\": \"',pipeline().parameters.Database,'\", \n\t\t\"TableName\": \"',pipeline().parameters.TableName,'\"}'\n\t\t)\n\t)",
								"type": "Expression"
							},
							"timeout": "10:00:00"
						}
					},
					{
						"name": "Get Webhook URL",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": true,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"method": "GET",
							"headers": {},
							"url": {
								"value": "https://@{variables('KVName')}.vault.azure.net/secrets/@{variables('SecretName')}?api-version=7.4",
								"type": "Expression"
							},
							"connectVia": {
								"referenceName": "AutoResolveIntegrationRuntime",
								"type": "IntegrationRuntimeReference"
							},
							"authentication": {
								"type": "MSI",
								"resource": "https://vault.azure.net"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"Database": {
						"type": "string"
					},
					"TableName": {
						"type": "string"
					}
				},
				"variables": {
					"KVName": {
						"type": "String",
						"defaultValue": "acm-toolkit-kv"
					},
					"SecretName": {
						"type": "String",
						"defaultValue": "finops-reports-full-refresh-webhook"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/PBI Refresh"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/full-pbi-refresh-all')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Refresh 3yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-3yr-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Refresh 1yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Refresh 3yr dataset",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-1yr-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction/PBI Refresh"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-3yr-refresh')]",
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-1yr-refresh')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/persist-latest')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Set first day of month",
						"type": "SetVariable",
						"dependsOn": [],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "firstday",
							"value": {
								"value": "@concat(formatDateTime(utcNow(), 'yyyyMM'), '01')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set last day of month",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set first day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "lastday",
							"value": {
								"value": "@formatDateTime(subtractFromTime(concat(formatDateTime(addToTime(utcNow(), 1, 'Month'),'yyyy-MM'), '-01'), 1, 'Day'), 'yyyyMMdd')",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Set folder path",
						"type": "SetVariable",
						"dependsOn": [
							{
								"activity": "Set last day of month",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"variableName": "folderpath",
							"value": {
								"value": "@concat(variables('firstday'), '-', variables('lastday'))",
								"type": "Expression"
							}
						}
					},
					{
						"name": "Persist with latest suffix",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Set folder path",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "persist-latest-pricesheet",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": "s037costmgmt",
									"type": "string"
								},
								"dateRange": {
									"value": {
										"value": "@variables('folderpath')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Convert pricesheet csv to parquet",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "Persist with latest suffix",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": {
										"value": "@concat('pricesheet/portal-export/FinOps-Pricesheet-Monthly/', variables('folderpath'), '/*')",
										"type": "Expression"
									},
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "PricesheetExportSource",
								"type": "DatasetReference",
								"parameters": {
									"dateRange": {
										"value": "@variables('folderpath')",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "PricesheetExportSink",
								"type": "DatasetReference",
								"parameters": {
									"dateRange": {
										"value": "@variables('folderpath')",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"concurrency": 1,
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"lastday": {
						"type": "String"
					},
					"firstday": {
						"type": "String"
					},
					"folderpath": {
						"type": "String"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Pricesheet"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/persist-latest-pricesheet')]",
				"[concat(variables('workspaceId'), '/datasets/PricesheetExportSource')]",
				"[concat(variables('workspaceId'), '/datasets/PricesheetExportSink')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-cost-and-refresh')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Update historic cost",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Run Notebook on Previous Dates_v1",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Update 1yr source",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Update historic cost",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Prod_Extended_Amortized_Cost-Oneyear",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Update 3yr source",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Update 1yr source",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Prod_Extended_Amortized_Cost-Threeyears",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					},
					{
						"name": "Refresh 3yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Update 3yr source",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-3yr-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					},
					{
						"name": "Refresh 1yr dataset",
						"type": "ExecutePipeline",
						"dependsOn": [
							{
								"activity": "Refresh 3yr dataset",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"pipeline": {
								"referenceName": "full-pbi-1yr-refresh",
								"type": "PipelineReference"
							},
							"waitOnCompletion": true,
							"parameters": {}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('process-cost-and-refresh_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/PBI Refresh"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Run Notebook on Previous Dates_v1')]",
				"[concat(variables('workspaceId'), '/notebooks/Prod_Extended_Amortized_Cost-Oneyear')]",
				"[concat(variables('workspaceId'), '/notebooks/Prod_Extended_Amortized_Cost-Threeyears')]",
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-3yr-refresh')]",
				"[concat(variables('workspaceId'), '/pipelines/full-pbi-1yr-refresh')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-cost-history')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Process historic cost",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "Run Notebook on Previous Dates_v1",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('process-cost-history_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/Cost"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/Run Notebook on Previous Dates_v1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-ri-purchases')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Transform RI Purchaes to parquet",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "DelimitedTextSource",
								"storeSettings": {
									"type": "AzureBlobFSReadSettings",
									"recursive": true,
									"wildcardFolderPath": "portal-export/FinOps-ReservationTransactions-Daily/*/*",
									"wildcardFileName": "*.csv",
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "DelimitedTextReadSettings"
								}
							},
							"sink": {
								"type": "ParquetSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings",
									"copyBehavior": "MergeFiles"
								},
								"formatSettings": {
									"type": "ParquetWriteSettings"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "AccountOwnerEmail",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Amount",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Amount",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ArmSkuName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ArmSkuName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingFrequency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingFrequency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "BillingMonth",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "BillingMonth",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CostCenter",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Currency",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Currency",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "CurrentEnrollmentId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "CurrentEnrollmentId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "DepartmentName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Description",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Description",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EventDate",
											"type": "DateTime",
											"physicalType": "String"
										},
										"sink": {
											"name": "EventDate",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "EventType",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "EventType",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "MonetaryCommitment",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "MonetaryCommitment",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Overage",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Overage",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PurchasingSubscriptionGuid",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PurchasingSubscriptionGuid",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PurchasingSubscriptionName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PurchasingSubscriptionName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "PurchasingEnrollment",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "PurchasingEnrollment",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Quantity",
											"type": "Double",
											"physicalType": "String"
										},
										"sink": {
											"name": "Quantity",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Region",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Region",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationOrderId",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationOrderId",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "ReservationOrderName",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "ReservationOrderName",
											"type": "String",
											"physicalType": "UTF8"
										}
									},
									{
										"source": {
											"name": "Term",
											"type": "String",
											"physicalType": "String"
										},
										"sink": {
											"name": "Term",
											"type": "String",
											"physicalType": "UTF8"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "RIPurchasesSource",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "RIPurchaseSink",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction/HUB and RI"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/RIPurchasesSource')]",
				"[concat(variables('workspaceId'), '/datasets/RIPurchaseSink')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-wbs-owners')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Process WBS Owners",
						"type": "SynapseNotebook",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "wbs-owner-lookup",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": "s037costmgmt",
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"folder": {
					"name": "PipelinesInProduction/SAP"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/notebooks/wbs-owner-lookup')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/servicenow-applications-daily')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Query ServiceNow applications from DB",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "ID",
											"type": "String",
											"physicalType": "char"
										},
										"sink": {
											"name": "ID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ApplicationName",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ApplicationName",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "AppID",
											"type": "Int64",
											"physicalType": "bigint"
										},
										"sink": {
											"name": "AppID",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ServiceOffering.Name",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ServiceOffering.Name",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Updated",
											"type": "DateTime",
											"physicalType": "datetime"
										},
										"sink": {
											"name": "Updated",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Created",
											"type": "DateTime",
											"physicalType": "datetime"
										},
										"sink": {
											"name": "Created",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "LifeCycleState",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "LifeCycleState",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "EndOfLifeDate",
											"type": "DateTime",
											"physicalType": "datetime"
										},
										"sink": {
											"name": "EndOfLifeDate",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalStatus",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalStatus",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalWBS",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalWBS",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ProductOwnerNo",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ProductOwnerNo",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ProductOwnerShortName",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ProductOwnerShortName",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "UserRepresentative",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "UserRepresentative",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "BusinessProcessArea",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "BusinessProcessArea",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OmniaSubscriptions",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OmniaSubscriptions",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "IsOmniaSubscription",
											"type": "Boolean",
											"physicalType": "bit"
										},
										"sink": {
											"name": "IsOmniaSubscription",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalUnitManagerNo",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalUnitManagerNo",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalManagerShortName",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalManagerShortName",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Product",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "Product",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalUnit",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalUnit",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalUnitOrgUnit",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalUnitOrgUnit",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ServiceNowApplicationsDataset",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "NewServiceNowSinkDataset",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Run ServiceNow applications ETL",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Query ServiceNow applications from DB",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "servicenow-application-processing",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@variables('storageAccount')",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"sparkPool": {
								"referenceName": "[parameters('servicenow-applications-daily_pipelineSparkPoolNameRef')]",
								"type": "BigDataPoolReference"
							},
							"executorSize": "Large",
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"driverSize": "Large",
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"variables": {
					"storageAccount": {
						"type": "String",
						"defaultValue": "[parameters('servicenow-applications-daily_pipelineStorageAccountVariable')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/ServiceNow"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ServiceNowApplicationsDataset')]",
				"[concat(variables('workspaceId'), '/datasets/NewServiceNowSinkDataset')]",
				"[concat(variables('workspaceId'), '/notebooks/servicenow-application-processing')]",
				"[concat(variables('workspaceId'), '/bigDataPools/', parameters('servicenow-applications-daily_pipelineSparkPoolNameRef'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/servicenow-subscriptions-daily')]",
			"type": "Microsoft.Synapse/workspaces/pipelines",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"activities": [
					{
						"name": "Query ServiceNow subscriptions from DB",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"queryTimeout": "02:00:00",
								"partitionOption": "None"
							},
							"sink": {
								"type": "DelimitedTextSink",
								"storeSettings": {
									"type": "AzureBlobFSWriteSettings"
								},
								"formatSettings": {
									"type": "DelimitedTextWriteSettings",
									"quoteAllText": true,
									"fileExtension": ".txt"
								}
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "Name",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "Name",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "SubscriptionURL",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "SubscriptionURL",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "SubscriptionType",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "SubscriptionType",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalWBS",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalWBS",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "OperationalStatus",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "OperationalStatus",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "LifecycleStatus",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "LifecycleStatus",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Application",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "Application",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ProductOwnerEmployeeId",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ProductOwnerEmployeeId",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "ProductOwnerEmail",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "ProductOwnerEmail",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "TechnicalOwnerEmployeeId",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "TechnicalOwnerEmployeeId",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "TechnicalOwnerEmail",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "TechnicalOwnerEmail",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Created",
											"type": "DateTime",
											"physicalType": "datetime"
										},
										"sink": {
											"name": "Created",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "Updated",
											"type": "DateTime",
											"physicalType": "datetime"
										},
										"sink": {
											"name": "Updated",
											"type": "String",
											"physicalType": "String"
										}
									},
									{
										"source": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "nvarchar"
										},
										"sink": {
											"name": "SubscriptionId",
											"type": "String",
											"physicalType": "String"
										}
									}
								],
								"typeConversion": true,
								"typeConversionSettings": {
									"allowDataTruncation": true,
									"treatBooleanAsNumber": false
								}
							}
						},
						"inputs": [
							{
								"referenceName": "ServiceNowSubscriptionsDataset",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ServiceNowSubscriptionsDatasetSink",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					},
					{
						"name": "Run ServiceNow Subscription ETL",
						"type": "SynapseNotebook",
						"dependsOn": [
							{
								"activity": "Query ServiceNow subscriptions from DB",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "0.12:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"notebook": {
								"referenceName": "servicenow-subscription-processing",
								"type": "NotebookReference"
							},
							"parameters": {
								"storageAccount": {
									"value": {
										"value": "@pipeline().parameters.storageAccount",
										"type": "Expression"
									},
									"type": "string"
								}
							},
							"snapshot": true,
							"conf": {
								"spark.dynamicAllocation.enabled": null,
								"spark.dynamicAllocation.minExecutors": null,
								"spark.dynamicAllocation.maxExecutors": null
							},
							"numExecutors": null
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {}
				},
				"parameters": {
					"storageAccount": {
						"type": "string",
						"defaultValue": "[parameters('servicenow-subscriptions-daily_pipelineStorageAccountParameter')]"
					}
				},
				"folder": {
					"name": "PipelinesInProduction/ServiceNow"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/ServiceNowSubscriptionsDataset')]",
				"[concat(variables('workspaceId'), '/datasets/ServiceNowSubscriptionsDatasetSink')]",
				"[concat(variables('workspaceId'), '/notebooks/servicenow-subscription-processing')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Adhoc_CSV_Source')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Adhoc_CSV_Source_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "InvoiceSectionName",
						"type": "String"
					},
					{
						"name": "AccountName",
						"type": "String"
					},
					{
						"name": "AccountOwnerId",
						"type": "String"
					},
					{
						"name": "SubscriptionId",
						"type": "String"
					},
					{
						"name": "SubscriptionName",
						"type": "String"
					},
					{
						"name": "ResourceGroup",
						"type": "String"
					},
					{
						"name": "ResourceLocation",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "ProductName",
						"type": "String"
					},
					{
						"name": "MeterCategory",
						"type": "String"
					},
					{
						"name": "MeterSubCategory",
						"type": "String"
					},
					{
						"name": "MeterId",
						"type": "String"
					},
					{
						"name": "MeterName",
						"type": "String"
					},
					{
						"name": "MeterRegion",
						"type": "String"
					},
					{
						"name": "UnitOfMeasure",
						"type": "String"
					},
					{
						"name": "Quantity",
						"type": "String"
					},
					{
						"name": "EffectivePrice",
						"type": "String"
					},
					{
						"name": "CostInBillingCurrency",
						"type": "String"
					},
					{
						"name": "CostCenter",
						"type": "String"
					},
					{
						"name": "ConsumedService",
						"type": "String"
					},
					{
						"name": "ResourceId",
						"type": "String"
					},
					{
						"name": "Tags",
						"type": "String"
					},
					{
						"name": "OfferId",
						"type": "String"
					},
					{
						"name": "AdditionalInfo",
						"type": "String"
					},
					{
						"name": "ServiceInfo1",
						"type": "String"
					},
					{
						"name": "ServiceInfo2",
						"type": "String"
					},
					{
						"name": "ResourceName",
						"type": "String"
					},
					{
						"name": "ReservationId",
						"type": "String"
					},
					{
						"name": "ReservationName",
						"type": "String"
					},
					{
						"name": "UnitPrice",
						"type": "String"
					},
					{
						"name": "ProductOrderId",
						"type": "String"
					},
					{
						"name": "ProductOrderName",
						"type": "String"
					},
					{
						"name": "Term",
						"type": "String"
					},
					{
						"name": "PublisherType",
						"type": "String"
					},
					{
						"name": "PublisherName",
						"type": "String"
					},
					{
						"name": "ChargeType",
						"type": "String"
					},
					{
						"name": "Frequency",
						"type": "String"
					},
					{
						"name": "PricingModel",
						"type": "String"
					},
					{
						"name": "AvailabilityZone",
						"type": "String"
					},
					{
						"name": "BillingAccountId",
						"type": "String"
					},
					{
						"name": "BillingAccountName",
						"type": "String"
					},
					{
						"name": "BillingCurrencyCode",
						"type": "String"
					},
					{
						"name": "BillingPeriodStartDate",
						"type": "String"
					},
					{
						"name": "BillingPeriodEndDate",
						"type": "String"
					},
					{
						"name": "BillingProfileId",
						"type": "String"
					},
					{
						"name": "BillingProfileName",
						"type": "String"
					},
					{
						"name": "InvoiceSectionId",
						"type": "String"
					},
					{
						"name": "IsAzureCreditEligible",
						"type": "String"
					},
					{
						"name": "PartNumber",
						"type": "String"
					},
					{
						"name": "PayGPrice",
						"type": "String"
					},
					{
						"name": "PlanName",
						"type": "String"
					},
					{
						"name": "ServiceFamily",
						"type": "String"
					},
					{
						"name": "CostAllocationRuleName",
						"type": "String"
					},
					{
						"name": "benefitId",
						"type": "String"
					},
					{
						"name": "benefitName",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Adhoc_CSV_Source_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutofitCombometerSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AutofitCombometerSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "autofitcombometer.parquet",
						"folderPath": "ccm",
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AutofitCombometerSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutofitCombometerSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AutofitCombometerSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobStorageLocation",
						"fileName": "AutofitComboMeterData.csv",
						"container": "costmanagementconnector-data"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "InstanceSizeFlexibilityGroup",
						"type": "String"
					},
					{
						"name": "ResourceLocation",
						"type": "String"
					},
					{
						"name": "ArmSkuName",
						"type": "String"
					},
					{
						"name": "Ratio",
						"type": "String"
					},
					{
						"name": "ComboMeter",
						"type": "String"
					},
					{
						"name": "HardwareMeter",
						"type": "String"
					},
					{
						"name": "SoftwareMeter",
						"type": "String"
					},
					{
						"name": "CompositeKey",
						"type": "String"
					},
					{
						"name": "NormalizedSKU",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AutofitCombometerSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureAD_Users')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AzureAD_Users_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": "users?$expand=manager($levels=2;$select=employeeId,displayName,userPrincipalName,accountEnabled,department)&$select=employeeid,displayName,userPrincipalName,accountEnabled,department,officeLocation,country,city"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AzureAD_Users_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureAdvisorRecommendationSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AzureAdvisorRecommendationSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"subscriptionId": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": {
						"value": "@concat('subscriptions/',dataset().subscriptionId,'/providers/Microsoft.Advisor/recommendations?api-version=2017-04-19')",
						"type": "Expression"
					}
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AzureAdvisorRecommendationSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureAdvisorRecommendationsSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AzureAdvisorRecommendationsSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"subscriptionId": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat('advisor-recommendations-subscription-',dataset().subscriptionId,'.parquet')",
							"type": "Expression"
						},
						"folderPath": "recommendations",
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AzureAdvisorRecommendationsSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureSubscriptionResources')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('AzureSubscriptionResources_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"subscriptionId": {
						"type": "string"
					},
					"resourceType": {
						"type": "string",
						"defaultValue": "'Microsoft.Compute/virtualMachines'"
					}
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": {
						"value": "@concat('subscriptions/', dataset().subscriptionId,'/resources?api-version=2021-04-01&$filter=resourceType eq',dataset().resourceType)",
						"type": "Expression"
					}
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('AzureSubscriptionResources_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CSV_Source_File')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('CSV_Source_File_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "id",
						"type": "String"
					},
					{
						"name": "subscriptionGuid",
						"type": "String"
					},
					{
						"name": "subscriptionName",
						"type": "String"
					},
					{
						"name": "meterId",
						"type": "String"
					},
					{
						"name": "usageStartDate",
						"type": "String"
					},
					{
						"name": "usageEndDate",
						"type": "String"
					},
					{
						"name": "offerName",
						"type": "String"
					},
					{
						"name": "resourceGroup",
						"type": "String"
					},
					{
						"name": "instanceId",
						"type": "String"
					},
					{
						"name": "additionalInfo",
						"type": "String"
					},
					{
						"name": "tags",
						"type": "String"
					},
					{
						"name": "orderNumber",
						"type": "String"
					},
					{
						"name": "unitOfMeasure",
						"type": "String"
					},
					{
						"name": "costCenter",
						"type": "String"
					},
					{
						"name": "accountId",
						"type": "String"
					},
					{
						"name": "accountName",
						"type": "String"
					},
					{
						"name": "accountOwnerId",
						"type": "String"
					},
					{
						"name": "departmentId",
						"type": "String"
					},
					{
						"name": "departmentName",
						"type": "String"
					},
					{
						"name": "publisherName",
						"type": "String"
					},
					{
						"name": "planName",
						"type": "String"
					},
					{
						"name": "consumedQuantity",
						"type": "String"
					},
					{
						"name": "resourceRate",
						"type": "String"
					},
					{
						"name": "extendedCost",
						"type": "String"
					},
					{
						"name": "isRecurringCharge",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('CSV_Source_File_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CleanedCSVDestSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('CleanedCSVDestSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "monthly/2022/08",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('CleanedCSVDestSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Monthly_Parquet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Monthly_Parquet_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"Container": {
						"type": "string"
					},
					"toDate_fromDate": {
						"type": "string",
						"defaultValue": "Dummy"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@if(contains(dataset().Path,'Actual'),concat('ACMMonthlyActualCost_',dataset().toDate_fromDate,'.parquet'),concat('ACMMonthlyAmortizedCost_',dataset().toDate_fromDate,'.parquet'))",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().Path",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().Container",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "billingFrequency",
						"type": "UTF8"
					},
					{
						"name": "purchasingEnrollment",
						"type": "UTF8"
					},
					{
						"name": "armSkuName",
						"type": "UTF8"
					},
					{
						"name": "term",
						"type": "UTF8"
					},
					{
						"name": "region",
						"type": "UTF8"
					},
					{
						"name": "purchasingSubscriptionGuid",
						"type": "UTF8"
					},
					{
						"name": "purchasingSubscriptionName",
						"type": "UTF8"
					},
					{
						"name": "accountName",
						"type": "UTF8"
					},
					{
						"name": "accountOwnerEmail",
						"type": "UTF8"
					},
					{
						"name": "departmentName",
						"type": "UTF8"
					},
					{
						"name": "costCenter",
						"type": "UTF8"
					},
					{
						"name": "currentEnrollment",
						"type": "UTF8"
					},
					{
						"name": "eventDate",
						"type": "UTF8"
					},
					{
						"name": "reservationOrderId",
						"type": "UTF8"
					},
					{
						"name": "description",
						"type": "UTF8"
					},
					{
						"name": "eventType",
						"type": "UTF8"
					},
					{
						"name": "quantity",
						"type": "DOUBLE"
					},
					{
						"name": "amount",
						"type": "DOUBLE"
					},
					{
						"name": "currency",
						"type": "UTF8"
					},
					{
						"name": "reservationOrderName",
						"type": "UTF8"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Monthly_Parquet_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/NewServiceNowSinkDataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('NewServiceNowSinkDataset_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction/ServiceNowDataset"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "NewServiceNowDataset.csv",
						"folderPath": "applications",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('NewServiceNowSinkDataset_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New_API_Format_Parquet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('New_API_Format_Parquet_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"dateRange": {
						"type": "string"
					},
					"ReportType": {
						"type": "string",
						"defaultValue": "na"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat('ACMMonthly',dataset().ReportType,'_',dataset().dateRange,'.parquet')",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().Path",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('New_API_Format_Parquet_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Older_Files_For_Deletion_Binary')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Older_Files_For_Deletion_Binary_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"ReportType": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('exports/daily/ACMDaily',dataset().ReportType)",
							"type": "Expression"
						},
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Older_Files_For_Deletion_Binary_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Parquet_File')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Parquet_File_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"fileName": {
						"type": "string",
						"defaultValue": "file"
					},
					"path": {
						"type": "string",
						"defaultValue": "path"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().fileName,'.parquet')",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().path",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Parquet_File_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Parquet_Monthly')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Parquet_Monthly_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Year_yyyy": {
						"type": "string",
						"defaultValue": "TBC"
					},
					"Month_mm": {
						"type": "string",
						"defaultValue": "TBC"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": {
							"value": "@concat('/usage/monthly/',dataset().Year_yyyy,'/',dataset().Month_mm,'/')",
							"type": "Expression"
						}
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "AccountId",
						"type": "UTF8"
					},
					{
						"name": "AccountName",
						"type": "UTF8"
					},
					{
						"name": "AccountOwnerEmail",
						"type": "UTF8"
					},
					{
						"name": "AdditionalInfo",
						"type": "UTF8"
					},
					{
						"name": "ConsumedQuantity",
						"type": "DOUBLE"
					},
					{
						"name": "ConsumedService",
						"type": "UTF8"
					},
					{
						"name": "ConsumedServiceId",
						"type": "UTF8"
					},
					{
						"name": "Cost",
						"type": "DOUBLE"
					},
					{
						"name": "CostCenter",
						"type": "UTF8"
					},
					{
						"name": "Date",
						"type": "UTF8"
					},
					{
						"name": "DepartmentId",
						"type": "UTF8"
					},
					{
						"name": "DepartmentName",
						"type": "UTF8"
					},
					{
						"name": "InstanceId",
						"type": "UTF8"
					},
					{
						"name": "MeterCategory",
						"type": "UTF8"
					},
					{
						"name": "MeterId",
						"type": "UTF8"
					},
					{
						"name": "MeterName",
						"type": "UTF8"
					},
					{
						"name": "MeterRegion",
						"type": "UTF8"
					},
					{
						"name": "MeterSubCategory",
						"type": "UTF8"
					},
					{
						"name": "Product",
						"type": "UTF8"
					},
					{
						"name": "ProductId",
						"type": "UTF8"
					},
					{
						"name": "ResourceGroup",
						"type": "UTF8"
					},
					{
						"name": "ResourceLocation",
						"type": "UTF8"
					},
					{
						"name": "ResourceLocationId",
						"type": "UTF8"
					},
					{
						"name": "ResourceRate",
						"type": "DOUBLE"
					},
					{
						"name": "ServiceAdministratorId",
						"type": "UTF8"
					},
					{
						"name": "ServiceInfo1",
						"type": "UTF8"
					},
					{
						"name": "ServiceInfo2",
						"type": "UTF8"
					},
					{
						"name": "StoreServiceIdentifier",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionGuid",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionId",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionName",
						"type": "UTF8"
					},
					{
						"name": "Tags",
						"type": "UTF8"
					},
					{
						"name": "UnitOfMeasure",
						"type": "UTF8"
					},
					{
						"name": "PartNumber",
						"type": "UTF8"
					},
					{
						"name": "ResourceGuid",
						"type": "UTF8"
					},
					{
						"name": "OfferId",
						"type": "UTF8"
					},
					{
						"name": "ChargesBilledSeparately",
						"type": "UTF8"
					},
					{
						"name": "Location",
						"type": "UTF8"
					},
					{
						"name": "ServiceName",
						"type": "UTF8"
					},
					{
						"name": "ServiceTier",
						"type": "UTF8"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Parquet_Monthly_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Parquet_for_Deletion')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('Parquet_for_Deletion_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"Container": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "*.Parquet",
						"folderPath": {
							"value": "@dataset().Path",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().Container",
							"type": "Expression"
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Parquet_for_Deletion_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PricesheetExportSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('PricesheetExportSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"dateRange": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().dateRange, '.parquet')",
							"type": "Expression"
						},
						"folderPath": "pricesheet/portal-export/pricesheet-converted",
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('PricesheetExportSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PricesheetExportSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('PricesheetExportSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"dateRange": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "part_0_0001.csv",
						"folderPath": "pricesheet/portal-export/FinOps-Pricesheet-Monthly/20240101-20240131/a1a831cf-9def-48dd-a822-af3d8390eede",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "EnrollmentNumber",
						"type": "String"
					},
					{
						"name": "MeterID",
						"type": "String"
					},
					{
						"name": "MeterName",
						"type": "String"
					},
					{
						"name": "MeterType",
						"type": "String"
					},
					{
						"name": "MeterCategory",
						"type": "String"
					},
					{
						"name": "MeterSubCategory",
						"type": "String"
					},
					{
						"name": "ServiceFamily",
						"type": "String"
					},
					{
						"name": "Product",
						"type": "String"
					},
					{
						"name": "SkuID",
						"type": "String"
					},
					{
						"name": "ProductID",
						"type": "String"
					},
					{
						"name": "MeterRegion",
						"type": "String"
					},
					{
						"name": "UnitOfMeasure",
						"type": "String"
					},
					{
						"name": "PartNumber",
						"type": "String"
					},
					{
						"name": "EffectiveStartDate",
						"type": "String"
					},
					{
						"name": "EffectiveEndDate",
						"type": "String"
					},
					{
						"name": "UnitPrice",
						"type": "String"
					},
					{
						"name": "BasePrice",
						"type": "String"
					},
					{
						"name": "MarketPrice",
						"type": "String"
					},
					{
						"name": "CurrencyCode",
						"type": "String"
					},
					{
						"name": "IncludedQuantity",
						"type": "String"
					},
					{
						"name": "OfferID",
						"type": "String"
					},
					{
						"name": "Term",
						"type": "String"
					},
					{
						"name": "PriceType",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('PricesheetExportSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RIPurchaseSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('RIPurchaseSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "ri-purchases.parquet",
						"folderPath": "ri",
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('RIPurchaseSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RIPurchasesSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('RIPurchasesSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "part0.csv",
						"folderPath": "portal-export/FinOps-ReservationTransactions-Daily/20240201-20240229/db8b3a9e-1da2-4c77-ad16-30ef41ac4503",
						"fileSystem": "reservations"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('RIPurchasesSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ReservationFileTransform_dst')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ReservationFileTransform_dst_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Year": {
						"type": "string"
					},
					"Month": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "reservation-charges.parquet",
						"folderPath": {
							"value": "@concat(dataset().Year,'/',dataset().Month)",
							"type": "Expression"
						},
						"fileSystem": "reservations"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ReservationFileTransform_dst_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037CSVSourceDataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037CSVSourceDataset_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Year": {
						"type": "string"
					},
					"Month": {
						"type": "string"
					},
					"toDate": {
						"type": "string"
					},
					"scope": {
						"type": "string"
					},
					"fromDate": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037CSVSourceDataset_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037Parquet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037Parquet_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Year": {
						"type": "string"
					},
					"Month": {
						"type": "string"
					},
					"toDate": {
						"type": "string"
					},
					"fromDate": {
						"type": "string"
					},
					"Scope": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@if(equals(dataset().Scope,'monthly'),concat(dataset().fromDate,'_',dataset().toDate,'-cleaned.parquet'),concat(dataset().fromDate,'-cleaned.parquet'))",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@concat(if(equals(dataset().Scope,'monthly'),concat('monthly/',dataset().Year,'/',dataset().Month),'daily'))",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "AccountId",
						"type": "UTF8"
					},
					{
						"name": "AccountName",
						"type": "UTF8"
					},
					{
						"name": "AccountOwnerEmail",
						"type": "UTF8"
					},
					{
						"name": "AdditionalInfo",
						"type": "UTF8"
					},
					{
						"name": "ConsumedQuantity",
						"type": "DOUBLE"
					},
					{
						"name": "ConsumedService",
						"type": "UTF8"
					},
					{
						"name": "ConsumedServiceId",
						"type": "UTF8"
					},
					{
						"name": "Cost",
						"type": "DOUBLE"
					},
					{
						"name": "CostCenter",
						"type": "UTF8"
					},
					{
						"name": "Date",
						"type": "UTF8"
					},
					{
						"name": "DepartmentId",
						"type": "UTF8"
					},
					{
						"name": "DepartmentName",
						"type": "UTF8"
					},
					{
						"name": "InstanceId",
						"type": "UTF8"
					},
					{
						"name": "MeterCategory",
						"type": "UTF8"
					},
					{
						"name": "MeterId",
						"type": "UTF8"
					},
					{
						"name": "MeterName",
						"type": "UTF8"
					},
					{
						"name": "MeterRegion",
						"type": "UTF8"
					},
					{
						"name": "MeterSubCategory",
						"type": "UTF8"
					},
					{
						"name": "Product",
						"type": "UTF8"
					},
					{
						"name": "ProductId",
						"type": "UTF8"
					},
					{
						"name": "ResourceGroup",
						"type": "UTF8"
					},
					{
						"name": "ResourceLocation",
						"type": "UTF8"
					},
					{
						"name": "ResourceLocationId",
						"type": "UTF8"
					},
					{
						"name": "ResourceRate",
						"type": "DOUBLE"
					},
					{
						"name": "ServiceAdministratorId",
						"type": "UTF8"
					},
					{
						"name": "ServiceInfo1",
						"type": "UTF8"
					},
					{
						"name": "ServiceInfo2",
						"type": "UTF8"
					},
					{
						"name": "StoreServiceIdentifier",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionGuid",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionId",
						"type": "UTF8"
					},
					{
						"name": "SubscriptionName",
						"type": "UTF8"
					},
					{
						"name": "Tags",
						"type": "UTF8"
					},
					{
						"name": "UnitOfMeasure",
						"type": "UTF8"
					},
					{
						"name": "PartNumber",
						"type": "UTF8"
					},
					{
						"name": "ResourceGuid",
						"type": "UTF8"
					},
					{
						"name": "OfferId",
						"type": "UTF8"
					},
					{
						"name": "ChargesBilledSeparately",
						"type": "UTF8"
					},
					{
						"name": "Location",
						"type": "UTF8"
					},
					{
						"name": "ServiceName",
						"type": "UTF8"
					},
					{
						"name": "ServiceTier",
						"type": "UTF8"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037Parquet_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037_Cleaned_CSV_Dest')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037_Cleaned_CSV_Dest_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Year": {
						"type": "string"
					},
					"Month": {
						"type": "string"
					},
					"fromDate": {
						"type": "string"
					},
					"toDate": {
						"type": "string"
					},
					"Scope": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@if(equals(dataset().Scope,'monthly'),concat(dataset().fromDate,'_',dataset().toDate,'-cleaned.csv'),concat(dataset().fromDate,'-cleaned.csv'))",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@concat(if(equals(dataset().Scope,'monthly'),concat('monthly/',dataset().Year,'/',dataset().Month),'daily'))",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					},
					{
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037_Cleaned_CSV_Dest_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037_New_Format_Usage_Data')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037_New_Format_Usage_Data_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"dateRange": {
						"type": "string"
					},
					"ReportType": {
						"type": "string",
						"defaultValue": "na"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@if(contains(dataset().Path,'ActualCost'),concat('ACMMonthly',dataset().ReportType,'_',dataset().dateRange,'.csv'),if(contains(dataset().Path,'AmortizedCost'),concat('ACMMonthly',dataset().ReportType,'_',dataset().dateRange,'.csv'),concat('ACMMonthlyUsage_',dataset().dateRange,'.csv')))",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().Path",
							"type": "Expression"
						},
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037_New_Format_Usage_Data_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037_Usage_DataSet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037_Usage_DataSet_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"fromDate": {
						"type": "string"
					},
					"toDate": {
						"type": "string",
						"defaultValue": "TBC"
					},
					"Scope": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@if(equals(dataset().Scope,'monthly'),concat(dataset().fromDate,'_',dataset().toDate,'-raw.csv'),concat(dataset().fromDate,'-raw.csv'))",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@if(equals(dataset().Scope,'monthly'),concat('monthly/',substring(dataset().fromDate,0,4),'/',substring(dataset().fromDate,5,2)),'daily')",
							"type": "Expression"
						},
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037_Usage_DataSet_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037_reservation_data_parquet')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('S037_reservation_data_parquet_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "reservations_costreport.parquet",
						"folderPath": "2022",
						"fileSystem": "reservations"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('S037_reservation_data_parquet_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQLDeploymentSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('SQLDeploymentSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"today": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().today, '-AHUB-Deployment.csv')",
							"type": "Expression"
						},
						"fileSystem": "sql-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('SQLDeploymentSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQLDeploymentSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('SQLDeploymentSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "LATEST-AHUB-Deployment.csv",
						"fileSystem": "sql-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('SQLDeploymentSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQLDisableSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('SQLDisableSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"today": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().today, '-AHUB-Removal.csv')",
							"type": "Expression"
						},
						"fileSystem": "sql-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('SQLDisableSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQLDisableSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('SQLDisableSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "LATEST-AHUB-Removal.csv",
						"fileSystem": "sql-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('SQLDisableSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowAppJson')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowAppJson_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction/ServiceNowDataset"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "ServiceNowTest.json",
						"folderPath": "applications",
						"fileSystem": "usage"
					}
				},
				"schema": {}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowAppJson_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowApplicationData')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowApplicationData_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction/ServiceNowDataset"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "ServiceNowApplication.parquet",
						"folderPath": "applications",
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": [
					{
						"name": "SubscriptionName",
						"type": "UTF8"
					},
					{
						"name": "CostCenter",
						"type": "UTF8"
					},
					{
						"name": "ResourceGroup",
						"type": "UTF8"
					},
					{
						"name": "ResourceLocation",
						"type": "UTF8"
					},
					{
						"name": "ResourceName",
						"type": "UTF8"
					},
					{
						"name": "MeterName",
						"type": "UTF8"
					},
					{
						"name": "MeterCategory",
						"type": "UTF8"
					},
					{
						"name": "MeterSubCategory",
						"type": "UTF8"
					},
					{
						"name": "Total quantity",
						"type": "DOUBLE"
					},
					{
						"name": "Cost in Kroner",
						"type": "DOUBLE"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowApplicationData_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowApplicationsDataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowApplicationsDataset_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction/ServiceNowDataset"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [],
				"typeProperties": {
					"schema": "v_SN_FinOps",
					"table": "v_FinOpsPOC"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowApplicationsDataset_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowLinkedService_Application_View')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowLinkedService_Application_View_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction/ServiceNowDataset"
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": "table/cmdb_ci_spkg?sysparm_fields=\"u_number\",\"name\"&sysparm_limit=100000"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowLinkedService_Application_View_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowSubscriptionsDataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowSubscriptionsDataset_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "AzureSqlTable",
				"schema": [],
				"typeProperties": {
					"schema": "v_SN_FinOps",
					"table": "v_FinOpsSubscriptions"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowSubscriptionsDataset_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowSubscriptionsDatasetSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ServiceNowSubscriptionsDatasetSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "servicenow/latest.csv",
						"folderPath": "subscriptions",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ServiceNowSubscriptionsDatasetSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SubscriptionResourceLocations')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('SubscriptionResourceLocations_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"subscriptionId": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "locations.csv",
						"folderPath": {
							"value": "@concat('metrics/vm-utilization-by-subscription/', dataset().subscriptionId)",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('SubscriptionResourceLocations_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestADFBinaryFile')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('TestADFBinaryFile_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"toDate": {
						"type": "string"
					},
					"fromDate": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().fromDate,'-',dataset().toDate,'-raw.csv')",
							"type": "Expression"
						},
						"folderPath": "ADFTest",
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('TestADFBinaryFile_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestADFCleanedCSV')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('TestADFCleanedCSV_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "ADFTest",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('TestADFCleanedCSV_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestADFDataset')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('TestADFDataset_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"toDate": {
						"type": "string"
					},
					"fromDate": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().fromDate,'-',dataset().toDate,'-raw.csv')",
							"type": "Expression"
						},
						"folderPath": "ADFTest",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": false,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('TestADFDataset_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/TestRawCSVSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('TestRawCSVSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "2022-08-01_2022-08-31-raw.csv",
						"folderPath": "monthly/2022/08",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": false,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "AccountId",
						"type": "String"
					},
					{
						"name": "AccountName",
						"type": "String"
					},
					{
						"name": "AccountOwnerEmail",
						"type": "String"
					},
					{
						"name": "AdditionalInfo",
						"type": "String"
					},
					{
						"name": "ConsumedQuantity",
						"type": "String"
					},
					{
						"name": "ConsumedService",
						"type": "String"
					},
					{
						"name": "ConsumedServiceId",
						"type": "String"
					},
					{
						"name": "Cost",
						"type": "String"
					},
					{
						"name": "CostCenter",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "DepartmentId",
						"type": "String"
					},
					{
						"name": "DepartmentName",
						"type": "String"
					},
					{
						"name": "InstanceId",
						"type": "String"
					},
					{
						"name": "MeterCategory",
						"type": "String"
					},
					{
						"name": "MeterId",
						"type": "String"
					},
					{
						"name": "MeterName",
						"type": "String"
					},
					{
						"name": "MeterRegion",
						"type": "String"
					},
					{
						"name": "MeterSubCategory",
						"type": "String"
					},
					{
						"name": "Product",
						"type": "String"
					},
					{
						"name": "ProductId",
						"type": "String"
					},
					{
						"name": "ResourceGroup",
						"type": "String"
					},
					{
						"name": "ResourceLocation",
						"type": "String"
					},
					{
						"name": "ResourceLocationId",
						"type": "String"
					},
					{
						"name": "ResourceRate",
						"type": "String"
					},
					{
						"name": "ServiceAdministratorId",
						"type": "String"
					},
					{
						"name": "ServiceInfo1",
						"type": "String"
					},
					{
						"name": "ServiceInfo2",
						"type": "String"
					},
					{
						"name": "StoreServiceIdentifier",
						"type": "String"
					},
					{
						"name": "SubscriptionGuid",
						"type": "String"
					},
					{
						"name": "SubscriptionId",
						"type": "String"
					},
					{
						"name": "SubscriptionName",
						"type": "String"
					},
					{
						"name": "Tags",
						"type": "String"
					},
					{
						"name": "UnitOfMeasure",
						"type": "String"
					},
					{
						"name": "PartNumber",
						"type": "String"
					},
					{
						"name": "ResourceGuid",
						"type": "String"
					},
					{
						"name": "OfferId",
						"type": "String"
					},
					{
						"name": "ChargesBilledSeparately",
						"type": "String"
					},
					{
						"name": "Location",
						"type": "String"
					},
					{
						"name": "ServiceName",
						"type": "String"
					},
					{
						"name": "ServiceTier",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('TestRawCSVSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VMDeploymentSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('VMDeploymentSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"today": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().today, '-AHUB-Deployment.csv')",
							"type": "Expression"
						},
						"fileSystem": "win-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('VMDeploymentSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VMDeploymentsSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('VMDeploymentsSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "LATEST-AHUB-Deployment.csv",
						"fileSystem": "win-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('VMDeploymentsSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VMDisableSink')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('VMDisableSink_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"today": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat(dataset().today, '-AHUB-Removal.csv')",
							"type": "Expression"
						},
						"fileSystem": "win-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('VMDisableSink_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VMDisableSource')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('VMDisableSource_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": "LATEST-AHUB-Removal.csv",
						"fileSystem": "win-hub-logs-v2"
					},
					"columnDelimiter": ",",
					"escapeChar": "\\",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('VMDisableSource_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_CSV_File')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ds_CSV_File_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "DelimitedText",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": "exports/daily/",
						"fileSystem": "usage"
					},
					"columnDelimiter": ",",
					"escapeChar": "\"",
					"firstRowAsHeader": true,
					"quoteChar": "\""
				},
				"schema": [
					{
						"name": "InvoiceSectionName",
						"type": "String"
					},
					{
						"name": "AccountName",
						"type": "String"
					},
					{
						"name": "AccountOwnerId",
						"type": "String"
					},
					{
						"name": "SubscriptionId",
						"type": "String"
					},
					{
						"name": "SubscriptionName",
						"type": "String"
					},
					{
						"name": "ResourceGroup",
						"type": "String"
					},
					{
						"name": "ResourceLocation",
						"type": "String"
					},
					{
						"name": "Date",
						"type": "String"
					},
					{
						"name": "ProductName",
						"type": "String"
					},
					{
						"name": "MeterCategory",
						"type": "String"
					},
					{
						"name": "MeterSubCategory",
						"type": "String"
					},
					{
						"name": "MeterId",
						"type": "String"
					},
					{
						"name": "MeterName",
						"type": "String"
					},
					{
						"name": "MeterRegion",
						"type": "String"
					},
					{
						"name": "UnitOfMeasure",
						"type": "String"
					},
					{
						"name": "Quantity",
						"type": "String"
					},
					{
						"name": "EffectivePrice",
						"type": "String"
					},
					{
						"name": "CostInBillingCurrency",
						"type": "String"
					},
					{
						"name": "CostCenter",
						"type": "String"
					},
					{
						"name": "ConsumedService",
						"type": "String"
					},
					{
						"name": "ResourceId",
						"type": "String"
					},
					{
						"name": "Tags",
						"type": "String"
					},
					{
						"name": "OfferId",
						"type": "String"
					},
					{
						"name": "AdditionalInfo",
						"type": "String"
					},
					{
						"name": "ServiceInfo1",
						"type": "String"
					},
					{
						"name": "ServiceInfo2",
						"type": "String"
					},
					{
						"name": "ResourceName",
						"type": "String"
					},
					{
						"name": "ReservationId",
						"type": "String"
					},
					{
						"name": "ReservationName",
						"type": "String"
					},
					{
						"name": "UnitPrice",
						"type": "String"
					},
					{
						"name": "ProductOrderId",
						"type": "String"
					},
					{
						"name": "ProductOrderName",
						"type": "String"
					},
					{
						"name": "Term",
						"type": "String"
					},
					{
						"name": "PublisherType",
						"type": "String"
					},
					{
						"name": "PublisherName",
						"type": "String"
					},
					{
						"name": "ChargeType",
						"type": "String"
					},
					{
						"name": "Frequency",
						"type": "String"
					},
					{
						"name": "PricingModel",
						"type": "String"
					},
					{
						"name": "AvailabilityZone",
						"type": "String"
					},
					{
						"name": "BillingAccountId",
						"type": "String"
					},
					{
						"name": "BillingAccountName",
						"type": "String"
					},
					{
						"name": "BillingCurrencyCode",
						"type": "String"
					},
					{
						"name": "BillingPeriodStartDate",
						"type": "String"
					},
					{
						"name": "BillingPeriodEndDate",
						"type": "String"
					},
					{
						"name": "BillingProfileId",
						"type": "String"
					},
					{
						"name": "BillingProfileName",
						"type": "String"
					},
					{
						"name": "InvoiceSectionId",
						"type": "String"
					},
					{
						"name": "IsAzureCreditEligible",
						"type": "String"
					},
					{
						"name": "PartNumber",
						"type": "String"
					},
					{
						"name": "PayGPrice",
						"type": "String"
					},
					{
						"name": "PlanName",
						"type": "String"
					},
					{
						"name": "ServiceFamily",
						"type": "String"
					},
					{
						"name": "CostAllocationRuleName",
						"type": "String"
					},
					{
						"name": "benefitId",
						"type": "String"
					},
					{
						"name": "benefitName",
						"type": "String"
					}
				]
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ds_CSV_File_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Daily_Parquet_File')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ds_Daily_Parquet_File_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"reportType": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Parquet",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@concat('ACMDaily',dataset().reportType,'.parquet')",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@concat(dataset().Path)",
							"type": "Expression"
						},
						"fileSystem": "usage"
					},
					"compressionCodec": "snappy"
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ds_Daily_Parquet_File_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_Test_delete_file')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ds_Test_delete_file_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"Path": {
						"type": "string"
					},
					"ReportType": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('exports/daily/ACMDaily',dataset().ReportType,'/',dataset().Path)",
							"type": "Expression"
						},
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ds_Test_delete_file_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_json_file_blank_destination')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ds_json_file_blank_destination_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"file_system": {
						"type": "string"
					},
					"directory": {
						"type": "string"
					},
					"filename": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Json",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"fileName": {
							"value": "@dataset().filename",
							"type": "Expression"
						},
						"folderPath": {
							"value": "@dataset().directory",
							"type": "Expression"
						},
						"fileSystem": {
							"value": "@dataset().file_system",
							"type": "Expression"
						}
					}
				},
				"schema": {
					"type": "object",
					"properties": {
						"kind": {
							"type": "string"
						},
						"id": {
							"type": "string"
						},
						"name": {
							"type": "string"
						},
						"type": {
							"type": "string"
						},
						"location": {
							"type": "string"
						},
						"sku": {
							"type": "string"
						},
						"properties": {
							"type": "object",
							"properties": {
								"meterId": {
									"type": "string"
								},
								"term": {
									"type": "string"
								},
								"costWithNoReservedInstances": {
									"type": "number"
								},
								"recommendedQuantity": {
									"type": "integer"
								},
								"totalCostWithReservedInstances": {
									"type": "number"
								},
								"netSavings": {
									"type": "number"
								},
								"firstUsageDate": {
									"type": "string"
								},
								"scope": {
									"type": "string"
								},
								"lookBackPeriod": {
									"type": "string"
								},
								"resourceType": {
									"type": "null"
								},
								"instanceFlexibilityRatio": {
									"type": "number"
								},
								"instanceFlexibilityGroup": {
									"type": "string"
								},
								"normalizedSize": {
									"type": "string"
								},
								"recommendedQuantityNormalized": {
									"type": "number"
								}
							}
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ds_json_file_blank_destination_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ds_test_delete_files')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ds_test_delete_files_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference"
				},
				"parameters": {
					"ReportType": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "AzureBlobFSLocation",
						"folderPath": {
							"value": "@concat('exports/daily/ACMDaily',dataset().ReportType)",
							"type": "Expression"
						},
						"fileSystem": "usage"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ds_test_delete_files_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ms_billing_output_file')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('ms_billing_output_file_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference",
					"parameters": {
						"blobPath": {
							"value": "@dataset().blobPath",
							"type": "Expression"
						}
					}
				},
				"parameters": {
					"blobPath": {
						"type": "String",
						"defaultValue": "TBC"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "Binary",
				"typeProperties": {
					"location": {
						"type": "HttpServerLocation"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('ms_billing_output_file_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/retrieve_cost_report_ms_billing_source')]",
			"type": "Microsoft.Synapse/workspaces/datasets",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"linkedServiceName": {
					"referenceName": "[parameters('retrieve_cost_report_ms_billing_source_dataSetLinkedServiceName')]",
					"type": "LinkedServiceReference",
					"parameters": {
						"baseUrl": "https://consumption.azure.com"
					}
				},
				"parameters": {
					"fromDate": {
						"type": "string"
					},
					"toDate": {
						"type": "string"
					}
				},
				"folder": {
					"name": "DatasetInProduction"
				},
				"annotations": [],
				"type": "RestResource",
				"typeProperties": {
					"relativeUrl": {
						"value": "@concat('v4/enrollments/57950773/reservationcharges?startDate=',dataset().fromDate,'&endDate=',dataset().toDate)",
						"type": "Expression"
					}
				},
				"schema": []
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('retrieve_cost_report_ms_billing_source_dataSetLinkedServiceName'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ACM_Toolkit_kv')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureKeyVault",
				"typeProperties": {
					"baseUrl": "https://ACM-Toolkit-kv.vault.azure.net/"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureDataLakeStorage1')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('AzureDataLakeStorage1_linkedServiceUrl')]",
					"accountKey": {
						"type": "SecureString",
						"value": "[parameters('AzureDataLakeStorage1_accountKey')]"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureManagementAPI')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('AzureManagementAPI_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "AadServicePrincipal",
					"servicePrincipalId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					},
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"aadResourceId": "https://management.azure.com",
					"azureCloudType": "AzurePublic"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AzureManagementAPIMetricsReader')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Azure Management API Client using the Azure-Cost-Management-Metrics-Reader service principal for authentication",
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('AzureManagementAPIMetricsReader_linkedServiceUrl')]",
					"enableServerCertificateValidation": false,
					"authenticationType": "AadServicePrincipal",
					"servicePrincipalId": "c282b841-bb78-4904-aba9-4aebf02ccb71",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "Azure-Cost-Management-Metrics-Reader-secret"
					},
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"aadResourceId": "https://management.azure.com",
					"azureCloudType": "AzurePublic"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CCM Storage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobStorage",
				"typeProperties": {
					"containerUri": "https://ccmstorageprod.blob.core.windows.net/costmanagementconnector-data",
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/FinOpsHubsTest')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('FinOpsHubsTest_linkedServiceUrl')]",
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"servicePrincipalId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"servicePrincipalCredentialType": "ServicePrincipalKey",
					"servicePrincipalCredential": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB Storage Account')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('HUB Storage Account_linkedServiceUrl')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MicrosoftGraphRESTAPI')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('MicrosoftGraphRESTAPI_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "OAuth2ClientCredential",
					"clientId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"clientSecret": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					},
					"tokenEndpoint": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/v2.0/token",
					"scope": "https://graph.microsoft.com/.default"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/NewServiceNow')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureSqlDatabase",
				"typeProperties": {
					"connectionString": {
						"type": "SecureString",
						"value": "[parameters('NewServiceNow_connectionString')]"
					},
					"servicePrincipalId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					},
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PowerBIWorkspace1')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "PowerBIWorkspace",
				"typeProperties": {
					"workspaceID": "c775d006-ff61-4ed8-b67d-c66d63eb55f2",
					"tenantID": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Pricesheet API')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "HttpServer",
				"typeProperties": {
					"url": "[parameters('Pricesheet API_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous",
					"authHeaders": {
						"Authorization": {
							"type": "AzureKeyVaultSecret",
							"store": {
								"referenceName": "ACM_Toolkit_kv",
								"type": "LinkedServiceReference"
							},
							"secretName": "EA-API-PRI-KEY"
						}
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S926FinOpsHubTest')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('S926FinOpsHubTest_linkedServiceUrl')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ServiceNowLinkedService')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "This linked service is not in use currently but will be remained for backup.",
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('ServiceNowLinkedService_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "OAuth2ClientCredential",
					"clientId": "5eb7f785-f27d-44d9-a53d-b19478160c4a",
					"clientSecret": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "SnowProdUserPwd"
					},
					"tokenEndpoint": "https://login.microsoftonline.com/3aa4a235-b6e2-48d5-9195-7fcf05b459b0/oauth2/v2.0/token",
					"scope": "openid 83b84d80-e0a7-409e-a3d5-70c2512f203d/.default",
					"authHeaders": {
						"Ocp-Apim-subscription-Key": {
							"type": "SecureString",
							"value": "**********"
						},
						"Content-Type": {
							"type": "SecureString",
							"value": "**********"
						}
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ms_billing_cost_report_download')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"blobPath": {
						"type": "string"
					}
				},
				"annotations": [],
				"type": "HttpServer",
				"typeProperties": {
					"url": "[parameters('ms_billing_cost_report_download_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ms_consumption_api_http')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"baseUrl": {
						"type": "String",
						"defaultValue": "https://consumption.azure.com"
					}
				},
				"annotations": [],
				"type": "HttpServer",
				"typeProperties": {
					"url": "[parameters('ms_consumption_api_http_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous",
					"authHeaders": {
						"Authorization": {
							"type": "AzureKeyVaultSecret",
							"store": {
								"referenceName": "ACM_Toolkit_kv",
								"type": "LinkedServiceReference"
							},
							"secretName": "Bearer-EA-API-PRI-KEY"
						}
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ms_consumption_api_rest')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"baseUrl": {
						"type": "string",
						"defaultValue": "https://consumption.azure.com"
					}
				},
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('ms_consumption_api_rest_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "Anonymous",
					"authHeaders": {
						"Authorization": {
							"type": "AzureKeyVaultSecret",
							"store": {
								"referenceName": "ACM_Toolkit_kv",
								"type": "LinkedServiceReference"
							},
							"secretName": "Bearer-EA-API-PRI-KEY"
						}
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ms_management_api_rest')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "RestService",
				"typeProperties": {
					"url": "[parameters('ms_management_api_rest_linkedServiceUrl')]",
					"enableServerCertificateValidation": true,
					"authenticationType": "AadServicePrincipal",
					"servicePrincipalId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					},
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"aadResourceId": "https://management.azure.com"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]",
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/omniaacdcdlsprod')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('omniaacdcdlsprod_linkedServiceUrl')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/s037-cost-management-WorkspaceDefaultSqlServer')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"parameters": {
					"DBName": {
						"type": "String"
					}
				},
				"annotations": [],
				"type": "AzureSqlDW",
				"typeProperties": {
					"connectionString": {
						"type": "SecureString",
						"value": "[parameters('s037-cost-management-WorkspaceDefaultSqlServer_connectionString')]"
					}
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/s037-cost-management-WorkspaceDefaultStorage')]",
			"type": "Microsoft.Synapse/workspaces/linkedServices",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"type": "AzureBlobFS",
				"typeProperties": {
					"url": "[parameters('s037-cost-management-WorkspaceDefaultStorage_linkedServiceUrl')]"
				},
				"connectVia": {
					"referenceName": "AutoResolveIntegrationRuntime",
					"type": "IntegrationRuntimeReference"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/integrationRuntimes/AutoResolveIntegrationRuntime')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/5th of every month at 5am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Azure AD Users_v1",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Month",
						"interval": 1,
						"startTime": "2022-12-05T00:00:00Z",
						"timeZone": "UTC",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								4
							],
							"monthDays": [
								5
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Azure AD Users_v1')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily at 12am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Azure Advisor Recommendations",
							"type": "PipelineReference"
						},
						"parameters": {}
					},
					{
						"pipelineReference": {
							"referenceName": "process-wbs-owners",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2023-09-26T07:21:00",
						"timeZone": "W. Europe Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								0
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Azure Advisor Recommendations')]",
				"[concat(variables('workspaceId'), '/pipelines/process-wbs-owners')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily at 1am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "compute-hub-deployments",
							"type": "PipelineReference"
						},
						"parameters": {
							"storageAccount": "s037costmgmt"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-03-15T13:12:00",
						"timeZone": "W. Europe Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								1
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/compute-hub-deployments')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily at 2am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "servicenow-applications-daily",
							"type": "PipelineReference"
						},
						"parameters": {}
					},
					{
						"pipelineReference": {
							"referenceName": "servicenow-subscriptions-daily",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2023-05-30T02:00:00",
						"timeZone": "Romance Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								2
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/servicenow-applications-daily')]",
				"[concat(variables('workspaceId'), '/pipelines/servicenow-subscriptions-daily')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily at 4am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "compute-hub-and-ri-savings",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2024-02-01T04:00:00",
						"timeZone": "W. Europe Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								4
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/compute-hub-and-ri-savings')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily at 5am')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Daily VM Utilization",
							"type": "PipelineReference"
						},
						"parameters": {
							"storageAccount": "s037costmgmt"
						}
					}
				],
				"type": "ScheduleTrigger",
				"typeProperties": {
					"recurrence": {
						"frequency": "Day",
						"interval": 1,
						"startTime": "2023-10-04T05:00:00",
						"timeZone": "W. Europe Standard Time",
						"schedule": {
							"minutes": [
								0
							],
							"hours": [
								5
							]
						}
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Daily VM Utilization')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/daily-actual-cost-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Extend Daily Actual Cost",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/usage/blobs/exports/daily/ACMDailyActualCost",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Daily Actual Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/daily-amortized-cost-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Extend Daily Amortized Cost",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/usage/blobs/exports/daily/ACMDailyAmortizedCost",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Daily Amortized Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/monthly-actual-cost-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Extend Monthly Actual Cost",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/usage/blobs/exports/monthly/ACMMonthlyActualCost",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Monthly Actual Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/monthly-amortized-cost-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "Extend Monthly Amortized Cost",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/usage/blobs/exports/monthly/ACMMonthlyAmortizedCost",
					"blobPathEndsWith": ".csv",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/Extend Monthly Amortized Cost')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/pricesheet-updates-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "test",
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "persist-latest",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/usage/blobs/pricesheet/portal-export/FinOps-Pricesheet-Monthly",
					"blobPathEndsWith": "manifest.json",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/persist-latest')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ri-purchases-update-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "process-ri-purchases",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/reservations/blobs/portal-export/FinOps-ReservationTransactions-Daily",
					"blobPathEndsWith": "manifest.json",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/process-ri-purchases')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ri-recommendation-update-trigger')]",
			"type": "Microsoft.Synapse/workspaces/triggers",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Run trigger when the RI recommendation dataset is updated, i.e when the dataset is exported into the storage account from Azure.",
				"annotations": [],
				"runtimeState": "Started",
				"pipelines": [
					{
						"pipelineReference": {
							"referenceName": "build-ri-recommendations",
							"type": "PipelineReference"
						},
						"parameters": {}
					}
				],
				"type": "BlobEventsTrigger",
				"typeProperties": {
					"blobPathBeginsWith": "/reservations/blobs/portal-export/FinOps-ReservationRecommendations-VMs-Daily",
					"blobPathEndsWith": "manifest.json",
					"ignoreEmptyBlobs": true,
					"scope": "/subscriptions/13d66f54-0a19-4912-b4f3-54d15897368d/resourceGroups/Synapse/providers/Microsoft.Storage/storageAccounts/s037costmgmt",
					"events": [
						"Microsoft.Storage.BlobCreated"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/pipelines/build-ri-recommendations')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AutoResolveIntegrationRuntime')]",
			"type": "Microsoft.Synapse/workspaces/integrationRuntimes",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "Managed",
				"typeProperties": {
					"computeProperties": {
						"location": "AutoResolve",
						"dataFlowProperties": {
							"computeType": "General",
							"coreCount": 8,
							"timeToLive": 0
						}
					}
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Dataflow1')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TestRawCSVSource",
								"type": "DatasetReference"
							},
							"name": "RawCSVSource"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "CleanedCSVDestSink",
								"type": "DatasetReference"
							},
							"name": "CleanedCSVSink"
						}
					],
					"transformations": [],
					"scriptLines": [
						"parameters{",
						"     Year as string,",
						"     Month as string",
						"}",
						"source(output(",
						"          AccountId as string,",
						"          AccountName as string,",
						"          AccountOwnerEmail as string,",
						"          AdditionalInfo as string,",
						"          ConsumedQuantity as string,",
						"          ConsumedService as string,",
						"          ConsumedServiceId as string,",
						"          Cost as string,",
						"          CostCenter as string,",
						"          Date as string,",
						"          DepartmentId as string,",
						"          DepartmentName as string,",
						"          InstanceId as string,",
						"          MeterCategory as string,",
						"          MeterId as string,",
						"          MeterName as string,",
						"          MeterRegion as string,",
						"          MeterSubCategory as string,",
						"          Product as string,",
						"          ProductId as string,",
						"          ResourceGroup as string,",
						"          ResourceLocation as string,",
						"          ResourceLocationId as string,",
						"          ResourceRate as string,",
						"          ServiceAdministratorId as string,",
						"          ServiceInfo1 as string,",
						"          ServiceInfo2 as string,",
						"          StoreServiceIdentifier as string,",
						"          SubscriptionGuid as string,",
						"          SubscriptionId as string,",
						"          SubscriptionName as string,",
						"          Tags as string,",
						"          UnitOfMeasure as string,",
						"          PartNumber as string,",
						"          ResourceGuid as string,",
						"          OfferId as string,",
						"          ChargesBilledSeparately as string,",
						"          Location as string,",
						"          ServiceName as string,",
						"          ServiceTier as string",
						"     ),",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     skipLines: 2,",
						"     partitionBy('hash', 1)) ~> RawCSVSource",
						"RawCSVSource sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:[(concat($Year,'-',$Month,'-cleaned.csv'))],",
						"     umask: 0022,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> CleanedCSVSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/TestRawCSVSource')]",
				"[concat(variables('workspaceId'), '/datasets/CleanedCSVDestSink')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Dataflow2')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "DataFlowNotInUse"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TestADFDataset",
								"type": "DatasetReference"
							},
							"name": "SourceRawCSV"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TestADFCleanedCSV",
								"type": "DatasetReference"
							},
							"name": "CleanedCSVSink"
						}
					],
					"transformations": [],
					"scriptLines": [
						"parameters{",
						"     toDate as string,",
						"     fromDate as string",
						"}",
						"source(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     limit: 100,",
						"     ignoreNoFilesFound: false,",
						"     skipLines: 2,",
						"     dateFormats: ['yyyy-MM-dd'],",
						"     preferredFractionalType: 'double') ~> SourceRawCSV",
						"SourceRawCSV sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     partitionFileNames:[(concat($fromDate,'-',$toDate,'-cleaned.csv'))],",
						"     umask: 0666,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> CleanedCSVSink"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/datasets/TestADFDataset')]",
				"[concat(variables('workspaceId'), '/datasets/TestADFCleanedCSV')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Remove First Two Lines')]",
			"type": "Microsoft.Synapse/workspaces/dataflows",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "DataFlowNotInUse"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"linkedService": {
								"referenceName": "[parameters('Remove First Two Lines_sourceDataflowLinkedServiceNameRef')]",
								"type": "LinkedServiceReference"
							},
							"name": "S037RawCSV"
						}
					],
					"sinks": [
						{
							"linkedService": {
								"referenceName": "[parameters('Remove First Two Lines_sinkDataflowLinkedServiceNameRef')]",
								"type": "LinkedServiceReference"
							},
							"name": "S037CleanedCSV"
						}
					],
					"transformations": [],
					"scriptLines": [
						"parameters{",
						"     Year as string,",
						"     Month as string",
						"}",
						"source(useSchema: false,",
						"     allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     ignoreNoFilesFound: false,",
						"     format: 'delimited',",
						"     fileSystem: 'usage',",
						"     folderPath: (monthly/2022/08),",
						"     fileName: (concat('2022-08-01','_2022-08-31-raw.csv')),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: false,",
						"     skipLines: 2,",
						"     partitionBy('hash', 1)) ~> S037RawCSV",
						"S037RawCSV sink(allowSchemaDrift: true,",
						"     validateSchema: false,",
						"     format: 'delimited',",
						"     fileSystem: 'usage',",
						"     folderPath: (concat('monthly/',$Year,'/',$Month,'/')),",
						"     columnDelimiter: ',',",
						"     escapeChar: '\\\\',",
						"     quoteChar: '\\\"',",
						"     columnNamesAsHeader: true,",
						"     partitionFileNames:[(concat($Year, '-',$Month,'-cleaned.csv'))],",
						"     umask: 0666,",
						"     preCommands: [],",
						"     postCommands: [],",
						"     skipDuplicateMapInputs: true,",
						"     skipDuplicateMapOutputs: true,",
						"     partitionBy('hash', 1)) ~> S037CleanedCSV"
					]
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/', parameters('Remove First Two Lines_sourceDataflowLinkedServiceNameRef'))]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/FinOps-metrics-reader-credentials')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ServicePrincipal",
				"typeProperties": {
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"servicePrincipalId": "c282b841-bb78-4904-aba9-4aebf02ccb71",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "Azure-Cost-Management-Metrics-Reader-secret"
					},
					"azureCloudType": "AzurePublic"
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/FinopsSpCredentials')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ServicePrincipal",
				"typeProperties": {
					"tenant": "3aa4a235-b6e2-48d5-9195-7fcf05b459b0",
					"servicePrincipalId": "4c1cded2-f7a7-4c00-8d65-0a3287cbd682",
					"servicePrincipalKey": {
						"type": "AzureKeyVaultSecret",
						"store": {
							"referenceName": "ACM_Toolkit_kv",
							"type": "LinkedServiceReference"
						},
						"secretName": "sp-password"
					}
				}
			},
			"dependsOn": [
				"[concat(variables('workspaceId'), '/linkedServices/ACM_Toolkit_kv')]"
			]
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WorkspaceSystemIdentity')]",
			"type": "Microsoft.Synapse/workspaces/credentials",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"type": "ManagedIdentity",
				"typeProperties": {}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2020 Cost greater than 1000')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Location"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), Location\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2020/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY [Location]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2021 ACD Increase')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/ACD Challenge"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --*\n    format(sum(CostInBillingCurrency), 'N', 'en-us') as TotalCost\n    ,format((sum(CostInBillingCurrency) - (sum(CostInBillingCurrency) / 1.09)), 'N', 'en-us') as [2023 ACD Increase]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/*/ACMMonthlyA*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    --benefitName is not NULL\n    --where ChargeType = 'Purchase'\n    --and PricingModel = 'Reservation'\n    --((ChargeType <> 'Purchase' and PricingModel <> 'Reservation') and PricingModel <> 'Spot') and\n    NOT(ChargeType = 'Purchase' and PricingModel = 'Reservation') and PricingModel <> 'Spot' and\n    [Date] >= '2021-03-01'\n    and [Date] < '2023-04-01'\n\n    --2021-03-01: 9%\n    --2023-04-01: 11%\n    --2024-02-01: 12%\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2021 Cost greater than 1000')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Location"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), Location\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nwhere (Cost > 1000.00)\nGROUP BY [Location]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 ACD Increase')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/ACD Challenge"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --*\n    format(sum(CostInBillingCurrency), 'N', 'en-us') as TotalCost\n    ,format((sum(CostInBillingCurrency) - (sum(CostInBillingCurrency) / (1.11 * 1.09))), 'N', 'en-us') as [2023 ACD Increase]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/*/ACMMonthlyA*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    --benefitName is not NULL\n    NOT(ChargeType = 'Purchase' and PricingModel = 'Reservation') and PricingModel <> 'Spot' and\n    --((ChargeType <> 'Purchase' and PricingModel <> 'Reservation') and PricingModel <> 'Spot') and\n\n    [Date] >= '2023-04-01'\n    and [Date] < '2024-02-01'\n\n    --2021-03-01: 9%\n    --2023-04-01: 11%\n    --2024-02-01: 12%\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Actual Cost by ConsumedService')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ConsumedService\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ConsumedService --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Actual Cost by Resource Location')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ResourceLocation\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ResourceLocation --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Actual cost by ActiveWBS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ActiveWBS\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType\n    ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\n    --,format(CostInBillingCurrency, 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --and ActiveWBS is null or ActiveWBS = ''\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Actual cost by CostAllocationType')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by CostAllocationType\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    CostAllocationType\n    ,ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by CostAllocationType, ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Amortized Cost by ConsumedService')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ConsumedService\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ConsumedService --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Amortized Cost by Resource Location')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ResourceLocation\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ResourceLocation --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Amortized cost by ActiveWBS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by ActiveWBS\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType\n    ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 BM Amortized cost by CostAllocationType')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by CostAllocationType\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    CostAllocationType\n    ,ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by CostAllocationType, ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 Benchmark Actual Cost by ActiveWBS and MeterCategory')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by MeterCategory\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, MeterCategory --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2023 Benchmark Amortized Cost by ActiveWBS and MeterCategory')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2023"
				},
				"content": {
					"query": "--\n--   Cost by MeterCategory\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/Extended_v3_ACMMonthly*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, MeterCategory --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2024-03-25 Cost Query Sub-RG')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "ACDC"
				},
				"content": {
					"query": "\nSELECT\n    --Top 100\n    upper(SubscriptionName) as SubscriptionName\n    ,upper(ResourceGroup) as ResourceGroup\n    --,CostInBillingCurrency as Cost\n    --,*\n    ,ActiveWBS\n    ,CostAllocationType\n    ,sum(CostInBillingCurrency) as Cost\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/20240201-20240229/Extended_v3_ACMMonthlyAmortizedCost_20240201-20240229.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    --upper(ActiveWBS) <> 'C.TDI.IT.00010' and\n    --upper(ActiveWBS) = 'E.RDI.10512' and\n    upper(SubscriptionName) like 'S913-AURORA-NON-PRODUCTION'\n    and lower(ResourceGroup) = 'mc_dev-aurora-ngrm-00_dev-aurora-ngrm-00_northeurope'\n    group by  upper(SubscriptionName), upper(ResourceGroup), ActiveWBS, CostAllocationType\n\n   ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2024-03-25 Cost Query WBS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "ACDC"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/costreports/monthly/2024/02/omnia_acdc_cost_details_with_sap_response.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\n    --where WBS = 'C.TDI.IT.00010'\n    where WBS = 'E.RDI.10512'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/2024-03-25 Cost Query excl WBS Tag')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "ACDC"
				},
				"content": {
					"query": "\nSELECT\n    --upper(SubscriptionName) as SubscriptionName\n    --,upper(ResourceGroup) as ResourceGroup\n    --,CostInBillingCurrency as Cost\n    --,Tags\n    sum(CostInBillingCurrency)\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/20240201-20240229/ACMMonthlyAmortizedCost_20240201-20240229.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    upper(Tags) not like N'%\"COSTALLOCATIONTYPE\": \"WBS\"%' AND    \n    upper(SubscriptionName) like 'S913-AURORA-NON-PRODUCTION'\n    and lower(ResourceGroup) = 'mc_dev-aurora-ngrm-00_dev-aurora-ngrm-00_northeurope'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/All non RI VMs')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost,\n    MeterSubCategory\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and MeterSubCategory != 'Reservation-Base VM'\n--and (MeterSubCategory LIKE '%Windows%') \n--WHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' and AdditionalInfo NOT LIKE '%Standard_DS[0-9]_v2%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterSubCategory\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType')\n--GROUP BY REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ServiceType\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/All_Cost_2021-04_2022-03')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/12 month period"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nwhere ([result].[Date] BETWEEN '2021-04-01' and '2022-03-31')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/All_Cost_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/All_Cost_2021_By_Product_MeterCategory_MeterSubCategory_ConsumedService_MeterName_UnitOfMeasure_PartNumber_Quantity')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as Date,\n    Product, \n    MeterCategory, \n    MeterSubCategory, \n    ConsumedService, \n    MeterName, \n    UnitOfMeasure, \n    PartNumber, \n    sum(ConsumedQuantity) as ConsumedQuantity, \n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), Product, MeterCategory, MeterSubCategory, ConsumedService, MeterName, UnitOfMeasure, PartNumber\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by Code and MeterCategory Amortized')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by MeterCategory\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    --CostAllocationCode\n    ActiveWBS\n    ,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/AmortizedCost/CostTagsExtended_ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, MeterCategory --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by Code and MeterCategory')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by MeterCategory\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/Ac*/CostTagsExtended_ACMMonthly*2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, MeterCategory --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by ConsumedService Amortized')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    --CostAllocationCode\n    ActiveWBS\n    ,ConsumedService\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/AmortizedCost/CostTagsExtended_ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ConsumedService --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by ConsumedService')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ConsumedService\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/ActualCost/CostTagsExtended_ACMMonthlyActualCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ConsumedService --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by CostAllocationCode Amortized')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by WBS to be charged (including CI and APPID WBS lookup)\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    --,format(sum(CostInBillingCurrency), 'N2') as Cost\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/AmortizedCost/CostTagsExtended_ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS--, CostAllocationType\n    order by sum(CostInBillingCurrency) DESC--, CostAllocationCode, CostAllocationType DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by CostAllocationCode')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by WBS to be charged (including CI and APPID WBS lookup)\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    --,format(sum(CostInBillingCurrency), 'N2') as Cost\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/ActualCost/CostTagsExtended_ACMMonthlyActualCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS--, CostAllocationType\n    order by sum(CostInBillingCurrency) DESC--, CostAllocationCode, CostAllocationType DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by Resource Location Amortized')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by Resource Location\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    --CostAllocationCode\n    ActiveWBS\n    ,ResourceLocation\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/AmortizedCost/CostTagsExtended_ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ResourceLocation --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Cost by Resource Location')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by ConsumedService\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    --CostAllocationType,\n    ActiveWBS\n    ,ResourceLocation\n    --,MeterCategory\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/ActualCost/CostTagsExtended_ACMMonthlyActualCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by ActiveWBS, ResourceLocation --format([Date], 'yyyy-MM'), CostAllocationType,\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark Invalid CostAllocationTypes')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/ActualCost/CostTagsExtended_ACMMonthlyActualCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \"CI%' and \n          upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \"WBS%' AND\n          upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \"APPID%' AND\n          upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \"TOBESPECIFIED%' AND\n          upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \"\"%' AND\n          upper(Tags) not like '%\"COSTALLOCATIONTYPE\": \" \"%' AND\n          upper(Tags) like '%\"COSTALLOCATIONTYPE\"%'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark cost by CostAllocationCode and CostAllocationType Amortized')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by CostAllocationType\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    CostAllocationType\n    --,CostAllocationCode\n    ,ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/AmortizedCost/CostTagsExtended_ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by CostAllocationType, ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Benchmark cost by CostAllocationCode and CostAllocationType')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "--\n--   Cost by CostAllocationType\n--\nSELECT\n    --TOP 1000 \n    --Tags \n    CostAllocationType\n    ,ActiveWBS\n    --,format([Date], 'yyyy-MM')\n    --,SubscriptionWBS\n    --,[SubscriptionServiceNow-App] \n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/benchmark/ActualCost/CostTagsExtended_ACMMonthlyActualCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where CostAllocationType not in ('CI', 'APPID', 'WBS', 'SubscriptionWBS')\n    --where CostAllocationCode = '' or CostAllocationType = '' or CostAllocationCode = 'TOBESPECIFIED' or CostAllocationType = 'TOBESPECIFIED'\n    group by CostAllocationType, ActiveWBS --format([Date], 'yyyy-MM'),\n    --group by CostAllocationCode, CostAllocationType\n    order by sum(CostInBillingCurrency) desc --, CostAllocationCode, CostAllocationType \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Calendar')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "-- Create the Calendar table\nCREATE TABLE Calendar (\n    [Date] DATE PRIMARY KEY,\n    [Year] INT,\n    [Month] INT,\n    [Day] INT,\n    [Quarter] INT,\n    [DayOfWeek] INT,\n    [Weekday] BIT,\n    [WeekOfYear] INT,\n    [MonthName] NVARCHAR(20),\n    [DayName] NVARCHAR(20),\n    [IsHoliday] BIT\n);\n\n-- Populate the Calendar table\nDECLARE @StartDate DATE = '2000-01-01';\nDECLARE @EndDate DATE = '2030-12-31';\n\nWITH CalendarData AS (\n    SELECT\n        DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate) AS [Date],\n        DATEPART(YEAR, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [Year],\n        DATEPART(MONTH, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [Month],\n        DATEPART(DAY, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [Day],\n        DATEPART(QUARTER, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [Quarter],\n        DATEPART(WEEKDAY, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [DayOfWeek],\n        CASE WHEN DATEPART(WEEKDAY, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) IN (1, 7) THEN 0 ELSE 1 END AS [Weekday],\n        DATEPART(WEEK, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [WeekOfYear],\n        DATENAME(MONTH, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [MonthName],\n        DATENAME(WEEKDAY, DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate)) AS [DayName],\n        0 AS [IsHoliday] -- Set IsHoliday value based on your specific requirements\n    FROM sys.all_columns AS c1\n    CROSS JOIN sys.all_columns AS c2\n    WHERE DATEADD(DAY, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1, @StartDate) <= @EndDate\n)\n\nINSERT INTO Calendar ([Date], [Year], [Month], [Day], [Quarter], [DayOfWeek], [Weekday], [WeekOfYear], [MonthName], [DayName], [IsHoliday])\nSELECT [Date], [Year], [Month], [Day], [Quarter], [DayOfWeek], [Weekday], [WeekOfYear], [MonthName], [DayName], [IsHoliday]\nFROM CalendarData;\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Collect ACMMonthlyActualCostAggregate')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ACMMonthlyActualCost_Aggregated_overview\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/ACMMonthlyActualCost_Aggregated_overview.parquet/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Collect ACMMonthlyActualCostAggregatePartitionByDate')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ACMMonthlyActualCostAggregatedPartitionByDate\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/partition_aggregate/parquet/ACMMonthlyActualCost_Aggregated_overview.parquet/*/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Collect ACMMonthlyAmortizedCost_Aggregated_overview')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ACMMonthlyAmortizedCost_Aggregated_overview\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/ACMMonthlyAmortizedCost_Aggregated_overview.parquet/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Combined_Actual_Savings')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Management API"
				},
				"content": {
					"query": "declare @last_month varchar(6) = FORMAT(EOMONTH(CURRENT_TIMESTAMP, -1), 'yyyyMM'),\n        @sql varchar(max) = ''\n\nset @sql = '\nSELECT\n    SubscriptionId, \n    SubscriptionName,\n    [Date],\n    ResourceGroup, \n    ResourceName, \n    ResourceId, \n    MeterCategory, \n    MeterSubCategory, \n    MeterName,\n    UnitOfMeasure,\n    Quantity,\n    UnitPrice,\n    EffectivePrice,\n    CostInBillingCurrency,\n    ServiceInfo2, \n    PartNumber,\n    AdditionalInfo\nFROM\n    OPENROWSET(\n        BULK ''https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/' + @last_month + '*/ACMMonthlyActualCost_*.parquet'',\n        FORMAT = ''PARQUET''\n    ) AS [result]\nWHERE ([Date] >= ''2023-01-30'' and [Date] <= ''2023-02-01'') \n    and (ResourceId like ''%/virtualMachines/%'' or ResourceId like ''%/virtualMachineScaleSets/%'')\n    and (MeterSubCategory like ''%Windows%'' or ServiceInfo2 = ''Windows Server BYOL'')\n\nUNION --ALL\n\nSELECT\n    SubscriptionId, \n    SubscriptionName,\n    [Date],\n    ResourceGroup, \n    ResourceName, \n    ResourceId, \n    MeterCategory, \n    MeterSubCategory, \n    MeterName,\n    UnitOfMeasure,\n    Quantity,\n    UnitPrice,\n    EffectivePrice,\n    CostInBillingCurrency,\n    ServiceInfo2, \n    PartNumber,\n    AdditionalInfo\nFROM\n    OPENROWSET(\n        BULK ''https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet'',\n        FORMAT = ''PARQUET''\n    ) AS [result]\nWHERE ([Date] >= ''2023-01-30'' and [Date] <= ''2023-02-01'') \n    and (ResourceId like ''%/virtualMachines/%'' or ResourceId like ''%/virtualMachineScaleSets/%'')\n    and (MeterSubCategory like ''%Windows%'' or ServiceInfo2 = ''Windows Server BYOL'')\n'\n\nEXECUTE(@sql)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ConsumedService by Subscription - Monthly')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "\nSELECT\n    SubscriptionName, sum(Cost) as Cost, ConsumedService --, substring([Date],0,8) as [Date]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2021/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere substring([Date],0,8) = '2021-01'\nGROUP BY SubscriptionName, ConsumedService, substring([Date],0,8)\nORDER BY SubscriptionName, ConsumedService, substring([Date],0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by Consumed Service')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 * \n    format([Date], 'yyyy-MM') as [Date]\n    ,upper(ConsumedService)\n    ,FORMAT(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    --where ConsumedService <> 'RoundingAdjustment'\n    group BY upper(ConsumedService), format([Date], 'yyyy-MM')\n    order by format([Date], 'yyyy-MM'), sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by Meter Category')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Resource Type"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 *\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date], \n    MeterCategory, \n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/*/*/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by MeterCategory YTD')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *\n    format([Date], 'yyyy-MM') as [Date]\n    ,upper(MeterCategory) as MeterCategory\n    ,FORMAT(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory <> 'RoundingAdjustment'\n    group BY upper(MeterCategory), format([Date], 'yyyy-MM')\n    order by format([Date], 'yyyy-MM'), sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by Month 2020')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Date"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2020/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2)\nORDER BY substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by Month 2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Date"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost by Month All Dates')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Date"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), FORMAT ([Date],'yyyy-MM')\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY FORMAT ([Date],'yyyy-MM') \nORDER BY FORMAT ([Date],'yyyy-MM') ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost for ResourceName List')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    ResourceName,\n    sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/20230901-20230930/Extended_v2_ACMMonthlyAmortizedCost_202309*.parquet/part*.snappy.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    WHERE UPPER(ResourceName) IN \n        ('S018-NOE-ORACLE-PROD01', 'S018-NOE-ORACLE-PROD01S', 'S018-NOE-ORACLE-TEST01', 'S021-NOE-ORACLE-DEV01', 'S021-NOE-ORACLE-PROD01', 'S021-NOE-ORACLE-PROD02', 'S021-NOE-ORACLE-PROD03',\n'S021-NOE-ORACLE-PROD03S', 'S021-NOE-ORACLE-TEST01', 'S021-NOE-ORCL-TEST-T609', 'S021-NOW-ORACLE-OBS01', 'S021-NOW-ORACLE-OBS03', 'S021-NOW-ORACLE-PROD01', 'S025-NOE-ORACLE-TEST08',\n'S034-NOE-ORACLE-PROD01', 'S034-NOE-ORACLE-PROD02', 'S034-NOE-ORACLE-PROD03', 'S034-NOE-ORACLE-TEST01', 'S034-NOW-ORACLE-TEST01', 'S034-WE-ORACLE-TEST01', 'S034-WE-ORACLE-TEST02',\n'S034-WE-ORACLE-TEST03', 'S034-WE-ORACLE-TEST04', 'S052-NCUS-ORACLE-TEST01S', 'S052-SCUS-ORACLE-DEV01', 'S052-SCUS-ORACLE-DEV02', 'S052-SCUS-ORACLE-OBS01', 'S052-SCUS-ORACLE-TEST01',\n'S052-SCUS-ORACLE-TEST01S', 'S084-NOE-ORACLE-PROD01', 'S098-NOE-ORACLE-OBS01', 'S098-NOE-ORACLE-PROD01', 'S098-NOE-ORACLE-PROD01S', 'S098-NOW-ORACLE-OBS01', 'S098-NOW-ORACLE-PROD01S',\n'S110-NOE-ORACLE-TEST01', 'S111-NOE-ORACLE-PROD01', 'S125-NOE-ORACLE-DEV01', 'S125-NOE-ORACLE-TEST01', 'S125-NOE-ORACLE-TEST02', 'S125-NOE-ORACLE-TEST03', 'S126-NOE-ORACLE-OBS02',\n'S126-NOE-ORACLE-PROD01', 'S126-NOE-ORACLE-PROD01S', 'S126-NOE-ORACLE-PROD02', 'S126-NOE-ORACLE-PROD02S', 'S126-NOE-ORACLE-PROD03', 'S126-NOE-ORACLE-PROD03S', 'S126-NOE-ORACLE-PROD04',\n'S126-NOE-ORACLE-PROD04S', 'S126-NOE-ORACLE-PROD05', 'S126-NOE-ORACLE-PROD05S', 'S126-NOE-ORCL-T01', 'S126-NOW-ORACLE-OBS01', 'S126-NOW-ORACLE-PROD01', 'S126-NOW-ORACLE-PROD01S1',\n'S126-NOW-ORACLE-PROD02S1', 'S126NOESTID01', 'S126NOESTID02', 'S126NOESTIDACC01', 'S126NOWORACLETEST01S', 'S152-NOE-ORACLE-PROD01', 'S152-NOE-ORACLE-PROD01S', 'S152-NOE-ORACLE-PROD02',\n'S152-NOE-ORACLE-PROD02S', 'S152-NOE-ORACLE-PROD03', 'S152-NOW-ORACLE-OBS01', 'S152-NOW-ORACLE-OBS02', 'S152-NOW-ORACLE-PROD01S', 'S152-NOW-ORACLE-PROD02S', 'S153-NOE-GLA-ORA-TEST',\n'S153-NOE-SA-ORA-TEST', 'S193-NOE-ORACLE-OBS02', 'S193-NOE-ORACLE-PROD01', 'S193-NOE-ORACLE-PROD02', 'S193-NOE-ORACLE-PROD02S', 'S193-NOE-ORACLE-TEST01', 'S193-WE-ORACLE-PROD02S',\n'S223-NOE-ORACLE-PROD01', 'S223-NOE-ORACLE-PROD01S', 'S223-NOW-ORACLE-OBS01', 'S223-NOW-ORACLE-PROD01S', 'S226-WE-ORACLE-OBS02', 'S226-WE-ORACLE-TEST01', 'S226-WE-ORACLE-TEST02',\n'S226-WE-ORACLE-TEST02S', 'S226-WE-ORACLE-TEST04', 'S245-NOE-ORA-HA-TEST01', 'S245-NOE-ORACLE-DEV01', 'S245-NOE-ORACLE-OBS01', 'S245-NOE-ORACLE-OBS02', 'S245-NOE-ORACLE-TEST01',\n'S245-NOE-ORACLE-TEST01R', 'S245-NOE-ORACLE-TEST02', 'S245-NOE-ORACLE-TEST02S', 'S245-NOE-ORACLE-TEST04', 'S245-NOE-ORACLE-TEST06', 'S245-NOW-ORACLE-TEST01S', 'S245-NOW-ORACLE-TEST02S',\n'S246-NOE-ORACLE-OBS01', 'S246-NOE-ORACLE-OBS02', 'S246-NOE-ORACLE-PROD01', 'S246-NOE-ORACLE-PROD01S', 'S246-NOE-ORACLE-PROD02', 'S246-NOE-ORACLE-PROD02S', 'S246-NOE-ORACLE-PROD03',\n'S246-NOW-ORACLE-PROD01S', 'S246-NOW-ORACLE-PROD02S', 'S252-NOE-ORACLE-OBS01', 'S252-NOE-ORACLE-PROD01', 'S252-NOE-ORACLE-PROD01S', 'S252-NOW-ORACLE-PROD01S', 'S253-NOE-ORACLE-DEV01',\n'S253-NOE-ORACLE-TEST01', 'S253-NOE-ORACLE-TEST01S', 'S253-NOW-ORACLE-OBS01', 'S253-NOW-ORACLE-TEST01S', 'S268-NOE-ORACLE-PROD01', 'S268-NOE-ORACLE-PROD02', 'S268-NOW-ORACLE-PROD01',\n'S268-SCUS-ORACLE-PROD01', 'S268-WE-ORACLE-OBS03', 'S268-WE-ORACLE-PROD01', 'S268-WE-ORACLE-PROD02', 'S268-WE-ORACLE-PROD03', 'S268-WE-ORACLE-PROD03S', 'S268-WE-ORACLE-PROD04',\n'S268-WE-ORACLE-PROD05', 'S268-WE-ORACLE-PROD07', 'S275-NOE-ORACLE-PROD01', 'S288-NE-ORACLE-TEST01S', 'S288-WE-ORACLE-OBS01', 'S288-WE-ORACLE-TEST01', 'S288-WE-ORACLE-TEST01S',\n'S289-BS-ORACLE-PROD01', 'S289-NE-ORACLE-OBS01', 'S289-WE-ORACLE-PROD01', 'S289-WE-ORACLE-PROD02', 'S289-WE-ORACLE-PROD02S', 'S289-WE-ORACLE-PROD03', 'S289-WE-ORACLE-PROD03S', 'S289-WE-ORACLE-PROD04',\n'S289-WE-ORACLE-PROD04S', 'S289-WE-ORACLE-PROD05', 'S289-WE-ORACLE-PROD05S', 'S313-NE-ORACLE-OBS01', 'S313-WE-ORACLE-PROD01', 'S313-WE-ORACLE-PROD03', 'S313-WE-ORACLE-PROD04', 'S355-NOE-ORACLE-OBS01',\n'S355-NOE-ORACLE-PROD01', 'S355-NOE-ORACLE-PROD01S', 'S355-NOE-ORACLE-TEST01', 'S385-NOE-ORACLE-DEV01', 'S385-NOE-ORACLE-PROD01', 'S385-NOE-ORACLE-TEST01', 'S424-NCUS-ORACLE-PROD01DR',\n'S424-SCUS-ORACLE-PROD01', 'S424-SCUSQQM-ORACLE-PROD01', 'S425-NCUS-ORACLE-TEST01S', 'S425-SCUS-ORACLE-TEST01', 'S425-SCUSQONS-ORACLE-DEV', 'S425-SCUSQQM-ORACLE-QA', 'S437-SCUS-ORACLE-DEV01',\n'S438-SCUS-ORACLE-PROD01', 'S457-NCUS-ORACLE-PROD01DR', 'S457-SCUS-ORACLE-PROD01', 'ZB-DB1001', 'ZB-DB1002', 'ZI-DB1001', 'ZI-DB1004', 'ZI-DB1005', 'ZNE-DB1001', 'ZNE-DB1002', 'ZNE-DB1004',\n'ZNE-DB1005', 'ZNE-DB1006', 'ZNE-DB1007', 'ZNE-DB1008', 'ZNE-DB1009', 'ZNE-DB1010', 'ZNE-DB1011', 'ZNE-DB1012', 'ZNE-DB1013', 'ZNE-DB1014', 'ZNE-DB1015', 'ZNE-DB1016', 'ZNE-DB1017', 'ZNE-DB1018',\n'ZNE-DB1019', 'ZNE-DB1020', 'ZNE-DB1021', 'ZNE-DB1022', 'ZNE-DB1023', 'ZNE-DB1024', 'ZNE-DB1025', 'ZNE-DB1026', 'ZNE-DB1027', 'ZNE-DB1028', 'ZNE-DB1029', 'ZNE-DB1030', 'ZNE-DB1031', 'ZNE-DB1032',\n'ZNE-DB1033', 'ZNE-DB1034', 'ZNE-DB1035', 'ZNE-DB1036', 'ZNE-DB1038', 'ZNE-DB1039', 'ZNE-DB1041', 'ZNE-DB1042', 'ZNE-DB1043', 'ZNW-DB1000', 'ZNW-DB1001', 'ZNW-DB1002', 'ZNW-DB1003', 'ZNW-DB1004',\n'ZNW-DB1005', 'ZNW-DB1006', 'ZNW-DB1007', 'ZNW-DB1008', 'ZNW-DB1009', 'ZNW-DB1010', 'ZNW-DB1011', 'ZNW-DB1012', 'ZNW-DB1013', 'ZNW-DB1014', 'ZNW-DB1015', 'ZNW-DB1016', 'ZT-DB1006')\ngroup by ResourceName\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost of VM Reservations')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    reservationOrderId,\n    reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    region AS region,\n    substring(eventDate,0,11) AS eventDate,\n    reservationOrderId AS reservationOrderId,\n    description AS [description],\n    quantity AS quantity,\n    amount AS amount,\n    reservationOrderName AS reservationOrderName,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/reservations/2022/reservations_costreport.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\nwhere armSkuName NOT LIKE 'SQL%'\norder by substring(eventDate,0,11)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost of VM by MeterSubCategory')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Resource Type"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), [MeterSubCategory]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2022/03/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' AND MeterSubCategory != 'Reservation-Base VM' AND Cost > 0\nGROUP BY [MeterSubCategory]\nORDER BY sum(Cost) DESC\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost_by_MeterCategory_Annual')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    MeterCategory, sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY MeterCategory\nORDER BY MeterCategory",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost_by_MeterCategory_Monthly')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory, sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Cost_by_ServiceTier_Monthly')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ServiceTier, sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ServiceTier\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ServiceTier",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Create Reservation Cost View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Management API"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW reservation_cost\nAS\n\nSELECT\n    reservationOrderId AS reservationOrderId,\n    reservationOrderName AS reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    eventDate,\n    quantity AS quantity,\n    amount AS amount,\n    currency,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/tempdata/annual/2021/costreport_reservations_monthly_2021.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\n--where reservationOrderName NOT LIKE '%SQL%' and reservationOrderId != 'd5b99270-d26e-49b1-82dc-d7cb16a9181a' and reservationOrderName NOT LIKE '%SUSE%'\n--order by eventDate",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateAdvisorRecommendationsView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Advisor_Recommendations\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/recommendations/cost-recommendations.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateAnomalyView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Anomalies_Past_Three_Months\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_AnomalyDetection_3mnth.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateAzureRegionView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW AzureRegions\nAS\n\nSELECT\n    [displayName]\n    ,[geographyGroup]\n    ,[latitude]\n    ,[longitude]\n    ,[pairedRegion]\n    ,[physicalLocation]\n    ,[regionCategory]\n    ,[regionType]\n    ,lower([name]) as name\n    ,[regionalDisplayName]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/locations/azure_regions.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateBenefitPurchasesView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW BenefitPurchases\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/benefit-purchases.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateBusinessAreaLevelView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Based on the new data that is generated by Joakim. ",
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW BusinessAreaLevel\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/AzureAD_BusinessAreaLevel/gold/usersWithBusinessAreaSnapshot_v1.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateCalendarView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Calendar_New\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/Calendar/delta/Calendar.delta/',\n        FORMAT = 'DELTA'\n    ) AS [result]\n\nGO\nSELECT TOP 10 * FROM Calendar_New",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateCumulativeCostView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW CumulativeCost\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/cumulative-cost-prediction.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateHUBandRISavingsView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW HUBandRISavings\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/hub/hub-and-ri-savings-past-two-years.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateOneYearCostView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ACMMonthlyAmortizedCost_overview_Oneyear\nAS\n\nSELECT *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_OneYear.parquet/*/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreatePricesheetView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Pricesheet\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/pricesheet/portal-export/pricesheet-latest/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateRIPurchasesView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW RIPurchases\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/ri/ri-purchases.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateRIRecommendationsView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW RIRecommendations\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/ri/ri-recommendations-with-autofit-combometer.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateServiceCostPredictionView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW ServiceCostPrediction\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/service-cost-prediction.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateServiceNowApplicationView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ServiceNowApplication\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/applications/ServiceNow-Application-List-Extended.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateServiceNowSubscriptionView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW ServiceNowSubscriptions\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/subscriptions/servicenow/latest-optimized.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateThreeYearCostView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_ACMMonthlyAmortizedCost_overview_Threeyears\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_Threeyears.parquet/*/*/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateVMUtilizationDailyMetricsView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW VM_Utilization_Daily_Metrics_Past_Three_Months\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/metrics/vm-utilization-aggregates/vm_cpu_agg_daily_past_3_months.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateVMUtilizationHourlyMetricsView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW VM_Utilization_Hourly_Metrics_Past_Three_Months\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/metrics/vm-utilization-aggregates/vm_cpu_agg_hourly_past_3_months.parquet/',\n        FORMAT = 'PARQUET'\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CreateWBSOWnerView')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW WBSOwners\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/sap/wbs-owner-latest.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DB_VCPU_Hours_2021_Daily')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --DISTINCT(ConsumedService), \n    --sum(ConsumedQuantity) as ConsumedQuantitySum,\n    --COUNT(ConsumedQuantity) as ConsumedQuantityCount,\n    --JSON_VALUE(AdditionalInfo, '$.vCores'),\n    --MeterName\n    --top 100 *\n    ConsumedService, \n    ConsumedQuantity,\n    InstanceId,\n    --AdditionalInfo,\n    JSON_VALUE(AdditionalInfo, '$.vCores') as AddInfo_vCores,\n    MeterName,\n    MeterCategory,\n    PartNumber,\n    [Date]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE (MeterCategory LIKE '%Database%' or  \n        MeterCategory LIKE '%SQL%') AND \n      (MeterSubCategory NOT LIKE '%Storage' AND \n        MeterSubCategory NOT LIKE '%License%') AND\n      (MeterName NOT LIKE '%DTU%') \n--GROUP BY ConsumedService",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DB_VCPU_Hours_2021_Investigation')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --DISTINCT(ConsumedService), \n    --sum(ConsumedQuantity) as ConsumedQuantitySum,\n    --COUNT(ConsumedQuantity) as ConsumedQuantityCount,\n    --JSON_VALUE(AdditionalInfo, '$.vCores'),\n    --MeterName\n    --top 100 *\n    ConsumedService, \n    ConsumedQuantity,\n    InstanceId,\n    JSON_VALUE(AdditionalInfo, '$.vCores') as AddInfo_vCores,\n    MeterName,\n    MeterCategory,\n    PartNumber,\n    [Date]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE (MeterCategory LIKE '%Database%' or  \n        MeterCategory LIKE '%SQL%') AND \n      (MeterSubCategory NOT LIKE '%Storage' AND \n        MeterSubCategory NOT LIKE '%License%') AND\n      (MeterName NOT LIKE '%DTU%') AND\n      --(MeterName = 'vCore' and ConsumedQuantity > 24 and AddInfo_vCores = \"\")\n      InstanceId = '/subscriptions/20666D8E-81B0-479F-8D56-D13FC4E5C12F/resourceGroups/osdu-r3mvp-sreqn-7wd9-rg/providers/Microsoft.DBforPostgreSQL/servers/osdu-r3mvp-sreqn-7wd9-pg'\n--GROUP BY ConsumedService",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DB_VCPU_Hours_2021_Monthly')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    JSON_VALUE(AdditionalInfo, '$.vCores') as AddInfo_vCores,\n    MeterName,\n    MeterCategory,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) AS [Date],\n    sum(Cost) AS Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE (MeterCategory LIKE '%Database%' or  \n        MeterCategory LIKE '%SQL%') AND \n      (MeterSubCategory NOT LIKE '%Storage' AND \n        MeterSubCategory NOT LIKE '%License%') AND\n      (MeterName NOT LIKE '%DTU%') \nGROUP BY JSON_VALUE(AdditionalInfo, '$.vCores'), MeterName, MeterCategory, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataBricks Disk Deletion Issue')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "  use costmgmt\n\nSELECT\n    --TOP 100 \n    --*,\n    SubscriptionName\n    --,ResourceGroup\n    --,format([Date],'yyyy-MM') as [Date]\n    ,format([Date],'yyyy-MM') as Date\n    --,CostInBillingCurrency as Cost \n    --,ResourceName\n    --,CostInBillingCurrency\n    --,*\n    ,sum(CostInBillingCurrency) as Cost\n\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202301*/ACMMonthlyActualCost_*.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/202*/ACMMonthlyAmortizedCost_*.parquet',\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2023*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\nwhere \n    (SubscriptionName = 'S219-MSS-Data-Platform-Production' OR\n    SubscriptionName = 'S218-MSS-Data-Platform-Non-Production')\n    --and ResourceGroup = 'eqnr-atlas-prod-maiacmndbwmngd-rg-xxg'\n    --and MeterSubCategory = 'Premium SSD Managed Disks'\n    and MeterCategory = 'Storage'\n    and lower(ResourceName) in \n    ('3a05c5cfac4146b9a10e06d5f2f1772f-0-scratchvolume','50d5f677d7944549b3ff458da26d357c-osdisk','32563072d8724e198f4a65645da37809-0-scratchvolume',\n    'e458f50133054053a2f387607920e353-0-scratchvolume','e4c1936a2b7845b08cb4c6fb72d2494b-containerrootvolume','90844098c44e4d9ea4bc235a532b6428-containerrootvolume',\n    'f00d4e59f7c14abda1793978d03459d3-containerrootvolume','d57de24fb50c4c39a5d99f375d069092-0-scratchvolume','0a6fc56d374e458cabbb2e4e560ed569-osdisk','3e2510563eb74de3ae374f36f3d8b94e-0-scratchvolume',\n    'e741ef8a787947be89374ee1cef34709-osdisk','00e08039ea474a30971ec66cd96cde01-osdisk','b1f95abb35e14759892fd38ae40b201d-containerrootvolume',\n    'd233bda9955147b7acdc8739a7287ad7-0-scratchvolume','a571431b41464565981249e64312cfac-containerrootvolume','810a26b2a4c8410b91938744294ae51c-osdisk',\n    '7c46635e3c694624a2a6278faf45b4c2-osdisk','1b992e9291584eb1a7ed53cb5ef6fdc0-0-scratchvolume','7290188e260e431ba4f84e88ee665235-containerrootvolume',\n    'cf3055997a63489b8e6673648de0619c-0-scratchvolume','f84fac16f0b14baba9c0dcb6e4551107-containerrootvolume','66a3df53a52d4f5d912685e2028e6171-containerrootvolume',\n    'ed14ca65c9a94a34aa3112a9ac9d855d-0-scratchvolume','43304e90ba314d689f11c7fac54d885c-containerrootvolume','b548390159544b9791fcca1ec2e30525-containerrootvolume',\n    '96ccfd96026f4015b8c0d149a45c831c-osdisk','fdd8ec9390c4418c972818bc789362ab-0-scratchvolume','6b4fe9cdff3741989acb8ac0ff98173b-0-scratchvolume','b493058b5f074801a7460fe2737a6061-osdisk',\n    '9bd042c67f4b4bd0b0e0f11051601b5d-0-scratchvolume','ffe39122be934be08344be206b37b306-0-scratchvolume','33a46b2f826b430f8f30398ed37e760f-osdisk','733149a80e544721acc0ec98911fdb9f-containerrootvolume',\n    '72be31e6c58340f3bc201d73c4c12838-containerrootvolume','72be31e6c58340f3bc201d73c4c12838-osdisk','cece2044ddb54ccab8aaeed27a629314-0-scratchvolume','4f2dd4f1a6274f1c8d263983a8c04bdb-0-scratchvolume',\n    'a2872f7d82cf464a89247a6928c37469-containerrootvolume','6de02bc67486415ab27cfe28383f7778-osdisk','c7ecb26690bc488195bc757f2301a0c9-containerrootvolume',\n    '2bafe38e9b3549749f54094a40efa7eb-containerrootvolume','2d032d19ffb8471b9996a8ec1e30a422-0-scratchvolume','46bc33676d484bfb9bf0607b9ca91cee-osdisk',\n    'c420d7cc470b474b80784b734e56bc0a-containerrootvolume','1bccef217622420691cd31cf85e5a4ca-osdisk','b7e715845d794dd1bbf7fecac74b7ec9-containerrootvolume',\n    '30293544fdd046cc92142ca3a2090792-containerrootvolume','f244e3b7600e4ec0b05735520063aaa2-containerrootvolume','c45c19dae72c4435aa54c5577d12ebb8-osdisk',\n    '17d95668855b4685a63052f66ea98964-0-scratchvolume','fe0284d30e444c168a54264aff89e4a2-osdisk','6c1c0eec136843e69a091d78582584ba-containerrootvolume',\n    'a9189f6ce0634f9ebe9438feb5daa4ff-containerrootvolume','3006eccd67764ce3af2f6d7e384db0e0-containerrootvolume','5a89d19d56994ea599479f364603990a-osdisk',\n    'a2d3dbe42c22453f93a9c25179887df9-containerrootvolume','66db85f167ad41ac8d3c6e2b614ca6e2-containerrootvolume','09e4ce5965ad49f6902594ad7d837fe1-0-scratchvolume',\n    '2ed4de63f2474c4f9daf93ef87a5bde6-osdisk','7513ee09d02b4ceb899eeb56562f371e-osdisk','262cf6b99eca4e7dae9a7118e50a6152-osdisk','3213c0c45cc44f67972850b0e3ffc0be-osdisk',\n    '913150d8a7f84b7cb96c478fbad5a89c-containerrootvolume','bb9acca78ea54c2693707bd84019cb6d-0-scratchvolume','e115ea650b244ca19f59766f33d189f3-0-scratchvolume',\n    'e20de2082a8343e29ea8f7f05d7a36c7-0-scratchvolume','0290b3bd4efa49d5b0d79963c0feb9ac-osdisk','7b5e1da4887441e09fd2fcfa8a456d52-osdisk','7e55d8645c654db982377ab9c6a1b859-containerrootvolume',\n    'df336595152344bc8fc58d9a8df3e4b0-0-scratchvolume','8a1a8ccbf2c34e1daee027764214b07e-0-scratchvolume','142c5654c3a14c0f960b04123ee75cfc-containerrootvolume',\n    'ca7a492e04654f18aaad8495af200492-containerrootvolume','84e63aa0a0424a6ca9fd786aaf6a3e91-0-scratchvolume','3f3eeec2a94d44f5ae2bf6d075dad30c-0-scratchvolume',\n    '3223d52ebadc49eaa4cf34d19f7cc79b-containerrootvolume','f1930e0442ad477c9f31a9b02e0fa708-0-scratchvolume','2b8257b8c6fa4e659773526ff4207223-containerrootvolume',\n    '7cae40f6814f4d899a51af985944b7b2-containerrootvolume','095c504b990c43c38a8b408542f8b5ed-osdisk','537e332eacaa406dba8b73ee416455bb-0-scratchvolume','0a26e4e70b3c47b8b0dfbd74843f69e7-containerrootvolume',\n    '7e69d3280f25462f8f26eeaceea3215f-containerrootvolume','d92776367c9843d2b14bf1205cea3c0b-containerrootvolume','3c3877c0e0fb437d9e4cfca4a3a3d9f0-0-scratchvolume','7072ec9254964689af429e0fa830637a-0-scratchvolume',\n    '5d047bcbddb5444893d657e0a64b3c34-containerrootvolume','49e06a9ad6174227bb5c7907c0951545-containerrootvolume','2c31e4da802143a496fd66b45161cbd4-osdisk','1e2a5a2d815a43fa9c7ae59de602a25f-0-scratchvolume',\n    'f9e943d5851648eb89c1d717501ee393-0-scratchvolume','768752a1b63e4626ba510e90e868d2b1-osdisk','4c72617e90474e59b56c2f065f223d9f-osdisk','ec1f956b7eb24f56a04956a57b089d27-containerrootvolume',\n    'f7d25eb2d7d74f0a9d79a432186f64b0-containerrootvolume','f7d25eb2d7d74f0a9d79a432186f64b0-0-scratchvolume','62b19901d8ca4217a806986af3627440-containerrootvolume','d16cf5b134094188abeb9ff7e8d2ae79-containerrootvolume',\n    'a2f9a7d02cfb463e8797523de358d8cd-osdisk','f95e070363d9496aaab047b2f988765f-osdisk','bc4fb5b14c5d438480ad3db12fbf5f6e-containerrootvolume','bc4fb5b14c5d438480ad3db12fbf5f6e-0-scratchvolume',\n    'e95cf0748e98452d89be133426d21943-osdisk','3fa7a07be031451785f23b9027f62400-containerrootvolume','3fa7a07be031451785f23b9027f62400-osdisk','ff4261d8f67e4958b1b9bf7493c2e3a6-containerrootvolume',\n    '86ebb0e6aa8544c283a9b43ddbd35573-0-scratchvolume','d2c32539373c4fbaa62829ae506c1949-osdisk','a7ea675e65b34f8b9eeed59140a8cce8-containerrootvolume','b93ce2586aa24f61861184e78001a226-containerrootvolume',\n    'b4f2c0db129a46fb9b3d9e61ead2679c-containerrootvolume','4c78003d2f5941a19718e9754cd3c022-0-scratchvolume','3b74713b29bc49dabecbaefeb833897e-containerrootvolume','9a8ce5100ab9477eb944d02da4e55469-osdisk',\n    '5923f6d3979b4b5aa3e6b755a554035e-containerrootvolume','a4df4210c36f486ab8f49710c6dee1c0-containerrootvolume','883b42279e0e4d259cf24c95f8fd9351-containerrootvolume','ca9298f057ce43e1b25760a9aca7b0ec-osdisk',\n    '23ba432cb1c14009b6908c44ea561a40-0-scratchvolume','8aeb20aa19d941c39dd12bfc30c2478e-containerrootvolume','d5ef9502da0844d7969a5ac7090b3b24-containerrootvolume','289f1696730441afb923a0b6ed93aded-osdisk',\n    '229252ea5cb840208b7390b4becd7150-containerrootvolume','fd2499eee5bf491fac9be94b111b1536-osdisk','8accd06c566d4e65a6cf0f8ea63c742e-0-scratchvolume','b863c6ea353742daa677386271ef99ad-containerrootvolume',\n    '505f1ae897ee43539fb0bf96edc1563c-osdisk','e45672594c0342a5ae4495d3020ff821-containerrootvolume','c249bcb7329b4f1988ef2dbfcc9cd796-containerrootvolume','e3178fa60eca4430bea7293c26597a49-containerrootvolume',\n    '72f7985fe1a44932b84dfa27d53c8e26-containerrootvolume','52d7e04323064f09b0f384546188963e-containerrootvolume','79dae29de3384b499bc123fa47d405eb-containerrootvolume','592a7b468dcb478e8dd4f6a2ef14f1a7-containerrootvolume',\n    '4eb3928c3cb34cffb5b12d278596f6c0-containerrootvolume','f13fe637c2fb4a32bd055a5ce3e640d1-0-scratchvolume','b7e33b74532d4a9ab07278b19125359e-containerrootvolume','e2273e2bbfa742c6bf2844cabd4b84dd-osdisk','3c3dfc0afc87427dae6fef4e3a4c045d-0-scratchvolume',\n    '77116313d93545e79889f8d960b95c74-0-scratchvolume','5495fbeab21740e8a92632e6a555f229-containerrootvolume','4284574b98554ba99cb9e50ddb90dc0e-0-scratchvolume','45ae80cf1311439eb22867eab1f467a8-0-scratchvolume','78f5ef5c94384f8caca7871461c95f10-containerrootvolume',\n    'd90eba9901784907bc931bf2d2c8ffdb-osdisk','2c0cc4b23e93428a9d1cea429eb63a07-containerrootvolume','2c0cc4b23e93428a9d1cea429eb63a07-0-scratchvolume','4d37f0e2d18641eb9a0475ae66c15b68-0-scratchvolume','88b4e68221c748c3b936ca84385b9eab-0-scratchvolume',\n    '5b4a1b6fe9c946f9a640d655b3af3491-containerrootvolume','ee1e7a389b33434a819fa6552d6de10a-osdisk','90bd5da0f85d49dc9d0ef8a719734f32-osdisk','3d4abea15e8b464da787cf388dc1c673-containerrootvolume','3d4abea15e8b464da787cf388dc1c673-0-scratchvolume','b81c8af8c05344f3b1b874e6b7442a72-containerrootvolume','1fc114a7587b40f99d0b45c9b15a52bd-osdisk','6faf8be9d1c64045ae4f4f1372ae1e12-osdisk','190abbb3ff64414cb76c633fe47922b5-osdisk','a5e1de768c47456eb33c244dd76a3be8-containerrootvolume','2d67bfb386854659a46e291207a4bd05-containerrootvolume','270c4809f8d84d7c9889ed66ad5f7802-0-scratchvolume','8deb6b6e74824ff889f44faf7f0d27a3-containerrootvolume','20e6e611d8994d8a8b4ecc27ac4d5a6e-osdisk','c9806b03795b4f57b932d5219b86c543-containerrootvolume','152ed36bb196498490a0022954e7bf42-containerrootvolume','152ed36bb196498490a0022954e7bf42-0-scratchvolume','152ed36bb196498490a0022954e7bf42-osdisk','6f155194de184f01b2bc47913a8a32cb-osdisk','e042e8c61eca48f2b91f83107fb2c361-osdisk','7e21ee238e16423183b5e71ea97433de-containerrootvolume','68ce6519db5f47e3859c174d750b3ebd-osdisk','ced5dc6153f74b8b8511cc3035d96e18-0-scratchvolume','d841cab1c74a45d7b487887188b66ad0-containerrootvolume','d425cdc2bddb491283653a378386af33-osdisk','8807e377e937427e986ded4c0650340c-containerrootvolume','8807e377e937427e986ded4c0650340c-osdisk','5768ae02569e4673b6f70a7889b97a6f-containerrootvolume','780af97a60474dee9d74a64b262e195c-containerrootvolume','70072249230f478daf6dcadf86c741bc-0-scratchvolume','a8fe432398e949eeb001a14bdd54693b-0-scratchvolume','dc7eec337a1d46cbb69e0104570f144e-containerrootvolume','f03361e1fbc64735abfa02c6c05e2c67-0-scratchvolume','ee6b7467667546d68360dea8aac4eb65-0-scratchvolume','e6043837fb2d46c988adbbf86595d7d4-containerrootvolume','2bebc76f509c4872926eae5470679977-0-scratchvolume','a486869cfa5746b1a513e700047d4635-osdisk','9d9fd9f62d5e47dea9fa2edb060fdace-containerrootvolume','00e222a7e7cc485d877af2a7a4fa9fb4-0-scratchvolume','7d010def86744964aeb23e8cdf3c4a2b-containerrootvolume','3144cbf21c8d40ec9187e2d9210faaaa-osdisk','4a76bb8237ee44eba808e33a098ba5b0-0-scratchvolume','07a7bebf37b042fa94d8375038afb823-osdisk','8e47c09775ee488099ad7f0cde2f8fa2-0-scratchvolume','4af5cb0abc6b48c18818c51040ce56da-containerrootvolume','9c2718d876e54890b435408d3f64bb4b-containerrootvolume','f6d44e7dc56f4d328be4935fee4eb167-osdisk','be7cedee576a418796628e25ede1de6d-0-scratchvolume','f5229ba1d22c43fda700e5926ec77973-0-scratchvolume','54564e0466d246d98559ccde4d4a78ff-osdisk','16f3f0f73fa64e4fbbe3d9390afd598e-containerrootvolume','c2f153b04f2e4b3bad7a4139dea9ac1e-containerrootvolume','74933055e7534b9ca3ce0e08a281398f-0-scratchvolume','0bd3624963d5495c936f703a2772a16d-0-scratchvolume','a181614d5efa4f5d9b9e142eaf83e24d-containerrootvolume','4a898e0d6840498ca75b2ad1e40a1879-containerrootvolume','d6377245e7ed4abdb86a818feca4ce3f-0-scratchvolume','d7762c0ff62a4ab394ff5a26d1b6c2f4-osdisk','b7c13dfb4db346d494d97f126db5de21-osdisk','c2f2f6de94f540988a67760fe1036de8-0-scratchvolume','f8b9b156fd1e43c19446f72da01b35c4-osdisk','47086e8c9c0b4b4f9a01319a9eef7a5e-containerrootvolume','2767c7a78dbb40989e288ef7047fafde-containerrootvolume','01075a76cbf1461a97ae5e2eb8bd5fa1-0-scratchvolume','8ccdd188289b4b028b5c4237997fbd1b-osdisk','824fc252bbd4463faf064d1c42524a33-containerrootvolume','22d8177b2f564ee28d5fa4d86912130a-nc05r-scratchvolume','edad0e762be84d72896d6f0bb6a67dfa-osdisk','22fcb3b5cec64043a2843d13a12cf6bf-containerrootvolume','e36d6623f6fa4d3c8e601f743b8445f2-containerrootvolume','447a404196284a7a9b4302eb04d306e1-containerrootvolume','69b04bb9e1184f50b13745fb24b85e8e-0-scratchvolume','bf60c22ebf5a4b65bb2799094a2086ac-0-scratchvolume','739b66c162024ef19c05bae2c255b679-containerrootvolume','134bbf6dc2284f428e6d0391a796dbb0-0-scratchvolume','aaabe24de5c045efa85aadcb4767873b-osdisk','0a00e995bfa343a9a6ef97963834a662-containerrootvolume','8d7ccb7bc08c4bc48302070e30ce7844-0-scratchvolume','b00e9dd3c9414c76b874238f6fe75431-osdisk','50145566ea69434d9aeb27c9c0380511-osdisk','37afad68d0f94ff6ac010979e6a3ae63-0-scratchvolume','15df1a6298e4443885d6c42bd4ac69ff-osdisk','6da45859456e4d1dac4a1a78441d13bd-containerrootvolume','e4c7b0ad9fdc458095d48c546ffc7700-containerrootvolume','5f95180445ed42868d8c0ca42c7425e9-osdisk','01551a77bf5f4803a47fe07e8c70e86f-containerrootvolume','c3b0710414ea460c8ae87a85257481c2-containerrootvolume','98ea90239211478d860e65faff82729a-0-scratchvolume','39b97e341f78401f96117c4384b8032d-0-scratchvolume','4b091e6a0c4e4728803ba3faa651de64-0-scratchvolume','92548d428ba24f779f12db20f4372513-0-scratchvolume','20487b7809ad4a4893966c69338edb2d-0-scratchvolume','cfa0e1fcc27e48a5976cf1cd27047a10-osdisk','b7981ea6cacf447f86bd33ac1e776d4d-osdisk','8d40020b96f34610824e5564bf70b667-osdisk','6024ed7f24b34cd28ce8b2207c503586-containerrootvolume','bffe0f92aa7549c8b29352ad7dfa9ba4-containerrootvolume','7bf9e47abcfd4739b43d4a16769e31ab-containerrootvolume','cf42e364bef74382b5d71dc223513bf0-0-scratchvolume','8255434c11a4428ebc99a3fd0d9673c1-osdisk','8ba9b50b3bac4a839b6a6e401c681e0b-containerrootvolume','8012a0ab6f8746279010ed6ec8a4dd8f-osdisk','d4219895bda74dce961b47276830d962-osdisk','fc6250fc2029476f9a9a18fc7d0c7182-0-scratchvolume','44aa8a93694549a88e7ce4c21e870130-containerrootvolume','93155d46c0a742b38f22bd988a154555-containerrootvolume','70405b45786e4f4a916500fff6df5637-osdisk','b3b2667e0de34cd2abb3312a30df5b39-0-scratchvolume','0f04052b227e42dd83a3139cf107a40e-osdisk','fe8e56ad1d204b4c8919d51c379800ce-osdisk','809104ebc85f4c3f89c85ba97945f4cb-0-scratchvolume','cf54f62fbeab43a4999d7a01dc561aca-containerrootvolume','2d7992c899f34474a0bb94476c61d8e6-containerrootvolume','2d7992c899f34474a0bb94476c61d8e6-osdisk','1e9f5158b9b84ef1b978e9835b7b95e7-containerrootvolume','c5b8903abe25423abcf5abd5ffb4488c-containerrootvolume','2338050846144288b2d623c0c614a828-0-scratchvolume','49aaa73e1fb641dda68f6ea9f37f864f-containerrootvolume','f88acbc4827f44f8ad36e2343ccfd9ea-containerrootvolume','de32408b99f14fe1adae11f2769cbaba-0-scratchvolume','3e5078a793a2443ca08a232c31f826c8-containerrootvolume','a062bc047b374354a8c62cc3e4507a20-osdisk','0ef292bacb784bb3a98712ca2bed8902-osdisk','a1f8e55d5e5d4e34b841a0b6cf712c10-containerrootvolume','a1f8e55d5e5d4e34b841a0b6cf712c10-0-scratchvolume','a1f8e55d5e5d4e34b841a0b6cf712c10-osdisk','7a3c0bc4f2b64bfdac1abcb2e1ddd035-0-scratchvolume','199af585619240b68e847bc64671ca05-containerrootvolume','445d7f19868043eab3fad05a1ee97fab-0-scratchvolume','a8dd186b0397455b93514f7fca94e880-containerrootvolume','91bd91f8a01b4c76835dd0b0e55c32b6-containerrootvolume','7f49898c07cb4df6b7ee4972cf2faec6-containerrootvolume','24561d05348e4d6fa8d0d2cfeb8230a7-containerrootvolume','b527ae6c83ce4884bf6101338663ec86-osdisk','390134e5e4bb473a8c74d3456773b333-0-scratchvolume','d0bda8c887484043b3a96e409f211629-0-scratchvolume','4a71f1add18f4323940e4fa1c84824f5-osdisk','c714bea9ca5c4192a0cf93aca9f50103-0-scratchvolume','304fbd9044574b03bd56d3c38277c3e3-containerrootvolume','dfa537a8a5a84ed49d0c45c3abf1727c-0-scratchvolume','a030b7768ceb4824bd3d479a3e23d981-containerrootvolume','0f831e56cbf14e298eb52046e634e959-0-scratchvolume','4d4cfd1fc98e4f2d95a7cc448bef51be-containerrootvolume','bb16560884764e79a9783b41f0df2e87-containerrootvolume','c9cb1e84622d4463ac229614a36a7a09-containerrootvolume','b7c013462f0a4dfe84697b678720a7b0-containerrootvolume','79772345b0384045b50b350b3396995e-containerrootvolume','90eca6fe89e64a16ad591d8ff0579d74-0-scratchvolume','f2ea77715bd145bda8e3f33c45d3e962-osdisk','76ce612e96be4d648be1a949a851f977-osdisk','3c9588c33fb046e0a31cbcf8fb654f6b-containerrootvolume','2b83defcf5bc43b28029101a42a81073-containerrootvolume','9dfcf56e55724a40bb61c27431e41f13-osdisk','91986dfd4a6a44acb11d4edb7ba84761-0-scratchvolume','268ab00ea92a4424b28f7c5cc3319c93-containerrootvolume','f2c0ddefcfe24c7285d44ad71bdaf5b6-0-scratchvolume','e9709532052749fbbdcdc0e142b5dcf8-containerrootvolume','495c9c4f93fe48f589fe2943a1bd6a3e-0-scratchvolume','dea0e5e28e2a436da6c6198246eff4ec-osdisk','7e1c8fe89a154f5cac0c309a4c78f877-0-scratchvolume','7e1c8fe89a154f5cac0c309a4c78f877-containerrootvolume','7e1c8fe89a154f5cac0c309a4c78f877-osdisk','68f8fa9994e44026bb677f1f02c0beb7-0-scratchvolume','68f8fa9994e44026bb677f1f02c0beb7-containerrootvolume','551890e5f6a740bfbe727a1037a95f49-containerrootvolume','5b62c9c4263648dea967e6ff2fe5371a-osdisk','783be09daa48498ea68f222030ee74ec-osdisk','f46cdf5e96fa44a9ad45325a1bc6908c-containerrootvolume','3b6a0bb2f9a440bba0cf2a2e70243c66-containerrootvolume','439f2d68a53545c7a28e71112331e656-osdisk','7f2f9644daff4fc9a85a55ec5d9ba1ff-osdisk','e928d0dfe465487fb41559f4086eb8a3-containerrootvolume','f4df8cce74924e249152675f2a6a366f-containerrootvolume','86767a32a3a543229f9d595536ff8324-0-scratchvolume','7b706891f95c47da90e4f4dfd115c6af-osdisk','6e73ceed18e947d79d391e24fea5c075-containerrootvolume','b9a060cbd75044c2833478eea26396ec-0-scratchvolume','f68dc8dcdfe84f45a27eb48e6fed23cb-containerrootvolume','d0c2816769254d388d5028f0413289b9-containerrootvolume','95070ce3b35c4e5b97f7414e01bff713-osdisk','dfa7647cc0244a609c2a89d7827fd4ad-0-scratchvolume','ddf7d5547d974c6da82a5a491f208e11-containerrootvolume','7529ed6b35764ea5834a0910243f2e0a-0-scratchvolume','9dd44b8646bb43ffbf4fa593a6d08659-containerrootvolume','8235fe481bea490baf0535f6e81b9228-0-scratchvolume','f24751d1a82e4b43ac4c12e2cfc0ec09-osdisk','34b4c9d47fa24f249871914617fec1be-0-scratchvolume','16d4f0e25bdf4af29cb5bfc1c2a4e1a8-osdisk','0d17857e5e4e422081f2977cf5dd15a1-containerrootvolume','9eaf2c6491c54c3c81490883e786428b-containerrootvolume','f42fa9df0e8f45f890b72c89710a2b37-containerrootvolume','72f0528fdcab4ddfb6e5bd7d04444d71-0-scratchvolume','005ac706fad64071a6cfe07bf29a7242-osdisk','7d9e6c2e3df8497bbf43b12669d33585-osdisk','78d53ec714324254aadd77be9702f82f-osdisk','63657ab4d59048d6bf6af7902528633a-osdisk','6e263bfa81b44ed6b9a8dde651100f52-osdisk','a43af8943a434ed1b2dc5399a41d213d-0-scratchvolume','53dd504c3210483580eb775a5122e876-containerrootvolume','d32b0d38f1eb4d01a7641bf8b86fe863-0-scratchvolume','133879d076674974970476df539157f3-0-scratchvolume','1dda31323df44c75b0fb3ddea73e8e5a-containerrootvolume','1ee3a24ca48348cebf65919230480055-containerrootvolume','dd153029bedc43bda62c33b6bb5d33a3-0-scratchvolume','80d8d7e78a3b44f993da4a56c3f6a362-containerrootvolume','7cd4fbd72c2f4c7ab00b8d3471ef66d0-containerrootvolume','d0266d262de24f47b1a7d0142d2ff339-0-scratchvolume','2c434f1936054394a8df6996abc61ea8-containerrootvolume','6e53282c13be496582f60df2df310e0d-osdisk','22ba278c29a7403481ff0db6385c2755-containerrootvolume','ceb875f4b208484da9ae29510b7008ed-containerrootvolume','127d8c4bdfdc44618dccf679bcbc5e1e-containerrootvolume','456c303a718e4b278d8e5c9214c50c84-osdisk','0c26c8c7ea5c4a39a3a0b7fee85a649a-osdisk','a0c6a5bb714b4d118be51d6b6b059b2b-0-scratchvolume','7ef01b70ae2547269eaba6ef48743cfe-osdisk','9cce05b5a4414ff89a678f9a795341e2-0-scratchvolume','d6c6a4e513ff429a8fc6d754fa1434fa-0-scratchvolume','68fe0f18d37445f6b79c8747ca815974-0-scratchvolume','bf9d5978ae04427d95b4d4f3459a4af2-0-scratchvolume','7a00ff70f6e443c3bd0b91486d6f9b23-containerrootvolume','3bd4b70eb74e41ed9298af5f0266c6f0-osdisk','23e44ab4b1a640d7975532e5b2285491-0-scratchvolume','2571cbd60ee040c08cf6b45618eb4f59-osdisk','5351979c975e411992b4b74ac1f03eae-0-scratchvolume','892ecc3b2e5c4e2192bc0a53d96a4da6-0-scratchvolume','e8838a7b88e641828949e8d9a6e3faf5-osdisk','ef3ed8aac68e43c48e7e1e41a040aadb-containerrootvolume','ca67c5c92e794da3af4aaf7788c54408-containerrootvolume','812813f94b0a4833882097588bdb044c-0-scratchvolume','6e6c7c511afc4ea99624bccc43eb720a-0-scratchvolume','3b695e4b82c04892be5f544c7be4d793-osdisk','9db97ba2dfee4928b45b7e179227e576-containerrootvolume','e95a87ae77ce43dcaf8eb8f00177b968-containerrootvolume','8b98fa3fb6f74a37a5d3ae4340db54b6-0-scratchvolume','2105e91c70d9457bb4316afd6ee45bca-0-scratchvolume','bd0668e7471f4b3297919468eda9ee81-containerrootvolume','bd0668e7471f4b3297919468eda9ee81-osdisk','89ceac44af904900ad5ba50e707273f2-0-scratchvolume','6a89f8d4f5694632ac5cd95f18421e54-0-scratchvolume','683b8170d5f541b3814fc83c446b087a-osdisk','58c7990444c044e6a8a0a6ea8f9f9887-osdisk','39da0e2ad5634ba18be43408f990f403-containerrootvolume','f358040c73074be380053a867d005755-0-scratchvolume','f358040c73074be380053a867d005755-osdisk','69f5b535670e44fcbd973db40c4f9496-containerrootvolume','5c9a487ae64849e9a9b99280ebe1f794-osdisk','02f0727e1a254acc96326b90d30f4954-containerrootvolume','62f68fd625a04e17bc5d2b55b89ef59f-osdisk','0cf89fe7a45a47c896c10f72890e168f-0-scratchvolume','2461bc0a1fdd49eeaddb93b792ba6945-0-scratchvolume','2461bc0a1fdd49eeaddb93b792ba6945-containerrootvolume','a8b973d757654c54bef7ab7e548205fb-containerrootvolume','d9d6539fb52944459aa9314ff477e2b5-containerrootvolume','827888645fbd40c28615ed45a23b22a2-osdisk','fd6f77ab2f10422da3d4fe58a5a27e16-containerrootvolume','5adde8c9906b420a9471578f0438b38b-0-scratchvolume','91008f610e294544abfe39253f4c3913-osdisk','74a6b383436f438e8fbea0b9b9ce9dc7-osdisk','792be483481447abbfd0d61e89dab2af-containerrootvolume','05e325cdb43143249a78e6b7c40cce2a-osdisk','7be3a654589947e5be6ed597590aa8e8-containerrootvolume','5ef51275c90a4be6887dc569381dcaa7-containerrootvolume','279edcab64044053acbda2e2f503325c-osdisk','cec476d5892041e1bc2395ca93a1b261-osdisk','32c09e9161884cc9b86d67494fe0f983-0-scratchvolume','942b58b7cad54f2581ff0a039b0ec058-osdisk','6e9c904be7be4bfcbdcd78ce89f8f941-containerrootvolume','ca43b5adab6448d3ad39198a003142f5-containerrootvolume','e11ac4f94c4b4326a5d9dd4cbca604af-osdisk','86ec4d99297e41e7a4f1262089ecf567-containerrootvolume','53c07d4aa80c43d1a19fc7d23d45deee-0-scratchvolume','1a388f040d804317b754add71644159e-osdisk','033a1914f0864012b9f78e156868ae37-containerrootvolume','950946e2570c43a99b9d43d1f8de11a2-containerrootvolume','7c22c3b14e7241cd936937517a39554a-osdisk','aeae856f86924f9ea414bfee81a3d3aa-0-scratchvolume','16699c278a184ee2992d10f03f0a08cf-0-scratchvolume','860162a99afd4d8cb86e54d5dea09148-osdisk','1ff47918431749d38cb0f1721362de14-0-scratchvolume','bc4c0ab73d6c447081dc35265dde7da2-containerrootvolume','ae83de0c152b4a1887c3389d7a095c94-0-scratchvolume','d80ca68158e14e23ac5e8622b0931676-containerrootvolume','5a3d5a784d074ccbb1745f32ff96f7b6-containerrootvolume','5a3d5a784d074ccbb1745f32ff96f7b6-osdisk','33135a446b0345568dc5b2809118e983-0-scratchvolume','ce7da0d0552447a5bad9921fd90b273d-0-scratchvolume','ce7da0d0552447a5bad9921fd90b273d-containerrootvolume','a696f5c20c7d453aa76033d89c3d01ad-containerrootvolume','613d1b697fe2480e96cc745280206ca6-osdisk','f8c3bfcb83c24e47b1f05ca82c453d19-osdisk','891f3454062b491aa7dd648dec2a451e-containerrootvolume','0abc45a51e644a6db4ebd2b2c61d5e0b-containerrootvolume','40c80043ed4c4063bfa869c6724b07b1-containerrootvolume','58b9e4adbe934603a20b3836b99d729b-0-scratchvolume','ff67163b302e456da689bda82a60579e-containerrootvolume','4293b520ef6f4391840057ecb0c46da6-containerrootvolume','e8d87f829c5d4bbfbbdd01f710087a04-0-scratchvolume','aa74aa3d6e7f46c1a951a3886a869195-containerrootvolume','e5f4c0b611424c4d9c6694e2af8ee9fc-containerrootvolume','c287fd84de53474f9fa5fa0be30fae88-osdisk','824dbfda181b4cd6919209672e386aea-osdisk','9f96500a487646e192e67394abaa3d0b-0-scratchvolume','39d94380547346d38e72f3d06a0e889c-containerrootvolume','01711a3cae804169b61ae49b9d6f71c9-0-scratchvolume','58d9dc607fa64301b7296ab2a423dfe2-osdisk','0d261260bbca427abc7f285cb8bd56d9-containerrootvolume','fdc62c1f0f7b40e9b3594fdbb517147f-containerrootvolume','803d61df10824e36b840694e3201f0d6-osdisk','f624cfa78f3d4954b87d685230cf08b1-containerrootvolume','4933a3af9a664eb4a870c7955b9e9895-containerrootvolume','222496f9748a443cb4a8b828d40a9cc8-containerrootvolume','40b542a2dda34832b414f250c01f190f-0-scratchvolume','7b90d7c6e6f14e7bae1c0479052fc52d-containerrootvolume','fc3d1a8b8f294cc39ad9fdb7465d50a1-osdisk','d05881bc8a644cdaa58cf86a3fa5999d-containerrootvolume','ed0f7d02be4449c387446619eb192dd1-0-scratchvolume','c4f7c49912cb4f96953e62d65e9d49e9-containerrootvolume','d9a69509e92f4f69bf374f6384d37c3f-containerrootvolume','7526f93cc0fa426cb0da947661847b83-containerrootvolume','bb0bda2b766a463faecf2aa41d4b13f3-osdisk','7366683819bd4693a865c3acbe0292e9-0-scratchvolume','bb2b8a30881c43499a5bf739d2656081-0-scratchvolume','39b7090b3a1c4c679be02176788fbc29-containerrootvolume','21c2ca3456d847c88298fe362e3b33d6-containerrootvolume','06f0f9d15b544f5abf923f68bfc750ec-osdisk','6d2f25269597421a8153f51106a60ba9-containerrootvolume','b12ab5cfb6a54031a0550b9ca6d6807c-containerrootvolume','6040d9cb91c34dd1983edb273c090ab5-0-scratchvolume','2957f8ac6df74210b5b3a0e568896a30-containerrootvolume','6857e54e5733420893f5001506f81f91-containerrootvolume','9d9ac3e0ec8d48ae9b43f32c3c2f203c-containerrootvolume','d9d128e87d884d7f98d14240094b0f91-0-scratchvolume','f15f7b82f4834ff18fb3732bbd3c5150-osdisk','499b4bab094840db8766c2464102ca5e-containerrootvolume','7b4ab35003a14fe5bef0a9399bde7e12-containerrootvolume','13d9ca1d549e416b82615b3cdc4869af-0-scratchvolume','3a6cf3b014ea42d88d532cb2ae9ff6aa-0-scratchvolume','56c2fde7139842e38a3dcded3360dd6c-osdisk','b198340bd9874c8f8aaf7e8fdd083bdc-containerrootvolume','a3117cf13c0a4a3b9828602713887533-containerrootvolume','66780b29bbbf456eb11f08fe0d1ed0de-0-scratchvolume','0c2edc7dcf2b4f5d9b7df5ee7989cf97-containerrootvolume','507d448311744ed2b42557b4b492dfc5-containerrootvolume','cae082825e124a268ff86352dd322b23-containerrootvolume','cae082825e124a268ff86352dd322b23-osdisk','7f0aaf97d9a24cf7b16d8884c04796ec-osdisk','63ee697d4209457f9ac68d9a16aa6aa8-osdisk','d1db733dd8474aff9f58aea594e68d07-osdisk','a42cb5f05468479fb0f4d3e0605811ce-containerrootvolume','79ab99a54e494157a8ed62633f053002-osdisk','a28acb9933e94eeeb7881c83c504fc67-containerrootvolume','368d5f8f9ec2439abb41923f8bac1709-containerrootvolume','179f20f9eda6493f8ce61c88d4c31a31-containerrootvolume','db99578fe0154e88a56039a80edd53fc-osdisk','36d4b99095204041805f3ee1f45fbf3a-containerrootvolume','d3e8980b449c441eb28cacbb8d478744-osdisk','873a3f1208234c83b5c3010b30a6c955-osdisk','2c573fe4d32b41679921d900c1eca34d-containerrootvolume','1b2ffccc5d02464fb8528d5d5d791c02-containerrootvolume','3a39bf0bc5244559989c25b806f89a45-0-scratchvolume','f13eed28416048699a399dd936dac037-containerrootvolume','f13eed28416048699a399dd936dac037-0-scratchvolume','f0fe8a3733e7478c8b3be2722266de26-0-scratchvolume','18d18011409246de9547772fe8996370-osdisk','f10910305c9147478d75d3b0fbb7be37-containerrootvolume','652d0c3c4f6e4dd0b8777982de201f6e-osdisk','a84f2a091b7b4b65bac05f5c971a63a1-osdisk','18bc520d37ba4bf7b644f923d144c373-containerrootvolume','dc387202300141ae8ccbd8f880741d56-0-scratchvolume','d3da762496e94918a9bd68ee8b58245a-osdisk','b03dc44e828a45439b2a03c3009b6827-0-scratchvolume','175a11e87f874cad8fcf8ce21be54b38-osdisk','fb2cb14a0c8f4d07ac7e86f31035c586-0-scratchvolume','3512032f95df4c968b621d98b5dccee5-0-scratchvolume','2ed7c92b682d4dbaa9fa39e06e98f1ea-containerrootvolume','1b0ca120c036493993ab923d2561c204-osdisk','b22437005a734ad882f86b6909704105-osdisk','9cd9601b730f464a91c827f47193fe6c-0-scratchvolume','de6b47668ae34b7fb8649ca22c198385-0-scratchvolume','37c7db3a129b4ffe84153d16c7af742e-containerrootvolume','5d0389ce07d54cf980c6f156f146f7ba-containerrootvolume','515e2e4bdba34fd38f9db8c354ee1d43-0-scratchvolume','daf27a6568a743e18840801e9d275f57-osdisk','c4193222275149e7aeae349999465dda-containerrootvolume','6ef143cef5ee408380166c1ada96f613-osdisk','f63bfdc465864e958931bcb7ccb0c1df-osdisk','eaeafae1fa0b435baaefc06365b9fbba-0-scratchvolume','eaeafae1fa0b435baaefc06365b9fbba-osdisk','76c9131a02fd4453ab8a04230fea2ca1-containerrootvolume','54370977d9584c828565305c15daa380-containerrootvolume','177fa548f28e408dbd28fb4f93c1b35f-osdisk','f1d21d0f0e1d426b96a85bb79ebb7dc0-containerrootvolume','a476eec0bbd64f4d9e809bcec8ada965-0-scratchvolume','224f3c6135954b6aaa8f0a3ea4a14f94-0-scratchvolume','224f3c6135954b6aaa8f0a3ea4a14f94-containerrootvolume','e25087a5c6ca4ecc993b1292255daea7-osdisk','e78b63abdb55482a9add7e967357f6ff-osdisk','4a7a753423204784b7d5fbf6f5d2bc10-osdisk','a948ddf1ab434a5e9ba62f44884cde39-0-scratchvolume','3a9dc6e06a1f4a88b7843aaeba087d2d-containerrootvolume','d88eb8d5538f4064aea2bd1e992f1abb-containerrootvolume','d88eb8d5538f4064aea2bd1e992f1abb-0-scratchvolume','419e5f52a59f44779d791991151918ee-containerrootvolume','0412a6b663544791a5382c393bbe5e87-containerrootvolume','b972c75e36e646e099680e6540806f1e-containerrootvolume','f7ab1fcbd54441a1a293d3cb5c4a3e42-0-scratchvolume','431ab69730754708ba40a0e324b6bdc0-containerrootvolume','4120cf0d35c64a3db54778cba07398e0-containerrootvolume','1f577a7ddff8470ea62c37d08ad77d1b-containerrootvolume','672b0e82722a4ce2b2cbcf82f421dd22-containerrootvolume','d2dbac512fe44b988cbf73e6fa195e71-osdisk','1ef5e1988ff448bbb028afb77fae17d3-0-scratchvolume','705b42ed52ca44c680190b5013d41bd3-containerrootvolume','6b75da894c76419e9ae6afe65834c04e-osdisk','4d70048a3e2949c98684c549887e403b-0-scratchvolume','6871ac0ef1434163877a9a180e3750d9-osdisk','b7c188a287e9442a98710de76fcf7163-containerrootvolume','de0216a2f2494fa6ba824d8c0e23b1af-containerrootvolume','f50304972ccf4bbc995dffa9ebf4195a-containerrootvolume','f50304972ccf4bbc995dffa9ebf4195a-osdisk','ce7b37efbd3845d7bbac7bae660c90e0-containerrootvolume','a605e6b905384ff0b0402491b219eb0c-containerrootvolume','c2d1db6a610141e687bfda845bfaf923-osdisk','9cd459f9d3fb443f95b8d13116cf813b-osdisk','b5fdfe098f544756b7d367e599830a36-osdisk','56e8c4ce50c9446692fb533cc7a96138-containerrootvolume','f3116654d4f747588849f1bc0ea525b4-containerrootvolume','f3116654d4f747588849f1bc0ea525b4-0-scratchvolume','b0881e06b1244881ba1dda29d4f6407d-containerrootvolume','f3c7e3c3d8364216b467e1de50fc75f6-osdisk','93bee7c087a34e5caa5d71bfbe87681f-containerrootvolume','e9ae363a7bab4871954b0a61bac72dd2-containerrootvolume','0347fd456b7e42cfb6c42084d059ab99-osdisk','91f938c37d314588906a5428b35ef451-containerrootvolume','338b0d0b5f3e4aaf967b6c4d3d30751d-osdisk','b6fe7d055f964f77b9d67ede9000122e-osdisk','9138fda34e984502bcaf0e05108880ff-osdisk','132c6c10ffab4eeda2ffe3c15a52c2b5-containerrootvolume','beac05912f894564a27901327d7c6eb4-0-scratchvolume','1ade18ac6964479c8faacbfa60bfea19-osdisk','ceafb559b23c4c0cb774052b11268d28-osdisk','5c3ae8aeb4e94a04b3b469b843bc1095-containerrootvolume','5981499bb25345ef871cf4bee5cb7652-0-scratchvolume','810e3f8662b24f71bb08be8e30d25428-containerrootvolume','21fc950924154ca2b93570f50d4a2ade-0-scratchvolume','27165dc583b24310b63e3d79ddc99216-0-scratchvolume','0e5cdac6e47341518af63ab82a629e21-containerrootvolume','0e5cdac6e47341518af63ab82a629e21-osdisk','8c2f17685b23452ba413c08e65ffd416-containerrootvolume','e59b313e0f464ae3a45bffdfafc5d615-0-scratchvolume','9668ac0d6a74496c9add87ddde8d82c5-osdisk','1f7d6a49c82d44a4b6e9e7a90bd4d062-osdisk','6ea0492780fe4aaabdcf010f6bc198a2-containerrootvolume','2f490eb29101454c94a9b9d18d90a62b-0-scratchvolume','263d191033b349e7bcaef9b56554b9b5-containerrootvolume','a2b4a9bcc2b94882ad6c29bb1e260d89-containerrootvolume','2c61b424ef334718a7ef5c2699d083d3-0-scratchvolume','447a4f1274ba4485a8ccbb9588f2b089-containerrootvolume','de2b8c3ab7ad414698aece2d5b6b4ef6-0-scratchvolume','e3d2cb301dae471b8b24df2f28f5928b-0-scratchvolume','e3d2cb301dae471b8b24df2f28f5928b-osdisk','6915460d9c9441eeac1dc5232ec02120-containerrootvolume','6915460d9c9441eeac1dc5232ec02120-osdisk','b254f13cff9f4c49a9e0efd6e5491234-containerrootvolume','4e6566abc50f483284f1712db5cb11ac-0-scratchvolume','f49a324a79504969a1a7d42f135791bf-osdisk','7956f3c11ed44caca1965ba935c03f78-osdisk','940c94d4c42b47af862c221c6e93bdd1-0-scratchvolume','c3411554d5fa4712a243e90a56974a37-0-scratchvolume','c606a959b1ef4295849c47110c7113a9-containerrootvolume','b450086cc54840dcae025622d32b1e08-0-scratchvolume','93a9b635b0264af884182ae1dec7f6a6-containerrootvolume','9a732ad008a9480683647deaa25d1eb6-containerrootvolume','6fdf9b83827343f08bc36b28b293877c-0-scratchvolume','c149445ea0384b2b85f9a805b3cf9f48-osdisk','2355fe66cf9f402897769241e2af6d5f-containerrootvolume','a32d5771763d4bac97a09881013a92d7-osdisk','6f65b02b5adc481ba356eed5a948bed1-containerrootvolume','5222d806b5a247ea8c03dcec9e7ff89e-osdisk','1456c9298d484c34aa2f37cbf59f435d-osdisk','c7d45d95c5804ba0a01a387a9083ea40-containerrootvolume','deadc6a69557490abdcd204cee083f09-0-scratchvolume','7ab45f45c0ac41cd8d1d28fee1b2d1d1-0-scratchvolume','4102d62643db47ae97a27a6411638942-osdisk','d9eb53d0f5e547ea88385a94d0cd61a7-0-scratchvolume','8a9f7bd775954e2587190ef18091f79d-containerrootvolume','89a42785e0da41a88162fdfad4bac034-osdisk','c39704f44fba421e9ca748789dd6bfdb-osdisk','1ef159164b2b4543a3bfeab836f9c128-containerrootvolume','196922f7dab749f68e42f9fa72d799fd-0-scratchvolume','aea2f848451f4c58a516f8c7295d6663-osdisk','e636657918bf4b798006bbc54e88042a-0-scratchvolume','513f6896da4841bca9b75eede3b99887-0-scratchvolume','d6b787593c2849fbb88d645485a2824d-0-scratchvolume','2950a8950e634b48ac4f56c9f3166612-osdisk','f372ae9beff44d71a060d9db14d575b2-osdisk','357199eb506f4f2f8ef9b272c4c89fbf-0-scratchvolume','0a73bb5b7760420396f9af39fb4cdabb-containerrootvolume','77c0bd8dc7b54ef589776e1ad22cca79-0-scratchvolume','2940ae08bb144befaac70f7aea8e3407-containerrootvolume','4b98f19f2a8f41c3b78afa0181054f96-containerrootvolume','d5a42eab22f2404588106bba3c3a409d-containerrootvolume','b07ed8f35eb640d49fa9a021e372b5ef-containerrootvolume','bfb0dc692f5d4b1492b21e02e216321d-containerrootvolume','3395179929834145a1ac4b5b23eef77f-0-scratchvolume','2a553f6873964518a2058b3d0310e715-0-scratchvolume','6df5283c17be46a8841953b7d2fbac86-osdisk','3301f86356314603ac03a010f6dbb627-osdisk','d0119048e761444fb363927af8c6c5a3-osdisk','0496598271a04a39963a9f29bf05b433-containerrootvolume','7db46d43dcb74cb0837493bacb1d4275-containerrootvolume','e61c308a29bc4faf9e8d971204cf23cd-containerrootvolume','b4ce73e959ea4c7cbf7ef7ffd6c7deff-osdisk','0e8dd80d4405413b8bcf605f32d5911d-osdisk','a537e4b052654b8bb93c3ae267760417-osdisk','68a2535f4bba4b31a238d57161a45f78-containerrootvolume','3ad40e019838408686d71f2ac10430a6-osdisk','9eda5fe37730420eb9cea570e0536e62-0-scratchvolume','0deb50dbaa504d60956983283fdab684-osdisk','f5d2425b8de44803b11b78e201f5fc03-0-scratchvolume','f5d2425b8de44803b11b78e201f5fc03-osdisk','7f47b1ccbd20424dae592886e0749841-osdisk','472d995d91fe475da17cc0bc1db5d6a3-osdisk','f148ddaaae8c48538af14a4b6ce987e6-osdisk','073994cf9fb1474781922e45d8aa727a-0-scratchvolume','eed3db334ed845a8ab45d419f853c011-containerrootvolume','eed3db334ed845a8ab45d419f853c011-0-scratchvolume','07ebb685943a4fb39cb951c99bcd0436-0-scratchvolume','e6019dcda81b459bbed7c18ef22047c5-osdisk','829ccf2be7fe4aaabddb7d33d2a60471-containerrootvolume','444b07e3f9194b16883e248ef8874416-containerrootvolume','444b07e3f9194b16883e248ef8874416-osdisk','b91d4c4307644a02b39f138eb83456e4-containerrootvolume','cad770709bec49cfa1e596ba0de04569-containerrootvolume','9f32184f1e8f4e4ca0179b93522a1861-containerrootvolume','26aa34ad81ce4e78b7f2e7c7b796f184-osdisk','c5ac3d2813714444b172babd0474409e-0-scratchvolume','b6617aca3d3e48dabde300cb0992881a-0-scratchvolume','b460c42b04c54f568c623ef96230fdaf-0-scratchvolume','b460c42b04c54f568c623ef96230fdaf-containerrootvolume','baaa13a0c442488eb0da73c1d189961b-0-scratchvolume','17a05b16a8114a2b802ad97bff6bbd37-containerrootvolume','70d44df8504c44a480e69e42f4b88616-containerrootvolume','4d36e73dad904baa8f2b78aa1bb63bd5-containerrootvolume','fb09cbd4f7864b48b145e753b7d89853-0-scratchvolume','dcf48613c3b9407aa4e01af5af91f586-osdisk','a33ffcc3fd7e4ab9b59b60bd7b772bde-0-scratchvolume','e07bbfd099944939a46183de3e4b94f9-containerrootvolume','09fe83c9ace6431abd1ab48685dd1cec-0-scratchvolume','75377bbe1a6d47cfbb4ecbb0f1fe418f-containerrootvolume','09f5d7c935b243b19cdcba5fdc8dffba-containerrootvolume','592674ad0b5e4609972f47d29a6de696-0-scratchvolume','8e9be1cdac44485ca34a82ca7d5dc1a9-osdisk','1c1a8c53346a4123831dfbcebf7d39c9-containerrootvolume','1c1a8c53346a4123831dfbcebf7d39c9-0-scratchvolume','25adca32b162416ea213f8c8132484f0-containerrootvolume','8271752293f9492b9e9e674a29718423-0-scratchvolume','514004a43e5d45e6825ec87d8d1b6419-osdisk','2149c22495614257b76d5c2e0a905d87-osdisk','233fb54d945941a6a7b8fa241905138c-0-scratchvolume','f2614a814f364d12ae5c31b2d0e35cd6-0-scratchvolume','3c7aaafaefe64d76b046d8ff2880e02d-osdisk','5146c0dc4ed145fc83bdd1ee5465251b-osdisk','0b1e21d5276d46beb2ae752619590887-osdisk','61292e79bdbd4fcba8954c8aa9df6c5e-osdisk','f2d5c66efb1f4869bc2053604669458d-osdisk','396794bf551a44c8aa48a8f1499429d5-0-scratchvolume','845160b96fec40da887fc2ffb6fe3c1a-containerrootvolume','6bf27f7621aa416e9e07939e91420f5d-containerrootvolume','713165fba547442a91099be95e4175d9-osdisk','b5f1e7ed15814b9f964b786bf21daa29-osdisk','0a39cf4bce144a2e825d4d1932236572-osdisk','6bb689da108f4ba8be1d3709f392e496-osdisk','a5256e3841a94eadb48e45d80408d887-0-scratchvolume','53b9fc93e41c4cd780d5e856eff67e4e-0-scratchvolume','49fdcbdd4a6d4335b0d7831c4bfea823-osdisk','b0b3a2bd8532453eab381ba61a988f0c-containerrootvolume','4ddf8b7ee8b1426193def49bdc0fb3d5-osdisk','b9406c48cc044986a2f16713a74cdd16-0-scratchvolume','9bef82b5d03c418c8b0eef3e8097e4f0-osdisk','728bc1e70b664699b882cfa8d408cf0c-0-scratchvolume','759e10bb706448c8a27fb09aad078ce8-containerrootvolume','08d55f0b32774d599e77a1b661fbbb09-osdisk','231f9f602f2d4d83b2991784098e4f82-0-scratchvolume','8c0a900e5ed1467d90384962ee8403d1-containerrootvolume','18b9c44404f84baea47ce5f0978039ca-containerrootvolume','4226209c30e44ac6b13501bf46ec31d3-0-scratchvolume','8a17e4631ae04ae4a07c50e66f407f24-0-scratchvolume','2bd629a5d04441e8834693535ec18e50-0-scratchvolume','ac4c078a80f14612bcc9be39e5492067-0-scratchvolume','31e8f9c25fce4dc1995c85594ed61d46-osdisk','d05bf43cf64b493fac935d32515c4dcf-containerrootvolume','d05bf43cf64b493fac935d32515c4dcf-osdisk','d0528b0fbe8e40cdb521c5275ca6db7a-containerrootvolume','d172c1a2c5e74b748abd5bba571bbb50-osdisk','777f372700654540beb03d5d04495af3-osdisk','aa32909ec3df4eb5a0f8c08f0e1a03c9-osdisk','405c36687cdd4b5a93dfefb2488fbc1f-containerrootvolume','d7c7e5f426a94b7985cd34684edfbd6f-containerrootvolume','2618fe177738461bb52a239f2c652bf9-0-scratchvolume','5d0a8e2759bf4965b2226a1d34b4ba05-osdisk','ba751690ee044234ba9e3821499511d1-0-scratchvolume','ba751690ee044234ba9e3821499511d1-containerrootvolume','db4cf788f98949abbcbc2bc9f66cc40a-0-scratchvolume','7ae6ea7deae748279283a9c61a9de452-osdisk','e524e627087b442ba07d71d23d99e6ad-osdisk','9ffbaf5a466e482ca1e8847cfa9efbcb-containerrootvolume','119c5780aaff4155b79ff73d0bce6932-osdisk','d3d5fafdbd63456d99d9b9e5bd7df3ee-containerrootvolume','d3d5fafdbd63456d99d9b9e5bd7df3ee-osdisk','638462e4e19241f08a3f2695ccc88736-containerrootvolume','fe9a968e55d04192b68b8b46130b8acc-osdisk','449d32d27a964379bc495dc8ab2ff72d-0-scratchvolume','b294270441714389b4e4cd1568acf68f-containerrootvolume','97da1903a33c444c93c2125fe40305cb-0-scratchvolume','ed4bdcc3c6e1427897e040c23c761703-containerrootvolume','a871148a1649446f8ebbab1375e840c0-containerrootvolume','2e36a116b2e94fde8082a08afa96f5b4-0-scratchvolume','aa2fd01543f2410c8fcdbf440363598b-containerrootvolume','59af0832bb7649e69aa8fda4d7281b5a-containerrootvolume','f673df21dade4ee2845e8e0d27f51acd-osdisk','ce50369417c6430dafc1ace30512472b-containerrootvolume','ba69d94189a348629777180cae66e7d4-0-scratchvolume','805d3eec826f4686a8fb5d307a51f1ed-osdisk','8cf648c8d1d1486abfb0a2443d565b1b-containerrootvolume','ce480f45a0a749d5a60e3a46fd43d476-osdisk','bae03ede1d2044a69d0e7852976b7b3e-containerrootvolume','7dee2327e3c14c5fb208bcfe80c2d503-0-scratchvolume','9b1b3a0bb71c4ad289989d7f56170fde-containerrootvolume','9b1b3a0bb71c4ad289989d7f56170fde-0-scratchvolume','aa107cb5e2934e11981d2d5f7ac532af-osdisk','a180ae200a2d4c54b54652fed3a8ad1f-0-scratchvolume','21dcc99ad36943bf98f55bfd70911c46-0-scratchvolume','3761f02074b545cfa60413f35799d6af-osdisk','5c445b64fc054cccbb159e3c4bab8870-containerrootvolume','cdf0b3607867498dbac00b9f222ed704-0-scratchvolume','0d64b09f72074c5f8ca86571c7d41098-0-scratchvolume','029313a8f40f455fbf19417a83e3454b-containerrootvolume','1af532d234ad4ae7adda6e8dfcb0d94f-0-scratchvolume','b270c3ebcf024459b4c0495e7db73ade-containerrootvolume','64ca5d1617a8482ba9c85f0c247525ae-0-scratchvolume','e62cd57c830e457cb7daac2265c6e91a-containerrootvolume','0c404aaafcd549bc9f97e29437f1d56f-containerrootvolume','0c404aaafcd549bc9f97e29437f1d56f-0-scratchvolume','46e32b2569124ec39208655e524b3e65-containerrootvolume','d0d8b46497fb4032b29f0ad3eb8749dd-osdisk','6889a7967ebf48609c3daece6eb5421d-containerrootvolume','ee07e7ae11f546cc9296aaf49949d371-osdisk','d698b3aebb2d411386b047292cbf9cb6-0-scratchvolume','c25d673c830b41a191ad863f8ae7d8d9-0-scratchvolume','db1caa0b057d47f58e4f8ef9148ba1df-containerrootvolume','d6a924107c024782a3b2330f53c9db29-osdisk','b632528cdaac489b8488271939484ee0-0-scratchvolume','40894266c4ee438f80f6ba43987489f1-containerrootvolume','573a447684514a02b6b1975874250004-osdisk','65cc25569fd04279b09cc7c681cc83ad-osdisk','553eb23c107346cf907779a55cfbf381-containerrootvolume','0066deb9c12c440d94843cb9b3714255-0-scratchvolume','0066deb9c12c440d94843cb9b3714255-containerrootvolume','b956209e357046c99a74a0dc538659e0-0-scratchvolume','8a9fc1fd269f4c1690da4ce369437bc5-0-scratchvolume','fb7635801776453ca3db2be422e2d53b-0-scratchvolume','edc4340ffada4c02b216351d975f18fc-osdisk','d8f43a13d33047948d101537ea6355ee-0-scratchvolume','d8f43a13d33047948d101537ea6355ee-osdisk','a804e40ac9e04686a3dd756f44bfa5f9-containerrootvolume','55615a033fe640a980bf35d767bbbb19-osdisk','ffeead3da34e4405ac271f93376040a3-containerrootvolume','6d4a0546f5814cae987a2914fee85624-containerrootvolume','92a12d53b8fa4475af9e0c5411995988-containerrootvolume','3bcca42ec22349119a5ed4478043cefd-containerrootvolume','d90ad891b28f483fa4d77112f1ff07e9-containerrootvolume','76d8ddd61d2749a2a859c10c543721b7-osdisk','c55963b682bc4525affc5b50f839ebae-osdisk','44968bf97b72487493337acfbc601b39-containerrootvolume','8aaeb3f5240844cbb7a1af3086997874-containerrootvolume','038aff455380408d8e91830eb12e3d98-containerrootvolume','038aff455380408d8e91830eb12e3d98-0-scratchvolume','79df8f66a2ea469a8b27ca59b50b027e-0-scratchvolume','038aff455380408d8e91830eb12e3d98-osdisk','01d0b4d862fd47faa9bb7011bfbdd8e4-osdisk','9052ed3962a84020b9ade88048161c0d-osdisk','c5e5b268b1cd4bd2a906c653c1eccb27-osdisk','e0a47da8df0749d29ed1787fc308bf5f-containerrootvolume','62d752779c0f4de38ab13834b320520c-osdisk','b56ab893bbe54f52b8e0dc4963a94356-containerrootvolume','0dd7282afa4a4cf6b50bfd325c420465-0-scratchvolume','d30278ac00b44a4a896f9066d4a05ccc-containerrootvolume','8be7cb6a0233417e928aa057b0df70ce-containerrootvolume','ddd3a3f729114925bd737beab7a05d32-osdisk','b131040490d145daa539c6542955f5f5-containerrootvolume','b131040490d145daa539c6542955f5f5-osdisk','c31c28370d114d6eab6dfffae14cb724-containerrootvolume','3c44ed8400434126bb4d26c566e85285-containerrootvolume','abe5a93fb5e2492e9e0461db0fef84b4-0-scratchvolume','4fab377e07664aabb8f6f7b8e0c92b44-osdisk','dcaf05a5d8084c3c976e6239a885eb66-containerrootvolume','abf4867420aa4e1cb6d196f65c359912-containerrootvolume','c49853e20b7041bc8a79dc9219210017-containerrootvolume','fa3f6a74895940b7a046b94c19aaadba-containerrootvolume','b9990473f4334513b2b35d3448d304ae-containerrootvolume','f618f90ff530464f9cd9e6a7914ad12e-containerrootvolume','096c9fc1182b4444a063aec3460a98d5-osdisk','6b35a10ce69145cfabc58aed1e2a7429-containerrootvolume','92b47730bedb4b45baf91d98533cb10d-0-scratchvolume','132c8741ac11413b8ed6340020db18fa-0-scratchvolume','a26533e3c1064bc2938b8bf1ec21fc11-containerrootvolume','cccb929c584e4cd2a979685d57f337ad-osdisk','e835eadd94114727b124fff29f1d5080-osdisk','8a698af3b6b146b5b66f9623531c24c5-osdisk','43272ce7dfb64484b7d32afdcfe34c64-containerrootvolume','a199479066a74ccdae87885c7197d993-0-scratchvolume','f1074c58568f4dfe8c14ca5c09e6cce7-osdisk','e620c1bfcd1f4bb19fe1df609872e055-containerrootvolume','e714dc3c85954939b3ebd17535685aec-0-scratchvolume','447529299abd4896b0317a28696034ba-0-scratchvolume','6265b6d20689419cbb0c42d2d239058f-containerrootvolume','5c8c24cbce004125934127888cb82fc3-containerrootvolume','6d646b7ede7d47d5bfec9c6b5ac6d185-0-scratchvolume','b28299edac5a4b798c4987961f2778a9-containerrootvolume','b14d3088e2ca4025a0e5c971ab3a640f-0-scratchvolume','9a14842229944392bd1c34f3d6ef3b27-osdisk','4805c0d9270e47a79a961bbf648d83bc-osdisk','e65d01f28e854b95b63928c02f06155f-0-scratchvolume','8b58140a39644054867dbc4dad75adb7-containerrootvolume','b587114b1648423abd26743924b3d9ca-0-scratchvolume','b71dfa3bc45a4a83be8c66dc55f06b01-osdisk','42e4500ff8bf4350a57453c146f0b742-0-scratchvolume','df23924dfd1f47638bfe1ceae0e2e5bb-containerrootvolume','d94f7c73c6df443d8bd7eca67e3a2878-0-scratchvolume','e1654b5576f34843b265b0bd43fafe8a-containerrootvolume','e1654b5576f34843b265b0bd43fafe8a-osdisk','d23384cf951547f2a294169dfb03cda1-containerrootvolume','514932948a384c898173f47437adc40e-containerrootvolume','414e12352ddb41e2b44938970267e4c9-0-scratchvolume','e42c2325ec1448e182c69b0c5a8717d5-osdisk','5d85ff89c1e44df4962802266560b0b1-containerrootvolume','22d32018ba4d4b219614997bfff01888-0-scratchvolume','0aff35981e5a436fb0f81e1380861548-containerrootvolume','25e9aae11fac496f9ab8b0bfa22f2356-0-scratchvolume','db694374abd3432680bdcefa4461ba7a-osdisk','eff2516001ee49a6876f175fde38c0d4-0-scratchvolume','601a43a726c146218e9519af9d62477e-containerrootvolume','f2ab4ad3702b42c9a94d61e7cfa4a6b6-containerrootvolume','9945dafaa10341aba35e571abce5c856-containerrootvolume','88eeb43d856442db8edb6b242be47d33-osdisk','9979389785a545b4b7106b5421fd5aaa-osdisk','eb26a691e7dc434c9bd321ee3372f3e7-0-scratchvolume','13fb62a78ba04e8f89207ae90c82ee9a-osdisk','87c89be16ed74acb90ec64a448f48eef-0-scratchvolume','45b182825b224242b3311ce2fa1e2f8d-containerrootvolume','27801b9fcb314d9085be8f8e8d65fc50-osdisk','d89e55d7df5747d69c37c9050fa88a8e-0-scratchvolume','d89e55d7df5747d69c37c9050fa88a8e-containerrootvolume','f5aff23f6695490dbdd360b2c52b09a0-containerrootvolume','305a357a13bb4205990979d355345d6f-containerrootvolume','8838bdb043854513a135a679e03514e5-0-scratchvolume','b1b124c016254920914bd99398873780-osdisk','477a230980ec4a4ea7ebdf5048910c28-0-scratchvolume','f1963e6a4eb34e6ea9eef67b270902a1-osdisk','d5b87ba5e1334512a9e447a90c93a44a-containerrootvolume','5439887f4a6347acb44837dde519f888-osdisk','096f9c1f75024a7299f2c731c381e084-0-scratchvolume','dacc567849674ff78798b8c406c8d25e-containerrootvolume','2eb310a4aad34783bac4f38f804a6e2a-osdisk','bb6ca51998f24ba3a499e5dc6c21b70f-0-scratchvolume','16eec8c2a1dd485390692735514b7d50-containerrootvolume','40d030b7957c46908d85b0128b1e5acc-osdisk','86beed77e6924cddb3930151fd57e426-containerrootvolume','0cf651017cfb44d1ae1f0ba10559c5f4-osdisk','25232032a4e04c3a96f00f7b969be428-0-scratchvolume','ff510e1fd2b04a0d9f8d9bf1151815ff-osdisk','a9f07da83fc948b1b220453868b2e8ff-osdisk','ac1af16305d24e5fa05717e6543c6f18-osdisk','c6b0c66324584566a9ad392fa9841950-containerrootvolume','ff3317b6ec62463596f993b51ad1523f-containerrootvolume','71f7ecaac3b44db08c79d45304d7e75a-osdisk','5f536b5e1b654919963e6615cf68205d-osdisk','1d6abf890c704242b3eed43a74167fe0-0-scratchvolume','c3ad295d4a61481994b5c78777c3f88d-containerrootvolume','8ac0d3d5b8c444f494dc2d63fc31deb7-0-scratchvolume','1f9eec91c67b439db7485ceb2ffc8124-containerrootvolume','09e5139e04304c5fa22876df1541ad2c-containerrootvolume','ce2a5f8a0c644b298e64c5770ef50d49-0-scratchvolume','a9b8ed592fde47d190e33f0e09786049-containerrootvolume','72c5fa3b854640e08a20f75c17e2050f-osdisk','a43318e623c643bfa1697f9d92ec1085-osdisk','f47dfd9822df4f0394e6adac6f04d116-0-scratchvolume','b6b2b9b1e5f947d2a9a77b57d2efafc9-containerrootvolume','e321b7a4f132456f888ea31bb99127cb-hoihd-scratchvolume','0549f6a098b14a3b8fec0b72a523be61-containerrootvolume','392b81e859374b28b0a11c0afc7894ef-containerrootvolume','2741818f220e453bbc38912f1c4db10d-0-scratchvolume','c5021156fb0344ee907f31cdeec3a877-containerrootvolume','091f7fd76998463593cd8f2093a53290-0-scratchvolume','4ea01ab7a103410cb2803c8606a614fe-containerrootvolume','73a85c96db1d40628be7a1c558995203-containerrootvolume','463572e22add4560b1796f2368857cdf-containerrootvolume','2c4e6f904931425683bfc83d28da5f3f-containerrootvolume','5b573c3fc428446e816d64887e03f996-osdisk','34a163fb11a64b1ea4047edc6409701c-0-scratchvolume','0fd41823a5914a6d9277b066bcb3cb0d-0-scratchvolume','b62fe93b010e434a9be69471567d81fe-osdisk','e45756f11b9d49a28e8add6d507947af-osdisk','b330b42bf52f4506b1a4c41b9a5d461f-0-scratchvolume','53b75037fa2446f99b9b10940d6e87d0-0-scratchvolume','300c4ae9fcfe482aaac7a86623ff3b58-0-scratchvolume','1c38b22b3e934d0a98388b47421a9238-osdisk','82778c60c7e74dac8155031317df0536-osdisk','acfbea8a019949ff8cf6795b7bd02bc3-0-scratchvolume','acfbea8a019949ff8cf6795b7bd02bc3-osdisk','b04ad610da934553a943ba58aaaa6898-osdisk','79c2570f08f540ae9a80046b98a1cc2a-containerrootvolume','59ca670b710f486598a908d79f98b659-containerrootvolume','cc27177802e24519b2abf696ddd93959-osdisk','799fde4113b24687ba86df51a9527654-osdisk','501bb52beff14b7fbdec4fd28ccfe056-containerrootvolume','035403fdb812455b8826f3970fefc10d-containerrootvolume','82b56460c4c545b5b0634e1e67f4e598-0-scratchvolume','64849e9008a74e35b488bf71927cac71-containerrootvolume','9e6c06880e874af691776e0994476ade-0-scratchvolume','1122fcaed8bd4f56b62398f7ea9cbc52-containerrootvolume','7a0965091afa4550947a4e7810ff74a7-0-scratchvolume','295b68c8a74d47a4ab5ff8fb8c5a69d5-0-scratchvolume','8d869d989707441cb81dc706fb1a2db7-containerrootvolume','def30a6f04a34ae890745e6e97e56b7a-containerrootvolume','2d10bfa02c104adc978bee6d0367c15c-containerrootvolume','c6b847021bb340119ea17f0883e2da14-osdisk','38c1ffa2ebb14dd186c4be8988c3b93f-containerrootvolume','fc6cc0650aec409ab35dba61569075d1-osdisk','009f6779801c4ed6af49e4ce600eedeb-containerrootvolume','399864ec31b848d0a96568483aa2380e-containerrootvolume','d6ec34abca8247979eb56bb5226a4dab-osdisk','8bfc54c574144208aa50578f65ea33e2-0-scratchvolume','90b00ef3492d48068165ddd62102b560-osdisk','93792119276b4523b136987a97cd79ac-0-scratchvolume','a877526dfd9342a48c0a2380b7427ba6-containerrootvolume','cb67d3f9edfc44e8aaf1227fa4cedb26-0-scratchvolume','cef74b66b6c1443eae029f75b6ee74b6-osdisk','06da0098ac354129898ff3992d35989e-containerrootvolume','19b403677e2e4624a4c56cb53c7c52a7-osdisk','0caec5c73e274c2b9af50f7cb281dd85-osdisk','e0affe3e05434ef0a699ed82cb01cda2-containerrootvolume','90f724e40981406e94e4939dc9e16e94-osdisk','7df12ad8237c45b9a724f8d3d1ab9ca6-osdisk','f3db9de1d3d74aeebbabf49168cdbd28-0-scratchvolume','d44b97ae9ed64aef8f82201826678940-osdisk','8fa80e09545546c1a9fff706a5247ace-0-scratchvolume','a722d4809d1c4f90b600617a8ce53808-osdisk','2ce065dbae524b12b7195513c837001e-0-scratchvolume','2ce065dbae524b12b7195513c837001e-containerrootvolume','d7c3db5f03404278936b8807894d8ed4-0-scratchvolume','94aa8510db094c3380d4fb06ea201484-0-scratchvolume','7ae1f7e2dd664347b1830145c4905fe9-osdisk','dda8f6bc20df46d1b6bf5dc00ed9c89c-containerrootvolume','a3e3e5b9508745768ae05a756e348a65-0-scratchvolume','71e8fa2538cf4104a5e5239838da18af-containerrootvolume','6a760bc93d1f4ab8b10e63a394ca9a14-0-scratchvolume','d7d222f604a64572a764f198d6191761-0-scratchvolume','df217a0232364699a42d1931232d1ed3-containerrootvolume','37ec6793b0444e2a9b5affd872455ac2-containerrootvolume','b36f6a3c8cd5493f8d7667bd86d1af18-0-scratchvolume','f79babcaa20d4bd2a48181ec38bad249-osdisk','7b194973b78e406d8fde9d128ea6d0f8-containerrootvolume','ae6b3c344bae484e994e206dde789c2a-containerrootvolume','502e27c41f0b4c2181fa808fb9e4687e-osdisk','37e1eda20b6c4e1cb5cfd3b674ace423-0-scratchvolume','88977f5ca91a4f5588129d321542e210-osdisk','cfd0e8d62d1b4af48f2b2f886b4b516a-0-scratchvolume','87a54da633684ec09c0439bbf8b37fc8-0-scratchvolume','b5891a346f984ecbbcdd2f766995ebf0-osdisk','c40b79d703464ab0a63932c7d8f34fc8-containerrootvolume','5a1c2ffbddf241e895ae3d4ad2ba0fd3-containerrootvolume','9d0b3ce312f44e398ddc8c7028825b25-containerrootvolume','24eb22f1325f4cabaa6813b3acafaa3c-0-scratchvolume','4f4bed97c54d4dc6b45880f8e07ca930-0-scratchvolume','d2f6dc2c5fb7406ba0fdd013016ce6ea-containerrootvolume','d1eaeecab5ea4ff4bbbc85e10cc40936-osdisk','76a408e3dce4487cb86f4c13efb7c416-containerrootvolume','26ec4184df494a12a0370a4b49814310-osdisk','24a89022df81448eaf9e8b827e335773-containerrootvolume','c01389af9afa416fad7ea4a1ab944db3-0-scratchvolume','c41e8e8b11f64d28a834c3c0a3bb988b-containerrootvolume','2cc72f8f03ca4cb0851d00bfa5dd2639-0-scratchvolume','50b50e6fcab24e728803f5ede0fcb1c5-containerrootvolume','f0e27205f38c4f669b06fd4272735a20-containerrootvolume','9cda5610922044fa8d0b7074a47c8582-osdisk','bf9278bef09e44e3b6961bdc24a2631c-osdisk','8b323e96db6b438b9d45a000456b1545-osdisk','6b9546a2c07d4acc86b4eb6b8d83f7ed-containerrootvolume','cdcdaac2af1d4a05ac880304b639b4d3-osdisk','c52b2b06872e4862a0db8eb5cb7de776-osdisk','f9f08ba7ec524f7bbb38f69dad88a4a7-osdisk','9845e785f71e46c2873fd23ec215f795-0-scratchvolume','36e86d745ce444c585c692814772e679-containerrootvolume','36e86d745ce444c585c692814772e679-0-scratchvolume','305cfc239afa4584b99b4800da39355b-0-scratchvolume','05e073c6b4094aa3abfc672ddc1fbe5e-containerrootvolume','19a8512b38a14afd9e2b3db79c62de60-osdisk','162de2f27b1b4bd7b45eaf572bde4b7a-osdisk','e62bbc8e501445b9ad0e2c1a2e1990e6-0-scratchvolume','89c1b049dff24f9aa1f928952f389c7b-containerrootvolume','89c1b049dff24f9aa1f928952f389c7b-osdisk','5ac48796a5274b539cdd822b7da4518f-0-scratchvolume','123b3c0c09ad45189969b667eae067d4-containerrootvolume','8175a07cad6d49aebdad65c4dab003a6-osdisk','60331e0db9ec4260ae1fbb109a23e3b1-osdisk','70359a72096f42c8a508744f3808b84c-osdisk','3ed0831f61494463b8debfe8c8b6e876-containerrootvolume','58eef115695442b0b70c07eaf2b295fc-0-scratchvolume','9232643b00934a4099dc6afae862c487-osdisk','52b43890845e441fbf29e42ada0418cc-osdisk','7ad662201f1f446882b8beb0f547df35-osdisk','e4b5fe3094fa4b1fb1c2fc61463638c6-containerrootvolume','39b11f326fed4c90957778534cf2e891-0-scratchvolume','0ebcfa39d03448648e75b0bc5d4775f5-0-scratchvolume','510e64026a7e419ba9a929077fe910c1-0-scratchvolume','b85e9d2f26294bdb85341f6440216870-containerrootvolume','9e7c804c053342c3b53e5d8c320a62f7-containerrootvolume','9e7c804c053342c3b53e5d8c320a62f7-osdisk','f103d3089e574ebba98ffed4f048558d-containerrootvolume','1cd8c16ac37b407b9a6681dda8633bfe-0-scratchvolume','7c4167a869434063a1b3c3782bb6bdaf-0-scratchvolume','a4ec53b167744d99b79dec92eaa02dc4-containerrootvolume','d17c73473acb47278bf823f0fcb39755-containerrootvolume','bd9a75aa6ba14fd1bcca076304e6f505-containerrootvolume','d55ba3331f374a99acb4c9e808957435-containerrootvolume','ee0639fb2ff24d47a8a8a24b8c34f760-osdisk','c89d0e896d524a4b83bb7f64fa5533b2-osdisk','627100ae1b3943ca80766e065fd8bae1-osdisk','8c81c74ef12e47b8973138f5455c1007-osdisk','34c2d13a22cc4b1e886cfc9e361fc8a5-0-scratchvolume','34c2d13a22cc4b1e886cfc9e361fc8a5-osdisk','29cb30b556214b5da55be9dab80d6d4f-0-scratchvolume','64f69eb181114a2e8107c3d35b59c24b-osdisk','040249e8bfcc45f6baeb627bf4c14511-containerrootvolume','c1a6aa87473e474e9655a7b7be8ce477-0-scratchvolume','c1a6aa87473e474e9655a7b7be8ce477-containerrootvolume','98611801fc38486e92ddf676e1d3c736-containerrootvolume','b517847f37f648fe88eced7d7a463362-containerrootvolume','be7ee3ef6bae41bf993875e796050882-containerrootvolume','66b367ade05148c5946b83b3a0fb0ca7-osdisk','511aee0a84d94ab9b1cab49e40c2bac2-0-scratchvolume','2f863f4806f54e02bd710d64d54c8e82-0-scratchvolume','5b4d11ad263e417291b16713d816f400-osdisk','68c77e9532184023a124ad0fadcbfa67-containerrootvolume','76928ecc454f408d9babce15b8ee9f5d-osdisk','9b97a0f4345b493f8a421f153ff0a02f-containerrootvolume','9b97a0f4345b493f8a421f153ff0a02f-osdisk','35df90b3729843a6bdeb2d4e8b0acf7b-osdisk','88e2448c7b324e76b002b59a28581712-containerrootvolume','3f8d6d3056f94c82b90bfb7084d2c917-0-scratchvolume','3f8d6d3056f94c82b90bfb7084d2c917-containerrootvolume','a05354f070a649e7b99595bba5d97968-osdisk','a97f657a961b40c18745ec66424ab6ac-containerrootvolume','8b6829a2c21246639af6c89d4b6b991f-containerrootvolume','70410800ef9943049621586174da3e3a-0-scratchvolume','63bd321cb1534462ae618c813eb735f9-containerrootvolume','23bb5bedf29245a5bed9002da650a264-0-scratchvolume','4e34d69abcbc426092283f984809ef4c-osdisk','544142a029a3445db0d1390105365e91-osdisk','b6c51b7d328b4e00a5c13fca7af799db-osdisk','f32948d204494076b75534f0875707f9-containerrootvolume','44032fad3c5e4d7f8445ae7ad8d8a191-0-scratchvolume','c0ae35c2a9b14da2881602b3eef8d164-osdisk','9d6af9d5f5cc4e028c55737413c01cd4-containerrootvolume','9d6af9d5f5cc4e028c55737413c01cd4-0-scratchvolume','5f72a3b236ae415489fe46e8b243eae1-containerrootvolume','018c63987fad4dc8b431be61108009ce-0-scratchvolume','77735e0b54f147e4988602252787c874-containerrootvolume','be9554919a0d48c2bbc6a42371fce1c8-containerrootvolume','a398b840a3194eea82583447d4c25235-containerrootvolume','c2ae9d8ac7224b0f897756aed6e462da-containerrootvolume','ee3d0a31ff5140a8810695cb14a61f66-0-scratchvolume','273df5edfcb34438a7f58d13bde2e1a3-0-scratchvolume','5173ea3ab6d94c5ba5a92c710081188d-osdisk','c7744fee90804f0c97ff95d03a874942-osdisk','6eb605b165d4460ca0d481aa44010008-containerrootvolume','717f09d52d214bf7b1c0e45664636117-0-scratchvolume','9f1ec2231ebe4ccf89ef9442896461b3-containerrootvolume','a4f3ac00202d43ca9e6178a6a7a23fca-0-scratchvolume','b125641fca474d3c86a8e908dec5d2a3-osdisk','1914641dd4494fabbc7a58e8efa822fd-osdisk','88c4192591494bac9cb4d09b1affed3a-osdisk','1daa5c79767b4dbfba57879feb26692a-containerrootvolume','c9d9b4a85e3f44cb9b020ae5327eab3f-osdisk','792ffce704864a92bbf86582db9ac3fe-0-scratchvolume','3b821f9b496c44fdb01dbab760870ed5-containerrootvolume','e8085f3857df4a64ad072d02a5462c60-0-scratchvolume','c8aa71f0fe5849b999d5f2e18a46434b-0-scratchvolume','71d8328bc5d045ad8a431f9ad99e0ea7-0-scratchvolume','dadbe858160a483cb1bd02136ae7edd3-0-scratchvolume','1c6fe75108d24eb8a162d327913c203a-containerrootvolume','d9d1c73b777e453a969fcaa4ea7add5a-0-scratchvolume','d9d1c73b777e453a969fcaa4ea7add5a-containerrootvolume','d9d1c73b777e453a969fcaa4ea7add5a-osdisk','4ce6938755c54e899fd8cdf43e016f00-containerrootvolume','605cbe43d7634e2cae72c070135da6bc-containerrootvolume','189cb5eae9b34013959841a67026acce-osdisk','ac0d775f3c79448eac65b4b9e5f397df-osdisk','56df236fb8974d55b0acfbb87ddac571-containerrootvolume','278168a5e4404ece9a28273800986e85-containerrootvolume','d94f9ec450ed47a2880dc3d4a2d9f900-containerrootvolume','88d1dc6c126148adbf2ff64dfc9bf976-containerrootvolume','443daa6518c4491288807a06565018c7-0-scratchvolume','6c7380a2d3264025a0e4421c182686c6-osdisk','6edfd680dd1f4cf6b664a046def5937a-containerrootvolume','01e3251f34d243c2b378c7ab15faa139-0-scratchvolume','3a4bd1f82465483da510f719c5797ffb-containerrootvolume','4e266801841541508dd4440a79ab8d28-osdisk','0177d4878dd549579e7fab98742d617a-containerrootvolume','13990eb56e1945af9d06932aaec2b29f-containerrootvolume','4082c94e961d492293d041c4636abb77-containerrootvolume','01bb0054fdb143a4b64f0494ffddb521-osdisk','50e3117697e24d30a8f1b2ffbe40763a-osdisk','5519c7ee882041e58aba52318050aabe-containerrootvolume','5dff6aee8d564e749264024c8a683b2d-containerrootvolume','9384ae92691b42ceb771befb779c92db-0-scratchvolume','2402da64c4b64646a26127f40fad8c83-0-scratchvolume','a31ffc771a5d4429aff881d1a4c1db1d-eg3wg-scratchvolume','c1b2ff0d4ea04c338d9e57b3794bc007-nttwv-scratchvolume','abff146dc81a4776a3593acdcaa48187-osdisk','f44e9285821f4fba969e972f3b0e4a1e-containerrootvolume','0e8858e88fe5455a85d57f0dfa9df91a-containerrootvolume','1c1f505f6cf2414890efd9691ca58cc7-containerrootvolume','9da3250a522144238312c3a74a5f77b6-containerrootvolume','50c0b21395e44ffe91f7c5afbe8b20e0-osdisk','631a275fa9ff4500bd26800be41fdfc0-containerrootvolume','a1aca208519540af868fa4bb97c7ef3b-containerrootvolume','0544c8ece7924fbda11698a01bd6dbe7-osdisk','d710da85d7744a51937d8a73d570c099-0-scratchvolume','7bff4a461417463daf163c4d15f9da9f-containerrootvolume','b4011cf79fb140cfad724e40b4dd18e5-0-scratchvolume','9630d175df6e49a9949f56110ee3e40e-containerrootvolume','add419162079402599b8f3b7f3df55ae-containerrootvolume','9b9ccd4bb7c74adcbf674c4fae2a7d08-containerrootvolume','b289c10488a44a3889d78634bfa8988c-osdisk','eb84f94379fe4c6fa49c7fb08f0384de-osdisk','c379eddf774a4796871ea991a5a4f8e0-0-scratchvolume','4e15a2ddec824a8d825b6bd0eb6b0014-osdisk','c3f328b28a01479d9394bf2770b193ea-0-scratchvolume','e6ca7d3270db43399277dd9bfc42b466-0-scratchvolume','950921cc10594ee58b62c76325f19cb4-containerrootvolume','3d5085e1239841099f8a95e9a7f53066-0-scratchvolume','8d3b94e27f2c40c9833b9a3b5c25421a-osdisk','0d988f3cfe3b4d7a9a1a015423b37743-osdisk','a9e00f39675f41e8834d0efbb534709d-osdisk','e5cb4500598c475c9d637eb6631424c0-osdisk','96df92f6b10c49f99d564eba664ebe17-0-scratchvolume','9bd11e94dc204dc484a4b426c58cbc00-containerrootvolume','db410d2988cb455aa6b88b99ee60a86c-containerrootvolume','0a4259c33d824b43bd01ab0e6d387116-0-scratchvolume','be89c3ae012449f7996874f190fcca9b-0-scratchvolume','f8267defb3a54287921ba94b9afaada5-0-scratchvolume','f8267defb3a54287921ba94b9afaada5-osdisk','72e8aeab8cc74f9b9f9741be8e596011-osdisk','f85e375d79ae41068414ac7427630348-osdisk','26da47024ee748619c7dad88bf4fff1f-containerrootvolume','fb974d70fe0f46e99dd76f4380d06a6f-osdisk','c9aa916a43ad4e449617bbfe688d7338-containerrootvolume','72d40e12d65249ff9671a4b37c555b62-containerrootvolume','03752b600fa647ff85745c00f77c3450-osdisk','b6262064e14d4d0a8d19e9b0b4f4e7d8-containerrootvolume','a57e72f279394403ad62499e913a54de-containerrootvolume','94d2b4eae46b498787ca444b06c5a308-containerrootvolume','2c725bf5fd474cd0b7b79a7ba35b3805-0-scratchvolume','b480f2678c764ebd9be51d98ad7cf755-0-scratchvolume','35cbfcff12064f209b70ac919a0ef9df-0-scratchvolume','6e3163a2e9b44be48446a28523514800-containerrootvolume','122048e75b13417598cb70db657fd3d4-0-scratchvolume','13d13877c13f4edb9f7aed0306cb4cf0-containerrootvolume','3dc287b8a3344105ae5fd84589e93da7-0-scratchvolume','4c8c5bf42a1a4afb8ce6bbb4e14e6632-0-scratchvolume','a682a505ae49467c8d56d4e02c406622-containerrootvolume','89b163ab63024988ab0d693ae6e18456-containerrootvolume','023185ec98994016b60557389b276ee6-containerrootvolume','d6b9eafada3542098018a359ab54a203-containerrootvolume','143698de6f864eaa84fa03813ead90a1-containerrootvolume','89dc4eef300940cc81a57b077124f836-0-scratchvolume','47c4c7ac60054ddab8bdeed0d547e69f-osdisk','c0be4647513749f59c29dbb1c8cbf5cd-containerrootvolume','51321997ee334b6990f98a5debec992d-0-scratchvolume','b220b156a2674aeebbcfab47a5f0dfe5-containerrootvolume','57bbe5ebb5bc4818a486d14b38eaa82c-containerrootvolume','3443d1c2c6bf4b9ba67a7da59a3452ad-containerrootvolume','f2cc572ae3e14de79d53f659c4e14d57-containerrootvolume','74d87aec23594453b50de09f5ce38462-0-scratchvolume','be265e111c004a08a0533931e9408a18-osdisk','8affbff6f46647788b0fa11dcdf0c7b5-containerrootvolume','8affbff6f46647788b0fa11dcdf0c7b5-osdisk','f4b1322a53514326ad8aaf5d0a78acf8-0-scratchvolume','5819c6de1e3448948477ff7717395f4c-containerrootvolume','58f6cd97b9994ba5b9c107be4a0df8d8-osdisk','a3e359e4205d42db979d4e9ffc1ee34b-containerrootvolume','e89fdd886715413991a1582192dd1bb5-containerrootvolume','3b6f7cea01bc4b23a9bc53293d00378f-0-scratchvolume','113cc110ae2d4812b0ba82527e83b8c6-0-scratchvolume','080f593ece96414fa675584e9530c68d-0-scratchvolume','080f593ece96414fa675584e9530c68d-osdisk','af7aa6ca38ec48d0bb51d4b434bdb5f5-0-scratchvolume','8991f4f986c24304bb426c5e18572bc3-containerrootvolume','24f4b159042b4d4baa87065614bcffea-osdisk','22cd8ff533334295954f05454e482936-0-scratchvolume','4599cec8ef2342f59fb94a9f5da50d6a-0-scratchvolume','35250b2c4e5a4bd2a4c39bbb668deae2-containerrootvolume','defda357b733428ea14fdd20765402cb-fukdj-scratchvolume','4977bf01e4774564a68c0e8779ff6b5a-containerrootvolume','1793ab2b14374ff4853047e46f4874bc-osdisk','46d0f43aa0614abc94f7014a7059fb0f-0-scratchvolume','bc1fe7d9cc2d462aa3fa48a046789712-0-scratchvolume','561043bf73534b4d80390a4978498813-0-scratchvolume','cbd8de7239ca47228eafdbda2c2e45e0-containerrootvolume','8478d3be139c4db5883230bc2dc9d4e7-containerrootvolume','4e451b9c2a4240bd9c097212e46678d2-0-scratchvolume','aadb9d40263746b9ab6d2dcdb271d57e-containerrootvolume','0767c9c3fbe64d10827a76b20461269f-containerrootvolume','68c3a57609b84a269d331ca3abeb1d44-containerrootvolume','357f364c7c3e478089cec76fa18586d9-containerrootvolume','fc0b0be09de144988a2b99c61c4e58d5-containerrootvolume','96681f44706f4b659f43eeabfd590504-0-scratchvolume','ca40933d2f154937bb01b3795783a3b8-osdisk','7757d35105004482bcd09c3410cf493a-containerrootvolume','2075012ca7464913b0006f9f66173a19-containerrootvolume','9b76075189a149bdbd13ddd7127cd968-containerrootvolume','b4c4a2efa8524105a252da7b8d178610-0-scratchvolume','3f1617dee13443ebbe326a0a1d0c8883-containerrootvolume','815733ad23894fd8aaa6f94ed5e63ba0-0-scratchvolume','968524e9beae4f8488328c5e2290658d-0-scratchvolume','6fceb6016256467081ab9588859070db-containerrootvolume','c7a3006d5fba485aa0719386f8ec51ce-containerrootvolume','3e5f345033234748bb8798190c8a2b5a-containerrootvolume','bf707696ce48471591ec3c61f0bdde32-0-scratchvolume','9babe64db33f49cd9e46aeb5ce67c3be-0-scratchvolume','b33bed3ad4f7407e81d806d2992cbf91-osdisk','3e9b2be92e244cc4b2b54cebaea042c0-containerrootvolume','9b486b6de9e64725be68316bd8118e6e-containerrootvolume','a855e3deee484b62a90de2b857d78713-0-scratchvolume','7c677d1bff0640b4a96ad3f11df39234-containerrootvolume','628d1b9d89df4f0e8ed5b86052268b0d-0-scratchvolume','d3f9f14d48c4415ca0f6feaceac7b014-osdisk','9255256cf9c04b6ea19719b34d098a53-osdisk','a816b8d57a424800b795c02e4ffc02d3-0-scratchvolume','eadfd029a9104c8e97aeb49a1ae9425d-0-scratchvolume','ffe91400344b4fe4b0c37685c81766a8-0-scratchvolume','a2e43781631748b4bfa3cb78ab8df338-osdisk','27aaf190a9f54d7685da5f65450bdb35-containerrootvolume','7abcc5c70c94460ab33d15eb1865d62b-osdisk','91b616975173447580734de490043afd-containerrootvolume','b58cb43402ae45198e37ffcccf04eedb-containerrootvolume','5cce3659583b4a42a2993fac20de9318-osdisk','7247ce4ad187419dbf67255f64633691-0-scratchvolume','7247ce4ad187419dbf67255f64633691-containerrootvolume','7467e3583d504529a27a03679c8dd4d9-0-scratchvolume','fe031987e94f425d9b37bcfa2e817652-osdisk','979c79410b9249e997e38213dd0b481d-osdisk','082edec2cda4456f95f41d6a8b3873ac-containerrootvolume','8273fde0427f44d4a0394b2b2ca8a69e-0-scratchvolume','b6ce0ee64d5946ffa031a2f8e2a1bb6d-0-scratchvolume','ba1be3fc052a4c149e3d26a8a9034b2a-containerrootvolume','4b7c065d7f0e42bf8a3759345d7bd864-containerrootvolume','446b2862c2364046819c9848a618fb12-osdisk','44d327a41f4942ccb0f45bbda04d1c49-containerrootvolume','e4877716faf947b3ac8485fdaff425ff-containerrootvolume','5e9d499f84284b09acaf3bef1595e465-0-scratchvolume','72a4ab0808a94e90b58d760701819f8f-containerrootvolume','f5d656f8713f40139f06eba8785a8e18-0-scratchvolume','267de52d5c104c6e84eceb9c36a2fd6f-osdisk','d47020a57b7c4b6dab9ff39501e2f2a0-osdisk','c0eebfd646ce41fd940d4372ff4824bc-0-scratchvolume','13011494b6b2409096b0556d0293727c-0-scratchvolume','c0eebfd646ce41fd940d4372ff4824bc-ucgny-scratchvolume','9fdb837fb34e46f383dd5283696e05e2-0-scratchvolume','697b79d309b940b7bbf2ac2d5d0870c5-containerrootvolume','697b79d309b940b7bbf2ac2d5d0870c5-osdisk','f6d27d340c6a4a179c4aa32b835d305b-containerrootvolume','9b086e1fc8354cb08e2507b1143d94c2-osdisk','6e81c33e0afd4c02865f12cf861e1424-0-scratchvolume','7fb873f3099a4d26bc0a722d6fda8cea-osdisk','702bf998238d46b9bdc20205a5c06685-osdisk','a6ae6445038d40bfa1df45aed13ee50e-osdisk','ec24e330461c4d26a79c6364cb78441a-0-scratchvolume','5e382b1e143f44f7a763f76a90e2c30a-0-scratchvolume','0a08ce64ad7243f5b413db8ee602f074-containerrootvolume','1215c860ad474bc8a64e1ca1f6724fa2-osdisk','4f47b10f1164403584490451b90c5494-containerrootvolume','dc3af575b15e4a95b46b044c2ff86a5a-containerrootvolume','dc3af575b15e4a95b46b044c2ff86a5a-osdisk','775791f40f2844d483d558aae333d87e-osdisk','6fd9456beb164055b56d52414d22fdf7-containerrootvolume','27553a60bfdc49cca6973f2d17579460-containerrootvolume','b8720633869f458aa7dbcff5575963c9-0-scratchvolume','22548a6193724ed18873f78b360e0346-osdisk','02aa60a2e7b84a5bb5b14ff7eda7990e-containerrootvolume','02aa60a2e7b84a5bb5b14ff7eda7990e-osdisk','7125611213504d55ab304bfac9b50ee9-0-scratchvolume','29b0ce3a484943f9b189efcd45de25c8-0-scratchvolume','63b911fb8cc0469f862bb2fc3c301a20-containerrootvolume','a9e28fc38f8b4f6f97da8ed50a3b71eb-osdisk','27839c42dc1149b88927a4b28aa35c7a-containerrootvolume','00ce63a0f864425ab260cd753adc12a1-containerrootvolume','d1f1d23e8be2490c8bbcf26fe535c13b-0-scratchvolume','56827c4149224ac68a2ece53fc08a52d-osdisk','9a8314fe85274e059f43207467040039-osdisk','50954887e7874ded819b41860421053c-containerrootvolume','445cae3a6c874825b844a3bf62cafc03-osdisk','22744265a43244499a60663927f0c439-osdisk','5d564915359f41b5b64d350d22821bdf-osdisk','ad8bc290f796430c859e4ee56374e945-0-scratchvolume','db9bb402e9ae46a092d9b436753bc40f-0-scratchvolume','567703801dd749939b225755d86f2d22-containerrootvolume','bade4b86d224410f81541e529289a5d5-containerrootvolume','b1e9dc8189b44e1a8f92e6921a60fdd2-containerrootvolume','830f6eb0c6d5494da87de84b890813e5-0-scratchvolume','5360518068ac412b99d3f001b9cefaf9-containerrootvolume','5519aaee3ddf4304ba6023f9ea61ed8a-osdisk','f41af47350e54121a3674f639b389206-osdisk','136403787aba4b8d9d220bfa0a527593-osdisk','c3d9b5628f744d4fa11da67495e6ccba-containerrootvolume','2f92017fff4440a3874acff25029d304-osdisk','148caea12f6c4d29b39ad1899fc65360-0-scratchvolume','148caea12f6c4d29b39ad1899fc65360-borgw-scratchvolume','12d7418e20f84ee0bc5509c88a810b54-containerrootvolume','388dd5d4c3f24502b58ba41ed4f93895-containerrootvolume','e35b13dbd47b41f385f6449ca7b2b07f-osdisk','37e4c3c64e814260acb4bbc5ee93b940-containerrootvolume','c8865abf09be4e0590e44a8f3abebd9f-containerrootvolume','5210f4af08dc4aec851b7f6aa23f9bb4-0-scratchvolume','4709cecdf2884257a03b21c106e59e8e-0-scratchvolume','363acedf11ce443f8f6f4dbeacf93ee6-0-scratchvolume','4fc910fab9004ac4bd050e806582d74f-osdisk','99effb1ce0384f849d118b0212ee166a-containerrootvolume','2eac0b0399ca4a8fa55eafa33bb98d36-0-scratchvolume','8d43d5bedf4f4ba1962b550ed4779d42-0-scratchvolume','f78c1139329845dd96e5cef418e68fb2-0-scratchvolume','494d3e1fc52c4f1496a9d90a3635b520-osdisk','2c78463a2542458a9a03ff97fba4fe4b-osdisk','c88a0e94bd9d447b8cb3e0feac5606e5-containerrootvolume','c88a0e94bd9d447b8cb3e0feac5606e5-osdisk','11dcfb7a6a6442da98d1111989d84c3c-osdisk','b03eb421e6ec42f48868cc7918c30fe0-osdisk','da142f16fedc464bbc32ea8aa00c62c6-osdisk','d45c7f89ef7b4f309a361ec72896b35c-osdisk','5b823cc3af354e86abad7ea8e915597f-containerrootvolume','507dac3ff2014f84b52f9ccd7e4aff4d-containerrootvolume','bd5e60dc03544d13894fd5e296b06915-osdisk','0ce1e05dc1004bd2ab334e219269b246-containerrootvolume','af836a5ca2ef43baaf33d826cadf5462-containerrootvolume','21fa1b6439864f0c844b52294f556507-containerrootvolume','2f4d4b8731ce460f8fb387c43b814984-containerrootvolume','85dd04fa87854e1587df3df1946c88c2-0-scratchvolume','7563bf60b168420881ff1ef97b294bcc-containerrootvolume','e0754d887e7e4b128f0b925cdbf70f12-0-scratchvolume','e0754d887e7e4b128f0b925cdbf70f12-osdisk','46c40750474f474eb8f618e08b98f912-containerrootvolume','39b492f5d65f4b03b789fce21c4a8fa1-0-scratchvolume','7ec725a4be364b63ba1140563605e3c6-containerrootvolume','7ec725a4be364b63ba1140563605e3c6-0-scratchvolume','7712f0829000406a9116e58080d00e29-0-scratchvolume','781f4942e38b475581f8f37c2fdf1f58-osdisk','bb3704d11590472e90c0d384b3cfdd65-0-scratchvolume','bb99d0fe91cb4756830f32b1bc11ac46-0-scratchvolume','bb99d0fe91cb4756830f32b1bc11ac46-containerrootvolume','ae9862c857ba4560b6f81b4086c0de43-containerrootvolume','ffc32158cfb245668485ccffda308621-containerrootvolume','9117c250a86c41aa978a357e29534a79-containerrootvolume','670a8932936145e7bf27ca91c99431d7-containerrootvolume','f0ca45bd9e05424582efa1417be343bb-3uwff-scratchvolume','3a3c14920773453b800d5aaa10865f82-osdisk','7a74d99df55741b28683cd9ae7d90607-containerrootvolume','653a006772db4b9d97e0199379e82c83-osdisk','f8abad339a5946e6a86221bfd6251746-containerrootvolume','31f808e0cda6446690296611d6dcb948-0-scratchvolume','4ad673d6b02241729500f83d30583ddc-osdisk','97afd03f141d44baacbc5c1e6c893294-osdisk','ee6e329a25e64f619909dfb7204501db-containerrootvolume','11c28811407842d68268fbe8f70654c9-osdisk','a26af1aa002c47d6a32bf1c5f194914e-containerrootvolume','3724c8d0762f44a4a5a3dd26f7040176-osdisk','7f657311461244ce8ac2a269ef46b700-vu9y3-scratchvolume','638565993d204e98b811aa4dc78f2768-cgrug-scratchvolume','5a493fb2e97e476bb8c04abad5f8bbb5-s8yzp-scratchvolume','3cb4ae056ac442b58268d890ca828aa3-ekuis-scratchvolume','f9e68cb9647646c3af1892207351afcb-19fgv-scratchvolume','0d85da4238bd4bd38f7dfc5ef4a887d3-5ovnz-scratchvolume','a485d23b577a4fea9b7b8e63e66226eb-wapr7-scratchvolume','ad7308a78dac4d8fb7b8e15a5a309cb4-asbxf-scratchvolume','72135fdd391c48058f2b7fc912ec4114-qklel-scratchvolume')\n    --and (lower(ResourceName) not like '%osdisk' and lower(ResourceName) not like '%containerrootvolume' and lower(ResourceName) not like '%scratchvolume')\n    and lower(ResourceName) like '%osdisk' \n    --and lower(ResourceName) like '%containerrootvolume' \n    --and lower(ResourceName) like '%scratchvolume'\n    --and MeterName like '%Disks'\n    --and Tags like '%databricks-instance-name%'\n    and format([Date],'yyyy-MM-dd') >= '2022-11-01' --and format([Date],'yyyy-MM-dd') <= '2023-03-22' \n\nGroup by SubscriptionName, format([Date],'yyyy-MM')\norder by SubscriptionName, format([Date],'yyyy-MM')",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/DataBricks Usage')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "\nSELECT\n    format([Date],'yyyy-MM') as [Date]\n    ,MeterCategory\n    ,SubscriptionName\n    ,MeterName\n    ,sum(Quantity) as Quantity\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2023*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Azure Databricks'\n    GROUP by format([Date],'yyyy-MM'), MeterName, MeterCategory, SubscriptionName --MeterName, \n    order by format([Date],'yyyy-MM'), sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Defender for Storage')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\n    ,sum(Quantity) as Quantity\n    ,UnitOfMeasure\n    ,UnitPrice\n    ,MeterCategory\n    ,MeterSubCategory\n    ,MeterName\n    \n    ,ResourceId\n    --distinct(MeterName)\n\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202308*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    WHERE\n        MeterCategory = 'Advanced Threat Protection'\n        --and MeterSubCategory = 'Storage'\n        --and MeterName = 'Standard Transactions'\n        --and (UnitOfMeasure = '1M' or UnitOfMeasure = '1/Hour')\n        --and (MeterName = 'Standard Transactions' or MeterName = 'Standard Node')\n    --group by UnitOfMeasure, UnitPrice,MeterCategory,MeterSubCategory,MeterName\n    --AND MeterName = 'Standard Node'\n    --and ResourceId = '/subscriptions/019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc/resourcegroups/doggerbankpreprod-project-resources/providers/microsoft.storage/storageaccounts/dlstepdbpreprod'\n    group by ResourceId\n    ,UnitOfMeasure\n    ,UnitPrice\n    ,MeterCategory\n    ,MeterSubCategory\n    ,MeterName\n    order by ResourceId\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Drop all Usage View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Management API"
				},
				"content": {
					"query": "DROP VIEW All_Usage_Management_API",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Example of MI')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQL HUB Issue"
				},
				"content": {
					"query": "SELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE InstanceId = '/subscriptions/7EC0C667-CE56-4737-A39D-F16434DE2501/resourceGroups/rg-fieldnet-t/providers/Microsoft.Sql/managedInstances/s251-sqlmi-t'\n--WHERE SubscriptionGuid = '13d66f54-0a19-4912-b4f3-54d15897368d' and \n--(ResourceGroup = 'Hub-Investigation-SQLDB-NoHUB' or \n--ResourceGroup = 'HUB-Investigation-MI' or \n--ResourceGroup = 'Hub-Investigation2')\norder by [Date] DESC\n\n--\n\n\n--WHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE '%BYOL' --and Product LIKE '%Spot%'\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), PartNumber, Product\n--ORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extended AI Query')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *,\n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as ai_VCPUs,\n    JSON_VALUE(AdditionalInfo, '$.vCores') as ai_vCores,\n    JSON_VALUE(AdditionalInfo, '$.UsageType') as ai_UsageType,\n    JSON_VALUE(AdditionalInfo, '$.ImageType') as ai_ImageType,\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ai_ServiceType,\n    JSON_VALUE(AdditionalInfo, '$.VMName') as ai_VMName,\n    JSON_VALUE(AdditionalInfo, '$.VMProperties') as ai_VMProperties,\n    JSON_VALUE(AdditionalInfo, '$.AHB') as ai_AHB,\n    JSON_VALUE(AdditionalInfo, '$.ConsumedQuantity') as ai_ConsumedQuantity,\n    JSON_VALUE(AdditionalInfo, '$.DatabaseName') as ai_DatabaseName\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20220201-20220228/ACMMonthlyActualCost_20220201-20220228.parquet',\n        FORMAT = 'PARQUET'\n    ) \n    AS [result]\n    where JSON_VALUE(AdditionalInfo, '$.vCores') != ''\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB Count')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API"
				},
				"content": {
					"query": "declare @HUB_Date as varchar(10)\nset @HUB_Date = '2023-01-21'\nSELECT\n    --TOP 10  *\n    count(ResourceName)\n    --ResourceName\n    --,substring(cast([Date] as varchar),1,10) as [Date]\n    --,MeterCategory\n    --,MeterName\n    --,AVG(cast(JSON_VALUE (AdditionalInfo, '$.VCPUs') as int)) as vCPUs\n    --,ResourceId\n    --sum(cast(JSON_VALUE (AdditionalInfo, '$.VCPUs') as int)) as vCPU\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/20230101-20230131/ACMDailyActualCost_653a874b-ede7-4670-abf7-fde225a5544f.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where ServiceInfo2 = 'Windows Server BYOL' and substring(cast([Date] as varchar),1,10) = @HUB_Date\n    group by ResourceId, ResourceName ,substring(cast([Date] as varchar),1,10) ,MeterCategory, MeterName\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB_SQL')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "SELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.AHB') as AHB, \n    MeterSubCategory,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product,\n    InstanceId\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2022/06/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--WHERE ServiceInfo2 NOT LIKE 'Windows%' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\nWHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'True') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory LIKE '%Hybrid%')\n--WHERE InstanceId = '/subscriptions/f9892073-3b09-40b7-8f33-1e0320e683c8/resourceGroups/rg-echomodeldist-test/providers/Microsoft.Sql/servers/sql-echomodeldist-test/databases/sql-echomodeldist-test/sqldb-echomodeldist-test'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterSubCategory, PartNumber, Product, JSON_VALUE(AdditionalInfo, '$.AHB'), InstanceId\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB_VMs')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "SELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), PartNumber, Product\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB_VMs_2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "SELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    Product,\n    PartNumber,\n    MeterCategory\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE '%BYOL' --and Product LIKE '%Spot%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), PartNumber, Product, MeterCategory\nORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB_Windows_Savings View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW HUB_Windows_Savings\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/savings/monthly/*/*/*-HUB_Windows.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Hub - Non Hub VM identification')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20231101-20231130/Extended_v3_ACMMonthlyActualCost_20231101-20231130.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory like 'Virtual Machines%'\n    --and Azure_Hybrid_Benefit = 'Enabled' and IsRIUsage = 'RI Usage' -- HUB enabled and RI assigned to VM\n    --and MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory = 'Windows Server' -- RI applied but PAYG Windows Licence\n    --AND IsRIUsage != 'RI Usage' and Azure_Hybrid_Benefit = 'Enabled' -- No RI assigned, HUB assigned\n    and MeterSubCategory = 'Windows Server' and IsRIUsage != 'RI Usage' -- No HUB, No RI\n    \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Image Type Count')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    ServiceInfo2 as [Image Type]\n    ,count(DISTINCT ResourceId) as [Count]\n    ,FORMAT ([Date],'yyyy-MM') as [Date]   \n    --,MeterSubCategory\n    --,Tags\n    --,ResourceId\n    --,SubscriptionId\n    --,SubscriptionName\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines' and Tags not like '%\"Cluster%' and Tags not like '%\"Kubernetes%' --and ServiceInfo2 is NULL --and SubscriptionId = '019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc'\n    --and ResourceId = '/subscriptions/019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc/resourceGroups/MC_AURORA11_AURORA11_NORTHEUROPE/providers/Microsoft.Compute/virtualMachineScaleSets/aks-gpu-36545846-vmss'\n    group by ServiceInfo2, FORMAT ([Date],'yyyy-MM')\n    --group by ResourceId, ServiceInfo2, MeterSubCategory, FORMAT ([Date],'yyyy-MM') --Tags, \n    order by count(DISTINCT ResourceId), FORMAT ([Date],'yyyy-MM') DESC\n    --order by FORMAT ([Date],'yyyy-MM')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Image Type Null Image Details')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    ServiceInfo2 as [Image Type]\n    --,count(DISTINCT ResourceId) as [Count]\n    ,FORMAT ([Date],'yyyy-MM') as [Date]   \n    ,MeterSubCategory\n    --,Tags\n    ,ResourceId\n    --,SubscriptionId\n    --,SubscriptionName\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines' and Tags not like '%\"Cluster%' and Tags not like '%\"Kubernetes%' and ServiceInfo2 is NULL --and SubscriptionId = '019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc'\n    --and ResourceId = '/subscriptions/019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc/resourceGroups/MC_AURORA11_AURORA11_NORTHEUROPE/providers/Microsoft.Compute/virtualMachineScaleSets/aks-gpu-36545846-vmss'\n    --group by ServiceInfo2, FORMAT ([Date],'yyyy-MM')\n    group by ResourceId, ServiceInfo2, MeterSubCategory, FORMAT ([Date],'yyyy-MM') --Tags, \n    --order by count(DISTINCT ResourceId), FORMAT ([Date],'yyyy-MM') DESC\n    order by FORMAT ([Date],'yyyy-MM')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Linux Reservation Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    reservationOrderId AS reservationOrderId,\n    reservationOrderName AS reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11) AS eventDate,\n    quantity AS quantity,\n    amount AS amount,\n    currency,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/tempdata/annual/2021/costreport_reservations_monthly_2021.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\nwhere reservationOrderName NOT LIKE '%SQL%' and reservationOrderId != 'd5b99270-d26e-49b1-82dc-d7cb16a9181a' and reservationOrderName LIKE '%SUSE%'\norder by substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Linux_Reservations')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.ReservationOrderId') as ReservationOrderId, \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines Licenses' and JSON_VALUE(AdditionalInfo, '$.ReservationId') LIKE '%%' and Product Not like 'Windows%'\n--and MeterSubCategory = 'Reservation-Base VM' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), PartNumber, Product, JSON_VALUE(AdditionalInfo, '$.ReservationOrderId')\nORDER BY ConsumedQuantity DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Linux_Reservations_2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    substring([Date],0,8) as [Date],\n    JSON_VALUE(AdditionalInfo, '$.ReservationOrderId') as ReservationOrderId, \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines Licenses' and JSON_VALUE(AdditionalInfo, '$.ReservationId') LIKE '%%' and Product Not like 'Windows%'\n--and MeterSubCategory = 'Reservation-Base VM' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\nGROUP BY substring([Date],0,8), JSON_VALUE(AdditionalInfo, '$.ServiceType'), PartNumber, Product, JSON_VALUE(AdditionalInfo, '$.ReservationOrderId')\nORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Linux_VM_VCPU_Hours_with_Cost_2021_excl_RI')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    substring(FORMAT ([Date],'yyyy-MM-dd') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and MeterSubCategory != 'Reservation-Base VM' and MeterSubCategory NOT LIKE '%Windows%'\n--WHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' and AdditionalInfo NOT LIKE '%Standard_DS[0-9]_v2%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-dd') ,0,8)\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType')\n--GROUP BY REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\nORDER BY substring(FORMAT ([Date],'yyyy-MM-dd') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/List all MeterCategories per ConsumedService')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *\n    --format([Date], 'yyyy-MM') as [Date]\n    upper(ConsumedService) as ConsumedService\n    ,upper(MeterCategory) as [MeterCategory]\n    ,FORMAT(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where ConsumedService is not null --and MeterCategory like '%SQL%'\n    group BY upper(ConsumedService), upper(MeterCategory)\n    order by upper(ConsumedService), upper(MeterCategory)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Market Place Charges 2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(additionalInfo, '$.UsageType') as UsageType,\n    JSON_VALUE(additionalInfo, '$.ServiceType') as ServiceType,\n    JSON_VALUE(additionalInfo, '$.VCPUs') as VCPUs,\n    substring(FORMAT (usageStartDate,'yyyy-MM-dd') ,0,8) AS [Date],\n    sum(consumedQuantity) as consumedQuantity,\n    sum(resourceRate) as resourceRate,\n    sum(extendedCost) as extendedCost,\n    isRecurringCharge\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/tempdata/annual/2021/Marketplace_Charges_2021.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n    GROUP BY JSON_VALUE(additionalInfo, '$.UsageType'),\n    JSON_VALUE(additionalInfo, '$.ServiceType'),\n    substring(FORMAT (usageStartDate,'yyyy-MM-dd') ,0,8),\n    JSON_VALUE(additionalInfo, '$.VCPUs'),\n    isRecurringCharge\n    order by extendedCost DESC\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MarketPlace Usage')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "MarketPlace"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    PublisherType\n    ,PublisherName\n    ,PlanName\n    ,SubscriptionId\n    ,SubscriptionName\n    ,ResourceGroup\n    ,ResourceLocation\n    ,[Date]\n    ,Quantity\n    ,EffectivePrice\n    ,UnitPrice\n    ,CostInBillingCurrency\n    ,ConsumedService\n    ,ResourceId\n    ,ResourceName\n    ,ai_ServiceType\n    ,ai_VCPUs\n    ,CostAllocationType\n    ,CostAllocationCode\n    ,ActiveWBS\n    ,AppID\n    ,Application_Name\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where PublisherType = 'Marketplace' \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MarketPlace View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW MarketPlace\nAS\n\n\nSELECT\n    --TOP 100 \n    PublisherType\n    ,PublisherName\n    ,PlanName\n    ,SubscriptionId\n    ,SubscriptionName\n    ,ResourceGroup\n    ,ResourceLocation\n    ,[Date]\n    ,Quantity\n    ,EffectivePrice\n    ,UnitPrice\n    ,CostInBillingCurrency\n    ,ConsumedService\n    ,ResourceId\n    ,ResourceName\n    ,ai_ServiceType\n    ,ai_VCPUs\n    ,CostAllocationType\n    ,CostAllocationCode\n    ,ActiveWBS\n    ,AppID\n    ,Application_Name\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where PublisherType = 'Marketplace' \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MarketPlaceActualCost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "MarketPlace"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/20221101-20221130/ACMDailyActualCost_314263b6-3eec-48c4-a5b3-d251b0ff1036.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nwhere PublisherType = 'Marketplace'",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MarketPlaceAmortised')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "MarketPlace"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyAmortizedCost/20221101-20221130/ACMDailyAmortizedCost_c2efb564-3599-4f9d-a5a8-800a769844e3.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nwhere PublisherType = 'Marketplace'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MeterCategory Count')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 5 *,\n    MeterCategory\n    ,count(distinct ResourceId) as [Count]\n    --,sum(Quantity) as Quantity\n    --,sum(CostInBillingCurrency) as Cost\n    --,UnitOfMeasure\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    group by MeterCategory\n    order by MeterCategory\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MeterCategory subcategory consumed service meterName UoM list')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT \n    MeterCategory,\n    MeterSubCategory,\n    ConsumedService,\n    MeterName,\n    UnitOfMeasure\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--WHERE MeterCategory = 'Storage' and ConsumedService = 'Microsoft.Compute'\nGROUP by MeterCategory, MeterSubCategory, ConsumedService, MeterName, UnitOfMeasure",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Monthly Cost of VMs')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Cost by Resource Type"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), FORMAT ([Date],'yyyy-MM')\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nwhere MeterCategory = 'Virtual Machines'\nGROUP BY FORMAT ([Date],'yyyy-MM')\nORDER BY FORMAT ([Date],'yyyy-MM')",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/MonthlyPartitioned')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_MonthlyPartitioned\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/MonthlyPartitioned.parquet/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Naz WBS Search')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\nSubscriptionName\n,[ResourceGroup]\n,format([Date], 'yyyy-MM')\n--,concat(substring([Date],7,4), '-', substring([Date],1,2)) as [Date]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n--,SUM(Quantity) as Quantity\n,ai_ServiceType\n,[MeterCategory]\n,[MeterSubCategory]\n,Tags\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202212*/E*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere \n    --UPPER(Tags) like '%C.ITX.036.001%' --OR\n    UPPER(Tags) like '%C.ITX.036.002%' --OR\n    --UPPER(Tags) like '%C.ITD.15.022%' OR\n    --UPPER(Tags) like '%C.ITD.15.034%' OR\n    --UPPER(Tags) like '%C.ITX.43.001%' OR\n    --UPPER(Tags) like '%C.ITX.46.004%' OR\n    --UPPER(Tags) like '%C.ITX.46.007%' OR\n    --UPPER(Tags) like '%C.ITX.46.011%' OR\n    --UPPER(Tags) like '%C.ITX.46.012%' OR\n    --UPPER(Tags) like '%C.ITX.036.002%'\n--GROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), SubscriptionName, MeterSubCategory, JSON_VALUE(AdditionalInfo, '$.ReservationId'), substring([Date],0,8)\n--ORDER BY substring([Date],0,8) DESC, sum(ConsumedQuantity) DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Network Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    --TOP 100 *\n    SubscriptionName\n    --,ResourceGroup\n    --,ResourceName\n    --,SUBSTRING(CAST([Date] as VARCHAR),1,10) as [Date]\n    ,ProductName\n    ,MeterCategory\n    ,MeterSubCategory\n    ,ResourceLocation\n    ,UnitOfMeasure\n    ,sum(Quantity) as Quantity\n    ,round(AVG(UnitPrice),2) as UnitPrice\n    ,ROUND(sum(CostInBillingCurrency),2) as Cost\n    ,PartNumber\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/20230801-20230831/Extended_ACMMonthlyActualCost_20230801-20230831.parquet/part-*.snappy.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    lower(SubscriptionName) in (\n        'hub01-shared-services'\n        ,'s268-prod-geology-geophysics'\n        ,'s034-geology-geophysics')\n    and MeterCategory in (\n        'Virtual Network'\n        --,'ExpressRoute'\n        --,'Bandwidth' \n        )\n    and [Date] > '2023-08-06' and [Date] < '2023-08-12'\n    and ResourceLocation = 'westeurope'\n    and MeterSubCategory <> 'IP Addresses'\n    group by SubscriptionName, ProductName, PartNumber, MeterCategory, MeterSubCategory, ResourceLocation, UnitOfMeasure ,PartNumber --, SUBSTRING(CAST([Date] as VARCHAR),1,10), ResourceGroup ,ResourceName, \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/No_of_Regions_Count_2021-04_2022-03')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/12 month period"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    COUNT(DISTINCT [ResourceLocation])\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nwhere ([result].[Date] BETWEEN '2021-04-01' and '2022-03-31')",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/No_of_Regions_Count_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    COUNT(DISTINCT [ResourceLocation])\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/No_of_Regions_List_2021-04_2022-03')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/12 month period"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    DISTINCT [ResourceLocation]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nwhere ([result].[Date] BETWEEN '2021-04-01' and '2022-03-31')\nORDER BY [ResourceLocation]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/No_of_Regions_List_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    DISTINCT [ResourceLocation]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nORDER BY [ResourceLocation]",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Null Image Type Breakdown')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n--top 100\n    ServiceInfo2 as [Image Type]\n    --,count(DISTINCT ResourceId) as [Count]\n    ,ResourceId\n    --,FORMAT ([Date],'yyyy-MM') as [Date]\n    --,SubscriptionId\n    --,SubscriptionName\n    ,MeterSubCategory\n    ,Tags\n    --,PricingModel\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202201*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines' and Tags not like '%\"Cluster%' and Tags not like '%\"Kubernetes%' and ServiceInfo2 is NULL --and SubscriptionId = '019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc'\n    --and ResourceId = '/subscriptions/019958ea-fe2c-4e14-bbd9-0d2db8ed7cfc/resourceGroups/MC_AURORA11_AURORA11_NORTHEUROPE/providers/Microsoft.Compute/virtualMachineScaleSets/aks-gpu-36545846-vmss'\n    --group by ServiceInfo2 --, FORMAT ([Date],'yyyy-MM'), \n    --order by count(DISTINCT ResourceId) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/PAYG VM Usage last 30 days')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "declare @thirtydaysago datetime\ndeclare @now datetime\nset @now = getdate()\nset @thirtydaysago = dateadd(day,-30,@now)\n\n    SELECT\n        format([Date],'yyyy-MM-dd') as [Date]\n        ,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n        ,JSON_VALUE(AdditionalInfo, '$.VCPUs') as vCPUs\n        --,AVG(cast(JSON_VALUE(AdditionalInfo, '$.VCPUs') as INT)) as vCPUs\n        ,ProductName\n        ,ResourceLocation\n        ,sum(Quantity) as Quantity\n        ,sum(CostInBillingCurrency) as [PAYG Cost]\n        --,Quantity\n        ,benefitName\n        --,*\n    FROM\n        OPENROWSET(\n            BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20230101-20230131/ACMMonthlyActualCost_20230101-20230131.parquet',\n            FORMAT = 'PARQUET'\n        ) AS [result]\n    where MeterCategory = 'Virtual Machines' and benefitName is null and [Date] >= @thirtydaysago and MeterName not like 'A%'\n    group by [Date], JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.VCPUs'), ProductName, ResourceLocation, benefitName\n\n    UNION\n\n    SELECT\n        format([Date],'yyyy-MM-dd') as [Date]\n        ,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n        ,JSON_VALUE(AdditionalInfo, '$.VCPUs') as vCPUs\n        --,AVG(cast(JSON_VALUE(AdditionalInfo, '$.VCPUs') as INT)) as vCPUs\n        ,ProductName\n        ,ResourceLocation\n        ,sum(Quantity) as Quantity\n        ,sum(CostInBillingCurrency) as [PAYG Cost]\n        --,Quantity\n        ,benefitName\n        --,*\n    FROM\n        OPENROWSET(\n            BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n            FORMAT = 'PARQUET'\n        ) AS [result2]   \n    where MeterCategory = 'Virtual Machines' and benefitName is null and [Date] >= @thirtydaysago and MeterName not like 'A%'\n    group by [Date], JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.VCPUs'), ProductName, ResourceLocation, benefitName\norder by [Date]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Premium SSD Query')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    --*\n    --SubscriptionName\n    --,ResourceGroup\n    --ProductName\n    MeterSubCategory\n    ,ResourceLocation\n    ,MeterName\n    ,UnitPrice\n    --,ProductName\n    --,ResourceName\n    ,sum(Quantity) as Quantity\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202304*/ACMMonthlyActualCost_*.parquet',\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n        (SubscriptionName = 'S009-Desktop-Service TS1' \n        or SubscriptionName = 'S220-Desktop-Service TS2')\n        and ProductName like '%SSD Managed Disks%'\n    group by UnitPrice, MeterSubCategory, MeterName, ResourceLocation--, ResourceName, ResourceGroup, ProductName, ProductName, SubscriptionName\n    order by sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Pricesheet New View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Pricesheets_New\nAS\n\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/pricesheet/New/ArmPriceSheet_Enrollment_LATEST.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Project cost report All Projects')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SAP Cost Report"
				},
				"content": {
					"query": "SELECT\n[ResourceGroup]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n,SUM(ConsumedQuantity) as Quantity\n,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n,JSON_VALUE(AdditionalInfo, '$.ReservationId') as ReservationId\n,[MeterCategory]\n,[MeterSubCategory]\n,[SubscriptionName]\n,substring([Date],0,8) as [Date]\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S138-SAP-Solution-Landscape' AND\n    UPPER(ResourceGroup) IN \n        ('S138-WESB-RG-S02', 'S138-WEDV-RG-D02', 'S138-WEQA-RG-SOX-Q02', 'S138-WEPR-RG-SOX-P02', \n        'S138-WESB-RG-S63', 'S138-WESB-RG-SB3', 'S138-WESB-RG-S83', 'S138-WESB-RG-S12', \n        'S138-WESB-RG-S73', 'S138-WESB-RG-Q73', 'S138-WESB-RG-T73', 'S138-WESB-RG-S43', 'S138-WESB-RG-SOX-S09',\n        'S138-WESB-RG-S08', 'S138-WEDV-RG-D08', 'S138-WEQA-RG-Q08', 'S138-WEPR-RG-P08', 'S138-WEDV-RG-D0T', 'S138-WEPR-RG-P0T',\n        'S138-WEQA-RG-SOX-Q33', 'S138-WESB-RG-SX3', 'S138-WEDV-RG-DX3', 'S138-WEQA-RG-QX3', 'S138-WEPR-RG-SOX-PX3')\n        --and (substring([Date],0,8) >= '2022-01' and substring([Date],0,8) <= '2022-06')\n        and MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM'\nGROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), SubscriptionName, MeterSubCategory, JSON_VALUE(AdditionalInfo, '$.ReservationId'), substring([Date],0,8)\nORDER BY substring([Date],0,8) DESC, sum(ConsumedQuantity) DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Project cost report Beyond RLM')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SAP Cost Report"
				},
				"content": {
					"query": "SELECT\n[ResourceGroup]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n,SUM(ConsumedQuantity) as Quantity\n,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n,JSON_VALUE(AdditionalInfo, '$.ReservationId') as ReservationId\n,[MeterCategory]\n,[MeterSubCategory]\n,[SubscriptionName]\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/08/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S138-SAP-Solution-Landscape' AND\n    UPPER(ResourceGroup) IN ('S138-WESB-RG-S02', 'S138-WEDV-RG-D02', 'S138-WEQA-RG-SOX-Q02', 'S138-WEPR-RG-SOX-P02', \n                            'S138-WESB-RG-S63', 'S138-WESB-RG-SB3', 'S138-WESB-RG-S83', 'S138-WESB-RG-S12')\n    --and (substring([Date],0,8) >= '2022-01' and substring([Date],0,8) <= '2022-06')\n    and MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM'\nGROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), [SubscriptionName],[MeterSubCategory]--, UnitOfMeasure --,substring([Date],0,8)\nORDER BY sum(ConsumedQuantity) DESC --, substring([Date],0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Project cost report Business Integrity Screening - BIS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SAP Cost Report"
				},
				"content": {
					"query": "SELECT\n[ResourceGroup]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n,SUM(ConsumedQuantity) as Quantity\n,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n,JSON_VALUE(AdditionalInfo, '$.ReservationId') as ReservationId\n,[MeterCategory]\n,[MeterSubCategory]\n,[SubscriptionName]\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/08/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S138-SAP-Solution-Landscape' AND\n    UPPER(ResourceGroup) IN ('S138-WESB-RG-S02', 'S138-WEDV-RG-D02', 'S138-WEQA-RG-SOX-Q02', 'S138-WEPR-RG-SOX-P02', \n                            'S138-WESB-RG-S63', 'S138-WESB-RG-SB3', 'S138-WESB-RG-S83', 'S138-WESB-RG-S12')\n    --and (substring([Date],0,8) >= '2022-01' and substring([Date],0,8) <= '2022-06')\n    and MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM'\nGROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), [SubscriptionName],[MeterSubCategory]--, UnitOfMeasure --,substring([Date],0,8)\nORDER BY sum(ConsumedQuantity) DESC --, substring([Date],0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Project cost report Kalundborg IT Separation Project - KITS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SAP Cost Report"
				},
				"content": {
					"query": "SELECT\n[ResourceGroup]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n,SUM(ConsumedQuantity) as Quantity\n,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n,JSON_VALUE(AdditionalInfo, '$.ReservationId') as ReservationId\n,[MeterCategory]\n,[MeterSubCategory]\n,[SubscriptionName]\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/08/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S138-SAP-Solution-Landscape' AND\n    UPPER(ResourceGroup) IN ('S138-WESB-RG-S02', 'S138-WEDV-RG-D02', 'S138-WEQA-RG-SOX-Q02', 'S138-WEPR-RG-SOX-P02', \n                            'S138-WESB-RG-S63', 'S138-WESB-RG-SB3', 'S138-WESB-RG-S83', 'S138-WESB-RG-S12')\n    --and (substring([Date],0,8) >= '2022-01' and substring([Date],0,8) <= '2022-06')\n    and MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM'\nGROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), [SubscriptionName],[MeterSubCategory]--, UnitOfMeasure --,substring([Date],0,8)\nORDER BY sum(ConsumedQuantity) DESC --, substring([Date],0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Project cost report NextGen ERP')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SAP Cost Report"
				},
				"content": {
					"query": "SELECT\n[ResourceGroup]\n--,substring([Date],0,8) as [Date]\n--,sum([Cost]) as Cost\n,SUM(ConsumedQuantity) as Quantity\n,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n,JSON_VALUE(AdditionalInfo, '$.ReservationId') as ReservationId\n,[MeterCategory]\n,[MeterSubCategory]\n,[SubscriptionName]\nFROM\n    OPENROWSET(\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/08/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S138-SAP-Solution-Landscape' AND\n    UPPER(ResourceGroup) IN ('S138-WESB-RG-S02', 'S138-WEDV-RG-D02', 'S138-WEQA-RG-SOX-Q02', 'S138-WEPR-RG-SOX-P02', \n                            'S138-WESB-RG-S63', 'S138-WESB-RG-SB3', 'S138-WESB-RG-S83', 'S138-WESB-RG-S12')\n    --and (substring([Date],0,8) >= '2022-01' and substring([Date],0,8) <= '2022-06')\n    and MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM'\nGROUP BY [MeterCategory], ResourceGroup, JSON_VALUE(AdditionalInfo, '$.ServiceType'), [SubscriptionName],[MeterSubCategory]--, UnitOfMeasure --,substring([Date],0,8)\nORDER BY sum(ConsumedQuantity) DESC --, substring([Date],0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Purchase')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    format([Date], 'yyyy-MM') as [Date]\n    ,MeterCategory\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2023*/ACMMonthlyAc*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where PricingModel = 'Reservation' and ChargeType = 'Purchase' \n    and (format([Date], 'yyyy-MM') = '2023-04' or format([Date], 'yyyy-MM') = '2023-05' or format([Date], 'yyyy-MM') = '2023-06')\n    group by format([Date], 'yyyy-MM'), MeterCategory\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Savings Calc')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 *,\n    --ChargeType\n    --,EffectivePrice\n    --,UnitPrice\n    --,Quantity\n    --,(UnitPrice - EffectivePrice) * Quantity as [Cost Saving]\n    --,IsRIUsage\n    sum((UnitPrice - EffectivePrice) * Quantity) as [Cost Saving Total]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/202*/Extended_v2_ACMMonthlyAmortizedCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where (IsRIUsage = 'RI Usage' or ChargeType = 'UnusedReservation')\n    and [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Savings')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Used RI savings - Unused RI cost\nUsed RI is where IsRIUsage = 'RI Usage'\nUnused RI is where ChargeType = 'UnusedReservation'\nWhen an RI is unused in the Amortized file the UnitPrice is 0 which means the sum((UnitPrice - EffectivePrice) * Quantity) as [Cost Saving Total] calculation can be used to calculate both the saving and the cost in the same line",
				"folder": {
					"name": "--RI & HUB Savings/New API/2023"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 \n    --ChargeType\n    --EffectivePrice\n    --,UnitPrice\n    --,Quantity\n    --,(UnitPrice - EffectivePrice) * Quantity as [Cost Saving]\n    --,IsRIUsage\n    sum((UnitPrice - EffectivePrice) * Quantity) as [Cost Saving Total]\n    --sum((EffectivePrice) * Quantity) as [Cost Saving Total]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/202*/Extended_v2_ACMMonthlyAmortizedCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where (IsRIUsage = 'RI Usage' or ChargeType = 'UnusedReservation')\n    and [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\n    and upper(benefitName) like 'S037%' -- filtering for the S037 reservations\n    --and upper(benefitName) not like 'S037%'  -- filtering for the non S037 reservations i.e. the SAP single scope reservations\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Usage March 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --ReservationName\n    --,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    --avg(UnitPrice) as UnitPrice\n    --,EffectivePrice as EffectivePrice\n    --,sum(UnitPrice * Quantity) as [PAYG Cost]\n    --,sum(EffectivePrice * Quantity) as [RI Cost]\n    --,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    sum(Quantity) as Quantity    \n    ,sum(CostInBillingCurrency) as Cost\n    --,SubscriptionId\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/202303*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere \n    ChargeType = 'Usage' \n    and PricingModel = 'Reservation' \n    and (ReservationName like 'S037_%' OR ReservationName like 'VM_RI_%')\n    --and SubscriptionId = '13d66f54-0a19-4912-b4f3-54d15897368d'\n    --and ConsumedService = 'Microsoft.Sql'\n\n--group by ReservationName, format([Date],'yyyy-MM')\n--GROUP by format([Date],'yyyy-MM'), ReservationName, SubscriptionId\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI Usage')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    format([Date], 'yyyy-MM') as [Date]\n    ,MeterCategory\n    --,MeterSubCategory\n    --,ResourceLocation\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2023*/ACMMonthlyAm*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where PricingModel = 'Reservation' and ChargeType = 'Usage' and ReservationName like 'S037%'\n    and (format([Date], 'yyyy-MM') = '2023-04' or format([Date], 'yyyy-MM') = '2023-05' or format([Date], 'yyyy-MM') = '2023-06')\n    group by format([Date], 'yyyy-MM'), MeterCategory--, MeterSubCategory, ResourceLocation\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI_VM_Savings View')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW RI_VM_Savings\nAS\n\nSELECT\n    *\n\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/savings/monthly/*/*/*-RI-VM.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Reservation Cost - Json')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    jsonContent,\n    JSON_VALUE (jsonContent, '$.armSkuName') AS armSkuName,\n    JSON_VALUE (jsonContent, '$.term') AS term,\n    JSON_VALUE (jsonContent, '$.region') AS region,\n    JSON_VALUE (jsonContent, '$.eventDate') AS eventDate,\n    JSON_VALUE (jsonContent, '$.reservationOrderId') AS reservationOrderId,\n    JSON_VALUE (jsonContent, '$.description') AS [description],\n    JSON_VALUE (jsonContent, '$.quantity') AS quantity,\n    JSON_VALUE (jsonContent, '$.amount') AS amount,\n    JSON_VALUE (jsonContent, '$.reservationOrderName') AS reservationOrderName,\n    JSON_VALUE (jsonContent, '$.billingFrequency') AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2022/*/costreport_reservations_monthly_*.json',\n        FORMAT = 'CSV',\n        FIELDQUOTE = '`',\n        FIELDTERMINATOR ='0x0b',\n        ROWTERMINATOR = '},'\n    )\n    WITH (\n        jsonContent nvarchar(MAX),\n        armSkuName varchar(MAX),\n        term varchar(MAX),\n        region varchar(MAX),\n        eventDate varchar(MAX),\n        reservationOrderId nvarchar(MAX),\n        [description] varchar(MAX),\n        quantity varchar(MAX),\n        amount varchar(MAX),\n        reservationOrderName varchar(MAX),\n        billingFrequency varchar(MAX)\n    )\n    AS [result]\n    --where armSkuName NOT LIKE 'SQL%'\n    --where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\n    order by eventDate\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Reservation Costs 2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    armSkuName AS armSkuName,\n    term AS term,\n    region AS region,\n    substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11) AS eventDate,\n    reservationOrderId AS reservationOrderId,\n    description AS [description],\n    quantity AS quantity,\n    amount AS amount,\n    reservationOrderName AS reservationOrderName,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/tempdata/annual/2021/reservation_cost.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\norder by substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Reservation Details Query - Json')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT TOP 100\n    jsonContent,\n    JSON_VALUE (jsonContent, '$.skuName') AS skuName,\n    JSON_VALUE (jsonContent, '$.reservationId') AS reservationId,\n    JSON_VALUE (jsonContent, '$.usageDate') AS usageDate,\n    JSON_VALUE (jsonContent, '$.totalReservedQuantity') AS totalReservedQuantity,\n    JSON_VALUE (jsonContent, '$.reservedHours') AS reservedHours,\n    JSON_VALUE (jsonContent, '$.usedHours') AS usedHours\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/validation/2022/02/02/costreport_reservation_details_validation.json',\n        FORMAT = 'CSV',\n        FIELDQUOTE = '\\',\n        FIELDTERMINATOR ='0x0b',\n        ROWTERMINATOR = '},'\n    )\n    WITH (\n        jsonContent nvarchar(MAX)\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Resources by ConsumedService')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "FinOps/Focus"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 *\n    --,ResourceType\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20230901-20230930/ACMMonthlyActualCost_3e81fc63-88df-4871-9972-3da13e27b6cd.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\n    where ConsumedService = 'Virtual Network'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Ronny - Naz which WBS are list of VMs being charged to')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    ResourceName\n    ,[Date]\n    ,Tags\n    ,AdditionalInfo\n    ,ResourceId\n--FROM\n--    OPENROWSET(\n--        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n--        FORMAT = 'PARQUET'\n--    ) AS [result]\n\nFROM [dbo].[Combined_Actual_Savings]\n\nwhere \n--[Date] = '2023-02-06' \nMeterCategory = 'Virtual Machines' --and Tags like '%\"CostAllocationType\": \"TOBESPECIFIED\"%' \n    and UPPER(ResourceId) in (\n    '/SUBSCRIPTIONS/061F6DAA-2AFE-427D-B3A5-A1919906D96F/RESOURCEGROUPS/CITRIX-XD-EEF89BD2-6D27-4BF6-95DA-AC4E20DC96A0-NNIFG/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4401',\n    '/SUBSCRIPTIONS/061F6DAA-2AFE-427D-B3A5-A1919906D96F/RESOURCEGROUPS/CITRIX-XD-EEF89BD2-6D27-4BF6-95DA-AC4E20DC96A0-NNIFG/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4402',\n    '/subscriptions/5f9dec8c-8bfd-40e1-b7c7-85fa538f77ed/resourceGroups/CITRIX-XD-A8EAF411-41E7-4C36-AFDB-0566B37EC488-4OVXF/providers/Microsoft.Compute/virtualMachines/MMP-TS4301',\n    '/subscriptions/5f9dec8c-8bfd-40e1-b7c7-85fa538f77ed/resourceGroups/CITRIX-XD-A8EAF411-41E7-4C36-AFDB-0566B37EC488-4OVXF/providers/Microsoft.Compute/virtualMachines/MMP-TS4302',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4201',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4202',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4203',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4204',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4205',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4206',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4207',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4208',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4209',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4210',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4211',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4212',\n    '/SUBSCRIPTIONS/5F9DEC8C-8BFD-40E1-B7C7-85FA538F77ED/RESOURCEGROUPS/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/PROVIDERS/MICROSOFT.COMPUTE/VIRTUALMACHINES/MMP-TS4213')\n    order by [Date]\n  ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Ronny CVD VM Cost Report')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT \n[ResourceName]\n,[ServiceInfo2]\n,[Date]\n,[MeterCategory]\n,[MeterSubCategory]\n,[Quantity]\n,[EffectivePrice]\n,[CostInBillingCurrency]\n,[UnitPrice]\n,[SubscriptionId]\n,[SubscriptionName]\n,[ResourceGroup]\n,[PublisherType]\n,[PublisherName]\n,[ReservationId]\n,[ReservationName]\n,[ResourceId]\n,[AdditionalInfo]\n,[MeterName]\n,[MeterRegion]\n,[UnitOfMeasure]\n,[ResourceLocation]\n,[ProductName]\n,[MeterId]\n FROM [dbo].[Combined_Actual_Savings]\nwhere upper(ResourceName) in ('CVD-240002', 'CVD-240003', 'CVD-240007', 'CVD-240008', 'CVD-240013', \n                        'CVD-240022', 'CVD-240026', 'CVD-240029', 'CVD-240030', 'CVD-240032', \n                        'CVD-240033', 'CVD-240037', 'CVD-240039', 'CVD-240040', 'CVD-240042', \n                        'CVD-240043', 'CVD-240044', 'CVD-240045', 'CVD-240049', 'CVD-240050') \n        and [Date] >= '2023-01-28' and MeterCategory = 'Virtual Machines'",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Ronny MMP VM ResourceId Report')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT --DISTINCT\nResourceName\n,ResourceId\n,Tags\n,SubscriptionName\n,[Date]\nFROM [dbo].[Combined_Actual_Savings]\nwhere upper(ResourceName) in (--'MMP-TS4401', 'MMP-TS4402',\n                        'MMP-TS4302', 'MMP-TS4301') \n        --and [Date] >= '2023-01-01' \n        and MeterCategory = 'Virtual Machines'\n--group by ResourceName,ResourceId,Tags, SubscriptionName",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S009 and S220 Cost Query')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    SubscriptionName,\n    ResourceName,\n    ResourceGroup,\n    [Date] as Date,\n    substring([Date],7,4) + '-' + substring([Date],1,2) + '-' + substring([Date],4,2)  as FormattedDate,\n    substring([Date],7,4) + '-' + substring([Date],1,2) as [ShortDate],\n    ResourceLocation,\n    UnitOfMeasure,\n    Quantity,\n    CostInBillingCurrency,\n    EffectivePrice,\n    UnitPrice,\n    PayGPrice,    \n    ProductName,\n    MeterCategory,\n    MeterSubCategory,\n    MeterName,   \n    ServiceInfo1,\n    ServiceInfo2,\n    ReservationId,\n    ReservationName,     \n    PartNumber,\n    PlanName,\n    Term,\n    CostCenter,\n    ConsumedService,\n    ResourceId,\n    Tags,\n    OfferId,\n    AdditionalInfo,\n    PublisherType,\n    PublisherName,\n    ChargeType,\n    Frequency,\n    PricingModel,\n    ServiceFamily,\n    benefitId,\n    benefitName,\n    SubscriptionId\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2022*/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S009-Desktop-Service TS1' or SubscriptionName = 'S220-Desktop-Service TS2' and substring([Date],7,4) + '-' + substring([Date],1,2) >= '2022-05'\n        and substring([Date],7,4) + '-' + substring([Date],1,2) <= '2022-08'\n--order by FormattedDate\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S034 VM Cost Actual')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "S034 VM Cost Investigation"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    *\n    --count(SubscriptionName)\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S034-Geology-Geophysics' and \n    MeterCategory = 'Virtual Machines' --and ServiceInfo2 LIKE '%BYOL' --and Product LIKE '%Spot%'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S034 VM Cost Amortised')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "S034 VM Cost Investigation"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *\n        JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs,\n    substring([Date],7,4) + '-' + substring([Date],1,2) + '-' + substring([Date],4,2) as [Date],\n    PartNumber,\n    UnitOfMeasure,\n    ProductName,\n    MeterCategory,\n    MeterSubCategory,\n    MeterName,\n    ServiceInfo2,\n    --sum(Quantity) as Quantity,\n    Quantity as Quantity,\n    --sum(EffectivePrice) as EffectivePrice,\n    EffectivePrice as EffectivePrice,\n    --sum(CostInBillingCurrency) as CostInBillingCurrency, \n    CostInBillingCurrency as CostInBillingCurrency, \n    UnitPrice,\n    --sum(PayGPrice) as PayGPrice,\n    PayGPrice as PayGPrice,\n    benefitName,\n    ResourceName,\n    ResourceLocation,\n    ResourceId\n    --count(SubscriptionName)\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2022*/ACMMonthlyAmortizedCost_2022*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere SubscriptionName = 'S034-Geology-Geophysics' and MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE '%BYOL' --and Product LIKE '%Spot%'\n--group by JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.VCPUs'), \n--        substring([Date],7,4) + '-' + substring([Date],1,2), PartNumber, UnitOfMeasure, ProductName, MeterCategory, \n--        MeterSubCategory, MeterName, ServiceInfo2, UnitPrice, benefitName, ServiceInfo2\norder by substring([Date],7,4) + '-' + substring([Date],1,2)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S037 Resources')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQL HUB Issue"
				},
				"content": {
					"query": "SELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/daily/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE SubscriptionGuid = '13d66f54-0a19-4912-b4f3-54d15897368d' and \n(ResourceGroup = 'Hub-Investigation-SQLDB-NoHUB' or \nResourceGroup = 'HUB-Investigation-MI' or \nResourceGroup = 'Hub-Investigation2')\norder by [Date] DESC\n\n--/subscriptions/A6ABE45D-E638-4325-A7E9-5559450AA434/resourceGroups/SQL-MI-NE/providers/Microsoft.Sql/managedInstances/sql-mi01\n\n\n--WHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE '%BYOL' --and Product LIKE '%Spot%'\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), PartNumber, Product\n--ORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/S162 Cost Investigation')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    [Date],\n    PartNumber,\n    ResourceRate,\n    ConsumedQuantity,\n    Cost,\n    ServiceTier,\n    SubscriptionName,\n    ResourceGroup\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/2022/*/*.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nWHERE SubscriptionName = 'S162-EDM-DataCatalog' AND ResourceGroup = 'CoreResources' and [Date] > '2022-05-27T00:00:00.0000000'\norder by [Date]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL HUB 2022 New API')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 100 \n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.AHB') as AHB, \n    JSON_VALUE(AdditionalInfo, '$.vCores') as vCores, \n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs, \n    MeterCategory,\n    MeterSubCategory,\n    format([Date], 'yyyy-MM') as [Date], \n    sum(Quantity) as Quantity,\n    --PartNumber,\n    ProductName\n    ,ResourceId\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'True') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory LIKE '%Hybrid%') \n--WHERE JSON_VALUE(AdditionalInfo, '$.AHB') = 'True' or MeterSubCategory LIKE '%Hybrid%'\n\n-----Below line extracts non HUB SQL entries for testing & investigation purposes\n--WHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'False') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory NOT LIKE '%Hybrid%') and Product LIKE 'SQL Server%' and Product NOT LIKE 'SQL Server Express%'\n\nGROUP BY  JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.AHB'), JSON_VALUE(AdditionalInfo, '$.vCores'), JSON_VALUE(AdditionalInfo, '$.VCPUs'), MeterCategory, MeterSubCategory, format([Date], 'yyyy-MM'), ProductName, ResourceId\nORDER BY format([Date], 'yyyy-MM'), Quantity DESC\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL HUB 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "SELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.AHB') as AHB, \n    JSON_VALUE(AdditionalInfo, '$.vCores') as vCores, \n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs, \n    MeterCategory,\n    MeterSubCategory,\n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    --PartNumber,\n    Product,\n    InstanceId\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n--WHERE MeterCategory LIKE 'SQL%'\n\n-----Due to MS bug where SQL DB's with HUB applied are identified as SQL MI DB's we are only querying for SQL MI and SQL VM below. If MS fix the bug the correct query for SQL DB with HUB will need to be identified and added to the where section of the query\n\nWHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'True') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory LIKE '%Hybrid%') \n\n-----Below line extracts non HUB SQL entries for testing & investigation purposes\n--WHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'False') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory NOT LIKE '%Hybrid%') and Product LIKE 'SQL Server%' and Product NOT LIKE 'SQL Server Express%'\n\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), MeterSubCategory, PartNumber, Product, JSON_VALUE(AdditionalInfo, '$.AHB'), InstanceId, JSON_VALUE(AdditionalInfo, '$.vCores'), MeterCategory, JSON_VALUE(AdditionalInfo, '$.VCPUs')\nORDER BY substring([Date],0,8), ConsumedQuantity DESC\n--order by CAST(JSON_VALUE(AdditionalInfo, '$.VCPUs') as int) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL HUB using Extended parquet')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2023"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    ai_ServiceType as ServiceType, \n    ai_AHB as AHB, \n    ai_vCores as vCores, \n    ai_VCPUs as VCPUs, \n    MeterCategory,\n    MeterSubCategory,\n    format([Date], 'yyyy-MM') as [Short Date], \n    sum(Quantity) as Quantity,\n    --PartNumber,\n    ProductName,\n    ResourceId\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202*/Extended_v2_ACMMonthlyActualCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE (MeterCategory = 'SQL Managed Instance' and ai_AHB = 'True') \nor (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory LIKE '%Hybrid%') \nand format([Date], 'yyyy-MM') >= '2022-11' and format([Date], 'yyyy-MM') <= '2023-10' \n--WHERE JSON_VALUE(AdditionalInfo, '$.AHB') = 'True' or MeterSubCategory LIKE '%Hybrid%'\n\n-----Below line extracts non HUB SQL entries for testing & investigation purposes\n--WHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'False') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory NOT LIKE '%Hybrid%') and Product LIKE 'SQL Server%' and Product NOT LIKE 'SQL Server Express%'\n\nGROUP BY  ai_ServiceType, ai_AHB, ai_vCores, ai_VCPUs, MeterCategory, MeterSubCategory, format([Date], 'yyyy-MM'), ProductName, ResourceId\nORDER BY format([Date], 'yyyy-MM'), Quantity DESC\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL Licence query')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    SubscriptionName\n    ,ResourceGroup\n    ,ProductName\n    ,ResourceName\n    --,Quantity\n    --,UnitPrice\n    --,benefitName\n    ,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202305*/ACMMonthlyActualCost_*.parquet',\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n        (SubscriptionName = 'S009-Desktop-Service TS1' \n        or SubscriptionName = 'S220-Desktop-Service TS2')\n        and MeterCategory = 'Virtual Machines Licenses'\n        and ProductName like 'SQL%'\n        and (ProductName not like 'SQL Server Dev%' AND ProductName not like 'SQL Server Ex%')\n        --and ResourceName = 'CVD-200661'\n    group by SubscriptionName, ResourceGroup, ProductName, ResourceName--, Quantity, UnitPrice, benefitName\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "SELECT\n    [Location] as [Location],\n    ResourceLocation,\n    JSON_VALUE(AdditionalInfo, '$.AHB') as AHB,\n    JSON_VALUE(AdditionalInfo, '$.vCores') as vCores, \n    MeterSubCategory,\n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product,\n    InstanceId,\n    AdditionalInfo\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n--WHERE ServiceInfo2 NOT LIKE 'Windows%' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\n--WHERE (MeterCategory = 'SQL Managed Instance' and JSON_VALUE(AdditionalInfo, '$.AHB') = 'True') or (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory LIKE '%Hybrid%')\n--WHERE InstanceId = '/subscriptions/f9892073-3b09-40b7-8f33-1e0320e683c8/resourceGroups/rg-echomodeldist-test/providers/Microsoft.Sql/servers/sql-echomodeldist-test/databases/sql-echomodeldist-test/sqldb-echomodeldist-test'\n--WHERE ResourceGroup = 'equr-ep-dev-cmn-01'\n--WHERE ResourceGroup = 'master-rg-tst'\nWHERE MeterSubCategory = 'Compute Reservation' --and ServiceTier = 'SQL RI'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), MeterSubCategory, PartNumber, Product, JSON_VALUE(AdditionalInfo, '$.AHB'), InstanceId, JSON_VALUE(AdditionalInfo, '$.vCores'), AdditionalInfo, [Location], ResourceLocation, ServiceTier\nORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI Cost 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    reservationOrderId AS reservationOrderId,\n    reservationOrderName AS reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    substring(eventDate,0,11) AS eventDate,\n    quantity AS quantity,\n    amount AS amount,\n    currency,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/reservations/2022/*/reservation-charges.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\nwhere reservationOrderName LIKE '%SQL%' --and reservationOrderId != 'd5b99270-d26e-49b1-82dc-d7cb16a9181a'\norder by substring(eventDate,0,11)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI Purchases 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 *\n    ReservationId\n    ,ReservationName\n    ,SubscriptionName\n    ,format([Date], 'yyyy-MM') as [Date]\n    ,MeterSubCategory\n    ,Term\n    ,ChargeType\n    ,Quantity\n    ,UnitPrice\n    ,CostInBillingCurrency\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Purchase' and PricingModel = 'Reservation' and MeterCategory like 'SQL%' --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI Purchases MArch 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 *\n    ReservationId\n    ,ReservationName\n    ,SubscriptionName\n    ,format([Date], 'yyyy-MM') as [Date]\n    ,MeterSubCategory\n    ,Term\n    ,ChargeType\n    ,Quantity\n    ,UnitPrice\n    ,CostInBillingCurrency\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Purchase' and PricingModel = 'Reservation' and MeterCategory like 'SQL%' --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI Usage 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    ReservationName\n    ,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    ,avg(UnitPrice) as UnitPrice\n    --,EffectivePrice as EffectivePrice\n    ,sum(Quantity) as Quantity\n    ,sum(UnitPrice * Quantity) as [PAYG Cost]\n    ,sum(EffectivePrice * Quantity) as [RI Cost]\n    ,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Usage' and PricingModel = 'Reservation' and ConsumedService = 'Microsoft.Sql'\ngroup by ReservationName, format([Date],'yyyy-MM')\norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL RI Usage March 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    ReservationName\n    ,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    ,avg(UnitPrice) as UnitPrice\n    --,EffectivePrice as EffectivePrice\n    ,sum(Quantity) as Quantity\n    ,sum(UnitPrice * Quantity) as [PAYG Cost]\n    ,sum(EffectivePrice * Quantity) as [RI Cost]\n    ,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Usage' and PricingModel = 'Reservation' and ConsumedService = 'Microsoft.Sql'\ngroup by ReservationName, format([Date],'yyyy-MM')\norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL VM HUB and PAYG Example')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings"
				},
				"content": {
					"query": "SELECT\n    TOP 100 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2024*/Extended_v3_ACMMonthlyActualCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    MeterCategory = 'Virtual Machines Licenses'\n    and ResourceId = '/subscriptions/8b96ae86-c1d5-4668-bf1c-e1b120b18b17/resourceGroups/S077-NOE-EMI-TST/providers/Microsoft.Compute/virtualMachines/S077WEMID1T'\n    and [Date] in ('2024-01-07', '2024-01-08', '2024-01-09')\n    \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 43')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "VM's with a VM name starting with an A are excluded",
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "declare @thirtydaysago datetime\ndeclare @now datetime\nset @now = getdate()\nset @thirtydaysago = dateadd(day,-30,@now)\n\nSELECT\n    format([Date],'yyyy-MM-dd') as [Date]\n    ,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    ,JSON_VALUE(AdditionalInfo, '$.VCPUs') as vCPUs\n    --,AVG(cast(JSON_VALUE(AdditionalInfo, '$.VCPUs') as INT)) as vCPUs\n    ,ProductName\n    ,MeterCategory\n    ,MeterSubCategory\n    --,sum(Quantity) as Quantity\n    --,sum(Quantity) * AVG(cast(JSON_VALUE(AdditionalInfo, '$.VCPUs') as INT)) as [Normalised Quantity]\n    ,Quantity\n    ,benefitName\n    ,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20230101-20230131/ACMMonthlyActualCost_20230101-20230131.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere MeterCategory = 'Virtual Machines' and benefitName is null and [Date] >= @thirtydaysago and MeterName not like 'A%'\n--group by [Date], JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.VCPUs'), ProductName, benefitName\norder by format([Date],'yyyy-MM-dd')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SQL script 51')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    TOP 10 \n    UnitPrice, \n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20240101-20240131/Extended_v3_ACMMonthlyActualCost_20240101-20240131.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where benefitName like 'Compute%'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Saving Plan Usage - Actual Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    SubscriptionName\n    ,ResourceGroup\n    ,ResourceLocation\n    ,[Date]\n    ,MeterCategory\n    ,MeterSubCategory\n    ,MeterName\n    ,UnitOfMeasure\n    ,ChargeType\n    ,PricingModel\n    ,benefitName\n    ,Quantity\n    ,EffectivePrice\n    ,UnitPrice\n    ,CostInBillingCurrency\n    ,PayGPrice\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyAmortizedCost/20221101-20221130/ACMDailyAmortizedCost_c2efb564-3599-4f9d-a5a8-800a769844e3.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nwhere ChargeType = 'Usage' and PricingModel = 'SavingsPlan'\norder by [Date] DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Saving Plan Usage - Amortised')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    SubscriptionName\n    ,ResourceGroup\n    ,ResourceLocation\n    ,[Date]\n    ,MeterCategory\n    ,MeterSubCategory\n    ,MeterName\n    ,UnitOfMeasure\n    ,ChargeType\n    ,PricingModel\n    ,benefitName\n    ,Quantity\n    ,EffectivePrice\n    ,UnitPrice\n    ,Quantity * UnitPrice as PAYG_Cost\n    ,Quantity * EffectivePrice as SP_Amount_Consumed\n    ,(Quantity * UnitPrice) - (Quantity * EffectivePrice) as Saving\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyAmortizedCost/20221101-20221130/ACMDailyAmortizedCost_c2efb564-3599-4f9d-a5a8-800a769844e3.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nwhere ChargeType = 'Usage' and PricingModel = 'SavingsPlan'\norder by [Date] DESC\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SavingPlanPurchaseCharges')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/20221101-20221130/ACMDailyActualCost_364ce664-c75b-437f-83c4-c74d393e6da3.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\nwhere PricingModel = 'SavingsPlan' and ChargeType = 'Purchase' --and SubscriptionName = 'S037-Cost-Management-reservations'\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SavingsPlanUnusedCapacity')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyAmortizedCost/20221101-20221130/ACMDailyAmortizedCost_c2efb564-3599-4f9d-a5a8-800a769844e3.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\n--where [Date] = '11/02/2022'\nwhere PricingModel = 'SavingsPlan' and ChargeType = 'UnusedSavingsPlan' --and SubscriptionName = 'S037-Cost-Management-reservations'\norder by [Date]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Sentinel Pricing')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    MeterName\n    ,UnitPrice\n    ,UnitOfMeasure\n    ,PartNumber\n    ,BasePrice\n    ,MarketPrice\n    ,MeterType\n    ,MeterCategory\n    ,ServiceFamily\n    ,Product\n    ,MeterRegion\n\n    --distinct(ServiceFamily)\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/pricesheet/portal-export/pricesheet-latest/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n    MeterCategory = 'Sentinel'\n    and OfferID = 'MS-AZR-0017P'\n    and MeterRegion = 'EU West'\n    and MeterName not like '%Classic%'\n    order by UnitPrice\n    \n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/SingularMonthly')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsNotInUse"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_SingularMonthly\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/aggregate/parquet/SingularMonthly.parquet/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Std vs Prem Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "SELECT\n    --*\n    --SubscriptionName\n    --,ResourceGroup\n    --ProductName\n    MeterCategory\n    ,MeterSubCategory\n    --,ResourceLocation\n    --,MeterName\n    --,ProductName\n    --,UnitPrice\n    --,ProductName\n    --,ResourceName\n    --,UnitOfMeasure\n    --,format(sum(Quantity), 'N', 'en-us') as Quantity\n    ,format(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        --BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where \n        ProductName like '%SSD Managed Disks%'\n        and MeterName like '%Disk%'\n        and MeterName <> 'Disk Operations'\n    group by MeterCategory, MeterSubCategory--, UnitOfMeasure--, ProductName --MeterName --, ResourceLocation--, ResourceName, ResourceGroup, ProductName, ProductName, SubscriptionName, UnitPrice,\n    order by sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage - Blob Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    --TOP 100 *\n    ResourceName\n    --,format([Date], 'yyyy-MM-dd') as [Date]\n    ,MeterCategory\n    ,MeterSubCategory\n    ,MeterName\n    ,UnitOfMeasure\n    ,sum(Quantity) as Quantity\n    ,UnitPrice\n    ,EffectivePrice\n    ,sum(CostInBillingCurrency) as CostInBillingCurrency\n    ,PartNumber\n    ,PlanName\n    ,ResourceLocation\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20230301-20230331/ACMMonthlyActualCost_20230301-20230331.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where SubscriptionId = '66638e28-3650-4b8c-a097-c0945a79fd90' \n        and MeterCategory = 'Storage'\n        and ResourceName = 'asdashared'\n        and MeterSubCategory = 'Tiered Block Blob'\n        and MeterName like '%Data Stored'\n    group by \n        ResourceName\n        --format([Date], 'yyyy-MM-dd')\n        ,MeterCategory\n        ,MeterSubCategory\n        ,MeterName\n        ,UnitOfMeasure\n        --,Quantity\n        ,UnitPrice\n        ,EffectivePrice\n        --,CostInBillingCurrency\n        ,PartNumber\n        ,PlanName\n        ,ResourceLocation",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage for ISG')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    MeterCategory,\n    MeterName,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost,\n    UnitOfMeasure\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Azure Data Share' or \n    MeterCategory = 'Azure NetApp Files' OR\n    MeterCategory = 'Backup' OR\n    MeterCategory = 'Storage' OR\n    MeterCategory = 'StorSimple'\nGROUP BY MeterCategory, MeterName, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), UnitOfMeasure\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory\n\n\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Account_from_Parquet')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    Redundancy,\n    sum(StorageInGb) as StorageInGb\nFROM\n    OPENROWSET(\n        BULK 'https://omniadlseun.dfs.core.windows.net/dls/enterprise/data/IT-Asset/InformationAssets/OmniaFacts/Dataset/AcdcDataset/AzureStorageAccountSizeByRedundancy/2022/03/AzureStorageSizeByRedundancy/part-00000-ecca91e8-c471-4ee4-ad71-8e0ba8d5c669-c000.snappy.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) LIKE '2021%'\nGROUP by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), Redundancy\norder by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Cost_Count_2021-04_2022-03')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/12 month period"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n    HEADER_ROW = TRUE\n    ) AS [result]\nWHERE \n    [result].[MeterCategory] = 'Storage' AND\n    [result].[MeterSubCategory] NOT LIKE '%Bandwidth%' AND\n    ([result].[Date] BETWEEN '2021-04-01' and '2022-03-31')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Cost_Count_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n    HEADER_ROW = TRUE\n    ) AS [result]\nWHERE \n    [result].[MeterCategory] = 'Storage' and \n    [result].[MeterSubCategory] NOT LIKE '%Bandwidth%'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Cost_by_MeterSubCategory_2021-04_2022-03')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/12 month period"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(Cost), [MeterSubCategory]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/*/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n    HEADER_ROW = TRUE\n    ) AS [result]\nWHERE   \n    [result].[MeterCategory] = 'Storage' and \n    [result].[MeterSubCategory] NOT LIKE '%Bandwidth%' and \n    ([result].[Date] BETWEEN '2021-04-01' and '2022-03-31')\nGROUP by [MeterSubCategory]\nORDER by sum(Cost) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Cost_by_MeterSubCategory_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    [MeterSubCategory], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    UnitOfMeasure,\n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n    HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Storage' and UnitOfMeasure LIKE '%GB/Month'\nGROUP by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterSubCategory, UnitOfMeasure\nORDER by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), sum(Cost) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Storage_Data_Stored_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) AS [Date],\n    MeterName,\n    sum(ConsumedQuantity) AS ConsumedQuantity\n    --UnitOfMeasure\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--WHERE MeterCategory = 'Storage' AND ServiceTier = 'Tables' and Product NOT LIKE '%Operations%'\nWHERE MeterCategory = 'Storage' AND (MeterName LIKE '%Data Stored' or MeterName LIKE '%Index')\n--WHERE MeterName LIKE 'Data Stored' \nGROUP BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterName\norder by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Tag Investigation')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    COUNT(AccountId)\n    --JSON_VALUE(Tags, '$.CostAllocationType') as CostAllocationType\n    --Tags\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/2022/05/ca8464bb-18e5-42b1-a4e6-7b193ee4d366.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--where UPPER(JSON_VALUE(Tags, '$.CostAllocationType')) = 'CI' \n--UPPER(JSON_VALUE(Tags, '$.CostAllocationType')) != '' AND\n--UPPER(JSON_VALUE(Tags, '$.CostAllocationType')) != 'WBS' AND\n--UPPER(JSON_VALUE(Tags, '$.CostAllocationType')) != 'APPID' AND\n--UPPER(JSON_VALUE(Tags, '$.CostAllocationType')) != 'TOBESPECIFIED' \n\n--where upper(Tags) LIKE '%COSTALLOCATIONTYPE%'\n\n--where JSON_VALUE(UPPER(Tags), '$.COSTALLOCATIONTYPE') = 'CI' \n--JSON_VALUE(UPPER(Tags), '$.COSTALLOCATIONTYPE') = ''\n--JSON_VALUE(UPPER(Tags), '$.COSTALLOCATIONTYPE') = 'WBS'\n--JSON_VALUE(UPPER(Tags), '$.COSTALLOCATIONTYPE') = 'APPID'\n--JSON_VALUE(UPPER(Tags), '$.COSTALLOCATIONTYPE') = 'TOBESPECIFIED' ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Testing VM states for HUB')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Management API"
				},
				"content": {
					"query": "SELECT\n    --top 1000\n    --JSON_VALUE(AdditionalInfo, '$.vCores') as vCores, \n    --avg(JSON_VALUE(AdditionalInfo, '$.VCPUs')) as VCPUs,\n    --MeterCategory, \n    --MeterSubCategory, \n    --ServiceInfo2, \n    --PartNumber,\n    --ReservationName,\n    --Quantity,\n    --UnitOfMeasure, \n    --MeterName,\n    --ProductName,\n    --[Date],\n    --ResourceGroup, \n    --ResourceName, \n    --ResourceId\n    max(MeterCategory), \n    max(MeterSubCategory), \n    ServiceInfo2, \n    max(PartNumber),\n    max(ReservationName),\n    sum(Quantity) as Quantity,\n    max(UnitOfMeasure), \n    max(MeterName),\n    max(ProductName),\n    [Date],\n    max(ResourceGroup), \n    max(ResourceName), \n    max(ResourceId)\n    --UnitPrice,\n    --EffectivePrice,\n    --CostInBillingCurrency,\n    --AdditionalInfo\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202301*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE (ResourceId like '%/virtualMachines/%' or ResourceId like '%/virtualMachineScaleSets/%') and MeterCategory = 'Virtual Machines'\n    --and MeterCategory = 'Virtual Machines'\n    --and MeterSubCategory = 'Dv3/DSv3 Series Windows'\n    --and ReservationName != '' \n    --and  ReservationName is not NULL\n    --and MeterSubCategory != 'Windows Server'\n    --and ServiceInfo2 = 'Windows Server BYOL'\n    --and ServiceInfo2 = ''\n    --and (MeterSubCategory like '%Windows%') \n    --and (MeterSubCategory != 'Windows Server') and (MeterSubCategory != 'Windows Server Burst')\n    --and JSON_VALUE(AdditionalInfo, '$.VCPUs') = 4\n    and (MeterSubCategory like '%Windows%' and ServiceInfo2 is NULL) or (ServiceInfo2 = 'Windows Server BYOL')\n    --and (MeterCategory = 'Virtual Machines Licenses' and MeterSubCategory = 'Windows Server')\n    --and ResourceId = '/subscriptions/fa020411-3a3b-443d-8b2f-ed3ac1a4029c/resourceGroups/S230-DC-FORECAST-CLIENT/providers/Microsoft.Compute/virtualMachineScaleSets/vmss-dc-forecast-client'\n    --and ResourceId = '/subscriptions/5f9dec8c-8bfd-40e1-b7c7-85fa538f77ed/resourceGroups/CITRIX-XD-DE028C6C-1A1E-4370-9244-39C08AA856CE-C5Q51/providers/Microsoft.Compute/virtualMachines/MMP-TS4212'\n    --and ResourceId = '/subscriptions/a6abe45d-e638-4325-a7e9-5559450aa434/resourceGroups/INFPROD-NOW/providers/Microsoft.Compute/virtualMachines/WS4253'\n    and [Date] = '2023-01-10'\n    group by ResourceId, [Date], ServiceInfo2\n    order by [Date]\n    --order by JSON_VALUE(AdditionalInfo, '$.VCPUs') DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Un Used RI March 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 10 *\n    --ReservationName\n    --,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    --,avg(UnitPrice) as UnitPrice\n    --,EffectivePrice\n    --,Quantity\n    --,sum(UnitPrice * Quantity) as [Equinor PAYG Cost]\n    --,EffectivePrice * Quantity as [RI Cost]\n    --,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    --,ProductOrderName\n    --,PartNumber\n    --,ChargeType\n    --,PricingModel\n    sum(Quantity)as Quantity\n    ,sum(EffectivePrice * Quantity) as [RI Cost]\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/202303*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere \n    ChargeType = 'UnusedReservation' \n    and (PricingModel = 'Reservation') \n    and (ReservationName like 'S037_%' OR ReservationName like 'VM_RI_%')\n    --and MeterCategory = 'Virtual Machines' --and format([Date],'yyyy-MM') = '2022-12'\n--group by ReservationName, format([Date],'yyyy-MM'), ProductOrderName,PartNumber, ChargeType, PricingModel --, JSON_VALUE(AdditionalInfo, '$.ServiceType')\n--order by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Un Used RI')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 10 *\n    ReservationName\n    ,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    --,avg(UnitPrice) as UnitPrice\n    ,EffectivePrice\n    ,Quantity\n    --,sum(UnitPrice * Quantity) as [Equinor PAYG Cost]\n    ,EffectivePrice * Quantity as [RI Cost]\n    --,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    ,ProductOrderName\n    ,PartNumber\n    ,ChargeType\n    ,PricingModel\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/202303*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'UnusedReservation' and (PricingModel = 'Reservation' or PricingModel = 'SavingsPlan') --and MeterCategory = 'Virtual Machines' --and format([Date],'yyyy-MM') = '2022-12'\n--group by ReservationName, format([Date],'yyyy-MM'), ProductOrderName,PartNumber, ChargeType, PricingModel --, JSON_VALUE(AdditionalInfo, '$.ServiceType')\norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VIEW - Combined_Actual_Savings')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Combined_Actual_Savings\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where [Date] >= '2022-12-31'\n\nUNION --ALL\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where [Date] <= '2022-12-31'\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Cost by VM Series')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *\n    format([Date], 'yyyy-MM') as [Date]\n    ,upper(MeterSubCategory) as [VM Series]\n    ,FORMAT(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\n    --,Quantity\n    --,format(sum(Quantity), 'N', 'en-us') as Quantity\n    --,UnitOfMeasure\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines'\n    group BY upper(MeterSubCategory), format([Date], 'yyyy-MM')\n    order by [Date], sum(CostInBillingCurrency) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM HUB 2022 New API')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "SELECT\n    --TOP 1000 *\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs, \n    format([Date], 'yyyy-MM') as [Date], \n    sum(Quantity) as Quantity,\n    PartNumber,\n    ProductName,\n    MeterCategory,\n    ServiceInfo2\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 = 'Windows Server BYOL' --and ReservationName != '' and Product LIKE '%Spot%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), format([Date], 'yyyy-MM'), PartNumber, ProductName, MeterCategory, JSON_VALUE(AdditionalInfo, '$.VCPUs'), ServiceInfo2\nORDER BY format([Date], 'yyyy-MM'), sum(Quantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM HUB 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "SELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs, \n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    PartNumber,\n    Product,\n    ServiceInfo2\n    --,sum(Cost) as Cost\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n--WHERE MeterCategory = 'Virtual Machines Licenses'\n----Filtering on only Windows Server HUB VM's, there is also Windows Client BYOL but this is not relecant for VM HUB savings calculations\n----I've removed \"Product LIKE '%Spot%'\" part is not required as spot machine still come under \"MeterCategory = 'Virtual Machines'\"\nWHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 LIKE 'Windows Server BYOL'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), PartNumber, Product, ServiceInfo2, JSON_VALUE(AdditionalInfo, '$.VCPUs')\nORDER BY substring([Date],0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM HUB using Extended parquet')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2023"
				},
				"content": {
					"query": "SELECT\n    --TOP 1000 *\n    ai_ServiceType as ServiceType, \n    ai_VCPUs as VCPUs, \n    format([Date], 'yyyy-MM') as [Date], \n    sum(Quantity) as Quantity,\n    PartNumber,\n    ProductName,\n    MeterCategory,\n    ServiceInfo2\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/202*/Extended_v2_ACMMonthlyActualCost_*.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ServiceInfo2 = 'Windows Server BYOL' --and ReservationName != '' and Product LIKE '%Spot%'\n    and [Date] >= '2022-11-01' and [Date] <= '2023-10-31'\nGROUP BY ai_ServiceType, format([Date], 'yyyy-MM'), PartNumber, ProductName, MeterCategory, ai_VCPUs, ServiceInfo2\nORDER BY format([Date], 'yyyy-MM'), sum(Quantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Hours by VM Series')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests/Cloud Cost Facts"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *\n    format([Date], 'yyyy-MM') as [Date]\n    ,upper(MeterSubCategory) as [VM Series]\n    --,FORMAT(sum(CostInBillingCurrency), 'N', 'en-us') as Cost\n    --,Quantity\n    ,format(sum(Quantity), 'N', 'en-us') as Quantity\n    --,UnitOfMeasure\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/2023*/ACMMonthlyAmortizedCost_2023*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines'\n    group BY upper(MeterSubCategory), format([Date], 'yyyy-MM')\n    order by [Date], sum(Quantity) DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Licences')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    JSON_VALUE(AdditionalInfo, '$.ReservationOrderId') as ReservationOrderId, \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost,\n    Product\n    --TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines Licenses' --and JSON_VALUE(AdditionalInfo, '$.ReservationId') LIKE '%%' --and Product Not like 'Windows%'\n--and MeterSubCategory = 'Reservation-Base VM' and ServiceInfo2 LIKE '%BYOL' and Product LIKE '%Spot%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), JSON_VALUE(AdditionalInfo, '$.ReservationOrderId'), Product\nORDER BY ServiceType ",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Purchase Cost 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    ReservationId\n    ,ReservationName\n    ,MeterSubCategory\n    ,Term\n    ,[Date]\n    ,Quantity\n    ,CostInBillingCurrency\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Purchase' and PricingModel = 'Reservation' --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \n--order by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Purchase Cost March 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --ReservationId\n    --,ReservationName\n    --,MeterSubCategory\n    --,Term\n    --,[Date]\n    sum(Quantity) as Quantity\n    ,sum(CostInBillingCurrency) as Cost\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/202303*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere \n    ChargeType = 'Purchase' \n    and PricingModel = 'Reservation' \n    and (ReservationName like 'S037_%' OR ReservationName like 'VM_RI_%')\n    --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \n--order by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Purchases 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    ReservationId\n    ,ReservationName\n    ,SubscriptionName\n    ,format([Date], 'yyyy-MM') as [Date]\n    ,MeterSubCategory\n    ,Term\n    ,ChargeType\n    ,Quantity\n    ,UnitPrice\n    ,CostInBillingCurrency\n    \nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Purchase' and PricingModel = 'Reservation' and MeterCategory not like '%SQL%' --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Refund Cost March 2023')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/Morten P Query"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --,format([Date],'yyyy-MM') as [Date]\n    --,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    --avg(UnitPrice) as UnitPrice\n    --,EffectivePrice as EffectivePrice\n    --,sum(UnitPrice * Quantity) as [PAYG Cost]\n    --,sum(EffectivePrice * Quantity) as [RI Cost]\n    --,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    sum(CostInBillingCurrency) as Cost\n    ,sum(Quantity) as Quantity \n    ,[Date]\n    --,ReservationName\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAc*/202303*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere \n    ChargeType = 'Refund' \n    and PricingModel = 'Reservation' \n    and (ReservationName like 'S037_%' OR ReservationName like 'VM_RI_%')\n\n    --and MeterCategory = 'Virtual Machines' and ChargeType = 'Usage'\n--group by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType') \n--order by format([Date],'yyyy-MM'), ReservationName\ngroup by [Date] --, ReservationName\norder by [Date]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Total Used Saving2')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 10 *\n    ReservationName\n    ,format([Date],'yyyy-MM') as [Date]\n    ,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    ,avg(UnitPrice) as UnitPrice\n    ,avg(EffectivePrice) as EffectivePrice\n    ,sum(Quantity) as Quantity\n    ,sum(UnitPrice * Quantity) as [Equinor PAYG Cost]\n    ,sum(EffectivePrice * Quantity) as [RI Cost]\n    ,sum((UnitPrice - EffectivePrice) * Quantity) as TotalUsedSavings\n    ,ProductOrderName\n    ,PartNumber\n    ,ChargeType\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAm*/2022*/A*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nwhere ChargeType = 'Usage' and PricingModel = 'Reservation' and MeterCategory = 'Virtual Machines' --and format([Date],'yyyy-MM') = '2022-12'\ngroup by ReservationName, format([Date],'yyyy-MM'), JSON_VALUE(AdditionalInfo, '$.ServiceType'),ProductOrderName,PartNumber, ChargeType\norder by format([Date],'yyyy-MM'), ReservationName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM RI Total Used Saving3')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/New API/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 *\n    --[Date]\n    sum([PAYG Cost]) as [PAYG Cost]\n    ,sum([RI Cost]) as [RI Cost]\n    ,sum(TotalUsedSavings) as TotalUsedSavings\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/test/RI_Savings_2022/VM_RI_Usage_2022.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW=TRUE\n    ) AS [result]\n    --group by [Date]\n    --order by [Date]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Reservation Cost - csv')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    reservationOrderId AS reservationOrderId,\n    reservationOrderName AS reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11) AS eventDate,\n    quantity AS quantity,\n    amount AS amount,\n    currency,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/tempdata/annual/2021/costreport_reservations_monthly_2021.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\nwhere reservationOrderName NOT LIKE '%SQL%' and reservationOrderId != 'd5b99270-d26e-49b1-82dc-d7cb16a9181a' and reservationOrderName NOT LIKE '%SUSE%'\norder by substring(FORMAT (eventDate,'yyyy-MM-dd') ,0,11)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Reservation Cost 2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    reservationOrderId AS reservationOrderId,\n    reservationOrderName AS reservationOrderName,\n    armSkuName AS armSkuName,\n    term AS term,\n    substring(eventDate,0,11) AS eventDate,\n    quantity AS quantity,\n    amount AS amount,\n    currency,\n    billingFrequency AS billingFrequency\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/reservations/2022/reservations_costreport.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n--where reservationOrderId = '7334aae9-5adc-4e4c-a58b-801d095a14df'\n--where reservationOrderName NOT LIKE '%SQL%' --and reservationOrderId != 'd5b99270-d26e-49b1-82dc-d7cb16a9181a'\nwhere armSkuName NOT LIKE 'SQL%' and eventDate Like '2022%'\norder by substring(eventDate,0,11)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM Reservation Utilisation')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Reservation - Saving Plan Queries"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    MeterSubCategory\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM' --and (MeterSubCategory LIKE '%Windows%')\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterSubCategory\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM and CloudServices Usage and Cost')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    MeterCategory,\n    MeterName,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost\n    --UnitOfMeasure\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' or MeterCategory = 'Cloud Services'\nGROUP BY MeterCategory, MeterName, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)--, UnitOfMeasure\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterCategory\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM details within a Subscription')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    --TOP 100 \n    ResourceName\n    --ResourceName\n    ,ResourceGroup\n    ,MeterCategory\n    ,MeterSubCategory\n    ,ResourceId\n    --,ai_ImageType\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/20230901-20230930/Extended_v2_ACMMonthlyActualCost_20230901-20230930.parquet/**',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines'\n    --MeterCategory = 'Virtual Machines Licenses'\n    and SubscriptionName = 'S268-Prod-Geology-Geophysics'\n    --and ResourceId like '%Capacity%'\n    --and (ResourceName is NULL or ResourceName = '')\n    group by ResourceId, ResourceName, ResourceGroup ,MeterSubCategory, MeterCategory\n    order by ResourceName",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM distinct ResourceId Count')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --TOP 100 \n    --MeterCategory\n    --,MeterSubCategory\n    format([Date], 'yyyy-MM') as [Date]\n    ,count(DISTINCT ResourceId) as [Count]\n    --,sum(Quantity) as Quantity\n    --,AdditionalInfo\n    --,sum(CostInBillingCurrency) as Cost\n    --,UnitOfMeasure\n    --,*\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where MeterCategory = 'Virtual Machines'\n    group by format([Date], 'yyyy-MM')\n    order by format([Date], 'yyyy-MM')\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_Cost_Per_Meter_SubCategory')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    [MeterSubCategory], \n    sum(Cost) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' \nGROUP BY MeterSubCategory\norder by Cost DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_RI_USE_2021')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType, \n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity\n    --Product\n    --ConsumedQuantity, \n    --sum(ConsumedQuantity), REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\n    --ConsumedQuantity, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','')\n    --MeterName, ConsumedQuantity, substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2), AdditionalInfo\n    TOP 1000 *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM' \n--and (MeterSubCategory NOT LIKE '%Windows%' and ServiceInfo2 Not Like '%Windows%')\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_RI_USE_2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    JSON_VALUE(AdditionalInfo, '$.ReservationOrderId') as ReservationOrderId, \n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    SubscriptionName,\n    ServiceInfo2\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/monthly/2022/*/*-cleaned.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\nWHERE (MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM') --and ([Date] >= '2022-01-01' and [Date] < '2022-07-01')\n--and (MeterSubCategory NOT LIKE '%Windows%' and ServiceInfo2 Not Like '%Windows%')\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), SubscriptionName, JSON_VALUE(AdditionalInfo, '$.ReservationOrderId'), ServiceInfo2\nORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_RI_USE_2022_From_SQLDB')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "--RI & HUB Savings/Old API"
				},
				"content": {
					"query": "USE costmgmt;\nGO\n\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    JSON_VALUE(AdditionalInfo, '$.ReservationOrderId') as ReservationOrderId, \n    substring([Date],0,8) as [Date], \n    sum(ConsumedQuantity) as ConsumedQuantity,\n    SubscriptionName\nFROM usage\nWHERE (MeterCategory = 'Virtual Machines' and MeterSubCategory = 'Reservation-Base VM') and ([Date] >= '2022-01-01' and [Date] < '2022-07-01')\n--and (MeterSubCategory NOT LIKE '%Windows%' and ServiceInfo2 Not Like '%Windows%')\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring([Date],0,8), SubscriptionName, JSON_VALUE(AdditionalInfo, '$.ReservationOrderId')\nORDER BY substring([Date],0,8), sum(ConsumedQuantity) DESC",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_Annual')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(ConsumedQuantity), REPLACE(REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('VCPUs\":',AdditionalInfo)+8,3),'}',''),',',''),' ',''),'\"','')\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ConsumedService != 'Microsoft.MachineLearningServices' and ConsumedService != 'Microsoft.ClassicCompute' \nGROUP BY REPLACE(REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('VCPUs\":',AdditionalInfo)+8,3),'}',''),',',''),' ',''),'\"','')",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_Annual_using_AdditionalInfo')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost\n    --sum(ConsumedQuantity), REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\n    --ConsumedQuantity, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','')\n    --MeterName, ConsumedQuantity, substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2), AdditionalInfo\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' or MeterCategory = 'Cloud Services'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\norder by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_CC')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    MeterName, Sum(ConsumedQuantity), substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.ClassicCompute'\nGROUP BY MeterName, substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_MLS')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --MeterName, Sum(ConsumedQuantity), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName != 'Compute'\n--GROUP BY MeterName, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n--order by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_MLS_json')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(ConsumedQuantity), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','')\n    --sum(ConsumedQuantity), REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\n    --ConsumedQuantity, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','')\n    --MeterName, ConsumedQuantity, substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2), AdditionalInfo\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' \n--WHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' and AdditionalInfo NOT LIKE '%Standard_DS[0-9]_v2%'\nGROUP BY REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S',''), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n--GROUP BY REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\norder by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n--ORDER BY REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','') DESC\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_Monthly_using_AdditionalInfo')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(ConsumedQuantity) as Cost,\n    --ConsumedQuantity, \n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date], \n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    --sum(ConsumedQuantity), REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\n    --ConsumedQuantity, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+10,3),'_',''),'s',''),'S','')\n    --MeterName, ConsumedQuantity, substring(FORMAT ([Date],'YYYY-MM-DD') ,6,2), AdditionalInfo\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' \n--WHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' and AdditionalInfo NOT LIKE '%Standard_DS[0-9]_v2%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType')\n--GROUP BY REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2021_byMonth')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    sum(ConsumedQuantity), REPLACE(REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('VCPUs\":',AdditionalInfo)+8,3),'}',''),',',''),' ',''),'\"',''), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and ConsumedService != 'Microsoft.MachineLearningServices' and ConsumedService != 'Microsoft.ClassicCompute' \nGROUP BY REPLACE(REPLACE(REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('VCPUs\":',AdditionalInfo)+8,3),'}',''),',',''),' ',''),'\"',''), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_2022')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2022"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    --top 100 *,\n    --JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    MeterName\n    --,FORMAT([Date],'yyyy') as [Date]\n    ,substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date]\n    ,sum(Quantity) as Quantity\n    --,sum(CostInBillingCurrency) as Cost\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/2022*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    WHERE MeterCategory = 'Virtual Machines' and ChargeType = 'Usage' --and benefitName is not NULL --and JSON_VALUE(AdditionalInfo, '$.ServiceType') is NULL --or MeterCategory = 'Cloud Services'\n    GROUP BY MeterName, substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8)\n    order by substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), Quantity DESC\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM_VCPU_Hours_with_Cost_2021_excl_RI')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "OGBG Benchmark 2022/2021"
				},
				"content": {
					"query": "-- This is auto-generated code\nSELECT\n    JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType,\n    MeterSubCategory,\n    substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8) as [Date],\n    sum(ConsumedQuantity) as ConsumedQuantity,\n    sum(Cost) as Cost\n    --*\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2021/*/*_cleaned.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\nWHERE MeterCategory = 'Virtual Machines' and MeterSubCategory != 'Reservation-Base VM' --and (MeterSubCategory LIKE '%Windows%')\n--WHERE MeterCategory = 'Virtual Machines' and ConsumedService = 'Microsoft.MachineLearningServices' and MeterName = 'Compute' and AdditionalInfo NOT LIKE '%Standard_DS[0-9]_v2%'\nGROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType'), substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), MeterSubCategory\n--GROUP BY JSON_VALUE(AdditionalInfo, '$.ServiceType')\n--GROUP BY REPLACE(REPLACE(SUBSTRING(AdditionalInfo,CHARINDEX('Standard_',AdditionalInfo)+11,2),'_',''),'s','')\nORDER BY substring(FORMAT ([Date],'yyyy-MM-DD') ,0,8), ConsumedQuantity DESC\n\n\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/View - Actual Usage - Management API')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Actual_Usage_Management_API\nAS\n\nSELECT\n    *\n    ,JSON_VALUE(AdditionalInfo, '$.VCPUs') as VCPUs\n    ,Quantity * cast(JSON_VALUE(AdditionalInfo, '$.VCPUs') as int) as CPUHours\n    ,JSON_VALUE(AdditionalInfo, '$.UsageType') as UsageType\n    ,JSON_VALUE(AdditionalInfo, '$.ImageType') as ImageType\n    ,JSON_VALUE(AdditionalInfo, '$.ServiceType') as ServiceType\n    ,JSON_VALUE(AdditionalInfo, '$.VMName') as VMName\n    ,JSON_VALUE(AdditionalInfo, '$.VMProperties') as VMProperties\n    ,JSON_VALUE(AdditionalInfo, '$.CPUs') as CPUs\n    --,FORMAT ([Date],'yyyy') as [Date_yyyy]\n    --,FORMAT ([Date],'yyyy-MM') as [Date_yyyy-MM]\n    --[Date],\n    --FORMAT ([Date],'yyyy-MM-dd') as [Date],\n    --substring([Date],7,4) + '-' + substring([Date],1,2) + '-' + substring([Date],4,2)  as FormattedDate,\n    --substring([Date],7,4) + '-' + substring([Date],1,2) as [ShortDate],\n    --ResourceGroup,\n    --ResourceLocation,\n    --UnitOfMeasure,\n    --Quantity,\n    --EffectivePrice,\n    --CostInBillingCurrency,\n    --UnitPrice,\n    --PayGPrice,    \n    --ProductName,\n    --MeterCategory,\n    --MeterSubCategory,\n    --MeterName,   \n    --ServiceInfo1,\n    --ServiceInfo2,\n    --ReservationId,\n    --ReservationName,     \n    --PartNumber,\n    --PlanName,\n    --Term,\n    --CostCenter,\n    --ConsumedService,\n    --ResourceId,\n    --Tags,\n    --OfferId,\n    --AdditionalInfo,\n    --ResourceName,\n    --PublisherType,\n    --PublisherName,\n    --ChargeType,\n    --Frequency,\n    --PricingModel,\n    --ServiceFamily,\n    --benefitId,\n    --benefitName,\n    --SubscriptionId,\n    --SubscriptionName\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/*/ACMMonthlyActualCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/View - Amortized Usage - Management API')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Amortised_Usage_Management_API\nAS\n\nSELECT\n    *\n    --,FORMAT ([Date],'yyyy') as [Date_yyyy]\n    --,FORMAT ([Date],'yyyy-MM') as [Date_yyyy-MM]\n    --[Date],\n    --FORMAT ([Date],'yyyy-MM-dd') as [Date],\n    --substring([Date],7,4) + '-' + substring([Date],1,2) + '-' + substring([Date],4,2)  as FormattedDate,\n    --substring([Date],7,4) + '-' + substring([Date],1,2) as [ShortDate],\n    --ResourceGroup,\n    --ResourceLocation,\n    --UnitOfMeasure,\n    --Quantity,\n    --EffectivePrice,\n    --CostInBillingCurrency,\n    --UnitPrice,\n    --PayGPrice,    \n    --ProductName,\n    --MeterCategory,\n    --MeterSubCategory,\n    --MeterName,   \n    --ServiceInfo1,\n    --ServiceInfo2,\n    --ReservationId,\n    --ReservationName,     \n    --PartNumber,\n    --PlanName,\n    --Term,\n    --CostCenter,\n    --ConsumedService,\n    --ResourceId,\n    --Tags,\n    --OfferId,\n    --AdditionalInfo,\n    --ResourceName,\n    --PublisherType,\n    --PublisherName,\n    --ChargeType,\n    --Frequency,\n    --PricingModel,\n    --ServiceFamily,\n    --benefitId,\n    --benefitName,\n    --SubscriptionId,\n    --SubscriptionName\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyAmortizedCost/*/ACMMonthlyAmortizedCost_*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/View - Extended Actual Usage - Management API')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Views"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Extended_Actual_Usage_Management_API\nAS\n\nSELECT\n    *\n    ,Quantity * cast(ai_VCPUs as int) as CPUHours\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/exports/monthly/ACMMonthlyActualCost/*/Extended*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/View - Pricesheet')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW Pricesheet\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/pricesheet/pricesheet-LATEST.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/WBS Check')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "SELECT\n    --top 10 *\n    distinct(SubscriptionName)\n    ,substring(LatestDate,1,7) as [Month]\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/tempdata/monthly/2022/12/filtered_parquet/*.snappy.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n    where   \n        upper(LatestCostAllocationCode) IN ('C.ITX.36.001', 'C.ITX.36.002', 'C.ITD.15.022', 'C.ITD.15.034', 'C.ITX.43.001', 'C.ITX.46.004', 'C.ITX.46.007', 'C.ITX.46.011', 'C.ITX.46.012')\n        or \n        upper(LatestCostCenter) IN ('C.ITX.36.001', 'C.ITX.36.002', 'C.ITD.15.022', 'C.ITD.15.034', 'C.ITX.43.001', 'C.ITX.46.004', 'C.ITX.46.007', 'C.ITX.46.011', 'C.ITX.46.012')\n    order by [Month], SubscriptionName\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/ambiguous-services')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"content": {
					"query": "-- This is auto-generated code\nSelect ResourceType, COUNT(*) as UniqueCount from (SELECT\n    ResourceType, ServiceModel, count(*) as GroupCount\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/services/services-raw.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n    group by ResourceType, ServiceModel) as [unique_result]\n    Group by ResourceType\n    having count(*) > 1\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/omnia_acdc_cost_details_with_sap_response_')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "Ad Hoc Cost Report Requests"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW cost_details_from_acdc\nAS \n\nSELECT\n    WBS,\n    SubscriptionId,\n    SubscriptionName,\n    ResourceGroup,\n    CONVERT(float,REPLACE(Amount,',','.')) as [Amount],\n    ServiceNowAppName,\n    --Posting_Date,\n    CONVERT(DATE, FORMAT(Posting_Date, '##-##-####'), 105) as Posting_Date,\n    --(CAST(SUBSTRING(cast(Posting_Date as varchar),5,4) AS varchar) + '-' + CAST(substring(cast(Posting_Date as varchar),3,2) AS varchar) + '-' + CAST(substring(cast(Posting_Date as varchar),1,2) AS varchar))as Posting_Date,\n    Company_Code,\n    AllocType,\n    ResourceCostAllocationType,\n    LatestCostAllocationCode,\n    LatestCostCenter,\n    Period\nFROM\n    OPENROWSET(\n        BULK 'https://omniaacdcdlsprod.dfs.core.windows.net/costreports/monthly/*/*/omnia_acdc_cost_details_with_sap_response.csv',\n        FORMAT = 'CSV',\n        PARSER_VERSION = '2.0',\n        HEADER_ROW = TRUE\n    ) AS [result]\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": -1
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/subscription')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "PowerBIViews"
				},
				"content": {
					"query": "USE costmgmt\nGO\n\nCREATE OR ALTER VIEW tsc_subscription\nAS\n\nSELECT\n    *\nFROM\n    OPENROWSET(\n        BULK 'https://s037costmgmt.dfs.core.windows.net/usage/subscriptions/optimized/subscription_optimized.parquet/*.parquet',\n        FORMAT = 'PARQUET'\n    ) AS [result]\n\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/tsc_CreateCalendarTable')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsInProduction"
				},
				"content": {
					"query": "-- Create the Calendar table\nCREATE TABLE Calendar\n(\n    [Date] DATE,\n    [Year] INT,\n    [Month] INT,\n    [Day] INT,\n    [Quarter] INT,\n    [DayOfWeek] INT,\n    [Weekday] INT,\n    [WeekOfYear] INT,\n    [MonthName] NVARCHAR(20),\n    [DayName] NVARCHAR(20),\n    [IsHoliday] INT\n)\nWITH\n(\n    DISTRIBUTION = ROUND_ROBIN\n);\n\n-- Create the clustered columnstore index\nCREATE CLUSTERED COLUMNSTORE INDEX idx_Columnstore ON Calendar;\n\n-- Optional: Create additional indexes or constraints if needed\n-- CREATE INDEX idx_Date ON dbo.Calendar([Date]);\n-- ALTER TABLE dbo.Calendar ADD CONSTRAINT pk_Calendar PRIMARY KEY ([Date]);\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "master",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/tsc_CreateCalendarTable_v2')]",
			"type": "Microsoft.Synapse/workspaces/sqlscripts",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "SQLScriptsInProduction"
				},
				"content": {
					"query": "-- Create the Calendar table using CTAS\nCREATE TABLE Calendar\nWITH\n(\n    DISTRIBUTION = ROUND_ROBIN,\n    CLUSTERED COLUMNSTORE INDEX\n)\nAS\nSELECT\n    [Date],\n    YEAR([Date]) AS [Year],\n    MONTH([Date]) AS [Month],\n    DAY([Date]) AS [Day],\n    DATEPART(QUARTER, [Date]) AS [Quarter],\n    DATEPART(WEEKDAY, [Date]) AS [DayOfWeek],\n    CASE WHEN DATEPART(WEEKDAY, [Date]) IN (1, 7) THEN 0 ELSE 1 END AS [Weekday],\n    DATEPART(WEEK, [Date]) AS [WeekOfYear],\n    DATENAME(MONTH, [Date]) AS [MonthName],\n    DATENAME(WEEKDAY, [Date]) AS [DayName],\n    0 AS [IsHoliday] -- Set IsHoliday value based on your specific requirements\nFROM\n    (SELECT CAST('2000-01-01' AS DATE) AS [Date] UNION ALL SELECT DATEADD(DAY, 1, [Date]) FROM dbo.Calendar WHERE [Date] < '2030-12-31') AS c\nOPTION (LABEL = 'Create Calendar', SINGLE_BLOB);\n",
					"metadata": {
						"language": "sql"
					},
					"currentConnection": {
						"databaseName": "costmgmt",
						"poolName": "Built-in"
					},
					"resultLimit": 5000
				},
				"type": "SqlQuery"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/AdHoc Extend AI column and WBS tags')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('AdHoc Extend AI column and WBS tags_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "0a1750e8-8c28-4a3f-ad7a-2e3567751efc"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('AdHoc Extend AI column and WBS tags_notebookSparkPoolIdRef')]",
						"name": "[parameters('AdHoc Extend AI column and WBS tags_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('AdHoc Extend AI column and WBS tags_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"amortizedCostPath = 'exports/monthly/ACMMonthlyAmortizedCost/'\n",
							"actualCostPath = 'exports/monthly/ACMMonthlyActualCost/'\n",
							"toDate = '20230131'\n",
							"fromDate = '20230101'\n",
							"container = 'usage'\n",
							"months = ['02']\n",
							"years = ['2023']\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath):\n",
							"    \n",
							"    print(f'Loading Source Parquet file - {path}...')\n",
							"    cost_df = pd.read_parquet(path)\n",
							"    print(f'Loading Subscription list - {subscription_path}...')\n",
							"    subscription_list = pd.read_json(subscription_path)\n",
							"    print(f'Loading SNOW application list - {appListPath}...')\n",
							"    appList = pd.read_parquet(appListPath)\n",
							"\n",
							"    #cost_df.dropna(subset=['AdditionalInfo'], inplace=True)\n",
							"    #cost_df = cost_df.head(10000)\n",
							"\n",
							"    return cost_df, subscription_list, appList"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(cost_df):\n",
							"\n",
							"    # Populating the Azure Hynbrid Benefit Column\n",
							"    cost_df['Azure_Hybrid_Benefit'] = np.where(cost_df['MeterSubCategory'].str.contains(\"Windows\"), \"Not enabled\", np.where(cost_df['ServiceInfo2'] == \"Windows Server BYOL\", \"Enabled\", \"Not supported\"))\n",
							"\n",
							"    # Populating the isRIUsage Column\n",
							"    cost_df['IsRIUsage'] = np.where(cost_df['ReservationId'].isna(), \"On Demand Usage\", \"RI Usage\")\n",
							"\n",
							"    # Extend AdditionalInfo Column\n",
							"    print('Calculating Mask....')\n",
							"    mask = cost_df['AdditionalInfo'].notna()\n",
							"    cost_df.loc[mask, 'AdditionalInfo'] = cost_df.loc[mask, 'AdditionalInfo'].apply(json.loads)\n",
							"    \n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(cost_df):\n",
							"    \n",
							"    print('Expanding the AdditionalInfo column...')\n",
							"    #cost_df = pd.concat([cost_df, cost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')], axis=1)\n",
							"    AdditionalInfo_df = cost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')\n",
							"    #AdditionalInfo_df = AdditionalInfo_df[[\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]]\n",
							"    columns_to_keep = [\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]\n",
							"    AdditionalInfo_df.drop(AdditionalInfo_df.columns.difference(columns_to_keep), axis=1, inplace=True)\n",
							"\n",
							"    # Manually creating the columns in the columns_to_keep array encase any columns are not present in the AdditionalInfo column.\n",
							"    # This avoids schema conflict with the usage file for other months that may have the missing columns\n",
							"    cost_df[columns_to_keep] = len(columns_to_keep) * [np.nan]\n",
							"    \n",
							"    # Updating the 'columns_to_keep' columns in cost_df with the values from AdditionalInfo_df\n",
							"    AdditionalInfo_df.dropna(inplace=True, how='all')\n",
							"    cost_df.update(AdditionalInfo_df)\n",
							"  \n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(cost_df):\n",
							"    \n",
							"    print('Populating the AHB vCPUs column...')\n",
							"    cost_df['ai_VCPUs'] = cost_df['ai_VCPUs'].fillna(0)\n",
							"    cost_df['ai_VCPUs'] = cost_df['ai_VCPUs'].astype(int)\n",
							"    cost_df['AHB_vCPUs'] = np.where(cost_df['ai_VCPUs'] == 0, 0, \n",
							"        np.where(cost_df['ai_VCPUs'] < 8, 8, \n",
							"        np.where(cost_df['ai_VCPUs'] <= 16, 16,\n",
							"        np.where(cost_df['ai_VCPUs'] == 20, 24,\n",
							"        np.where(cost_df['ai_VCPUs'] > 20, cost_df['ai_VCPUs'], 0)))))\n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(cost_df):    \n",
							"    \n",
							"    print('Populating the Instance Name column...')\n",
							"    cost_df.rename({'ai_VmName':'ai_Container_VmName'}, axis=1, inplace=True)\n",
							"    cost_df['Instance_Name'] = np.where(cost_df['ai_VMName'].isna(), cost_df['ResourceName'],\n",
							"        np.where(cost_df['ai_VMName'].notna(), cost_df['ai_VMName'], pd.NA))\n",
							"\n",
							"    cost_df['Date'] = cost_df['Date'].dt.date\n",
							"    \n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\n",
							"\n",
							"    print('Expanding the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list Tags field into their own fields...')\n",
							"\n",
							"    try:\n",
							"        subscription_tags_df = subscription_list.pop('tags').apply(pd.Series)\n",
							"    except:\n",
							"        print('Error processing the subscriptions json file!')\n",
							"\n",
							"    subscription_list['SubscriptionWBS'] = subscription_tags_df['WBS']\n",
							"    subscription_list['SubscriptionServiceNow-App'] = subscription_tags_df['ServiceNow-App']\n",
							"    \n",
							"    subscription_list.rename(columns={\"id\": \"SubscriptionId\"}, inplace=True)\n",
							"    columns_to_keep = ['SubscriptionId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\n",
							"\n",
							"    subscription_list.drop(columns=subscription_list.columns.difference(columns_to_keep), inplace=True)\n",
							"    \n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(cost_df, subscription_list):\n",
							"\n",
							"    print('Merging the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list into the cost dataframe...')\n",
							"\n",
							"    #cost_df['SubscriptionWBS'] = subscription_list(subscription_list.index, cost_df['SubscriptionId'])\n",
							"    \n",
							"    #print(subscription_list.columns)\n",
							"    #print(subscription_list[list('SubscriptionId')])\n",
							"    #cost_df = pd.merge(left=cost_df, right=subscription_list, left_on='SubscriptionId', right_on='id', how='left')\n",
							"    print(len(cost_df))\n",
							"    print(f\"cost_df Cost total is: {cost_df['CostInBillingCurrency'].sum()}\")\n",
							"    cost_df = cost_df.merge(subscription_list, how='left', on='SubscriptionId')\n",
							"    print(f\"cost_df Cost total is: {cost_df['CostInBillingCurrency'].sum()}\")\n",
							"    print(len(cost_df))\n",
							"    #print(cost_df[cost_df['ActiveWBS'].isnull()])\n",
							"    \n",
							"    return cost_df, subscription_list\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def replace_empty_cost_fields_with_subscription_details(cost_df, subscription_list, appList):\n",
							"\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\n",
							"\n",
							"    cost_df['CostAllocationCode'].replace('', np.nan, inplace=True)\n",
							"    cost_df['CostAllocationType'].replace('', np.nan, inplace=True)\n",
							"    cost_df['ActiveWBS'] = cost_df.loc[cost_df['CostAllocationType'] == 'WBS', 'CostAllocationCode']\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] != \"WBS\") & (cost_df['CostAllocationType'] != \"APPID\") & (cost_df['CostAllocationType'] != \"CI\") & (cost_df['CostAllocationType'] != \"SubscriptionWBS\")\n",
							"    cost_df.loc[mask, ['ActiveWBSReason']] = 'Invalid CostAllocationType: not APPID, CI or WBS'\n",
							"\n",
							"    mask = (cost_df['CostAllocationCode'].str.contains('^[a-zA-Z]\\.\\S*', regex=True) == False) & (cost_df['CostAllocationType'] == 'WBS')\n",
							"    cost_df.loc[mask, 'ActiveWBS'] = cost_df.loc[mask, 'SubscriptionWBS']\n",
							"    cost_df.loc[mask, 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'Invalid CostAllocationCode WBS'\n",
							"    \n",
							"    appList = appList.astype({'u_number': 'str'})\n",
							"    cost_df['ActiveWBS'] = cost_df['ActiveWBS'].fillna(cost_df['CostAllocationCode'].map(appList.set_index('u_number')['u_operational_wbs']))\n",
							"    cost_df['ActiveWBS'] = cost_df['ActiveWBS'].fillna(cost_df['CostAllocationCode'].map(appList.set_index('name')['u_operational_wbs']))\n",
							"    cost_df['ActiveWBS'].replace('TOBESPECIFIED', np.nan, inplace=True)  \n",
							"    \n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationCode'] = np.nan\n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    cost_df.loc[cost_df['ActiveWBS'].isnull(), 'ActiveWBS'] = cost_df['SubscriptionWBS']\n",
							"    \n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'CI')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'CI WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'APPID')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'APPID WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'WBS')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'WBS Cost Tag used'\n",
							"\n",
							"    mask = (cost_df['Tags'].str.contains('CostAllocationCode', case=False, na=False) == False) | (cost_df['Tags'].str.contains('CostAllocationType', case=False, na=False) == False)\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'CostAllocationType or CostAllocationCode not present in Tags'\n",
							"\n",
							"    return cost_df, subscription_list"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"    \n",
							"    print(f'Writing output file to: \"{destinationFilename}\"')\n",
							"    print(f'Dataframe length is: {len(cost_df)}')\n",
							"    cost_df.to_parquet(destinationFilename)\n",
							"    print('File write complete!')\n",
							"    "
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationcode_list(tag):\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               tag_array = tag.split('\",\"')\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    temp =  x.replace('\"','').upper()\n",
							"                    if x.replace(\"\\\"\",\"\").upper() == \"COSTALLOCATIONCODE\":\n",
							"                         return y.replace(\"\\\"\",\"\").strip('\\n').strip().upper()\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {cost_df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationtype_list(tag):\n",
							"\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               type_list = ['WBS', 'CI', 'APPID']\n",
							"               tag_array = tag.split('\",\"')\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    if x.replace('\"','').upper() == \"COSTALLOCATIONTYPE\":\n",
							"                         if y.replace('\"','').strip('\\n').strip().upper() in type_list:\n",
							"                              return y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         else:\n",
							"                              return np.nan\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {cost_df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(df):\n",
							"\n",
							"    print(\"Extracting cost Type and Code and storing in dedicated columns...\")\n",
							"\n",
							"    cost_df['CostAllocationType'] = cost_df.apply(lambda x: return_costallocationtype_list(x['Tags']), axis = 1)\n",
							"    cost_df['CostAllocationCode'] = cost_df.apply(lambda x: return_costallocationcode_list(x['Tags']), axis = 1)\n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_ai_column(cost_df, year, month, reportType):\n",
							"\n",
							"    warnings.simplefilter(action='ignore', category=FutureWarning)\n",
							"\n",
							"    #actualCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #actualCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #amortizedCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #amortizedCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"\n",
							"    #cost_df = load_source(actualCostSourcefilename)\n",
							"    cost_df = populate_columns(cost_df)\n",
							"    cost_df = extend_additional_info(cost_df)\n",
							"    cost_df = AHB_column(cost_df)\n",
							"    cost_df = instance_name(cost_df)\n",
							"    \n",
							"    return cost_df\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_wbs_columns(cost_df, subscription_list, year, month, reportType):\n",
							"\n",
							"    pd.set_option('max_colwidth', 50)\n",
							"\n",
							"    #cost_data_path = 'data/2022 Actual cost (10k rows).csv'\n",
							"    #size = 100\n",
							"    #subscription_path = 'data/subscriptions.json'\n",
							"\n",
							"    #df, subscription_list, appList = load_source_files(sourceFilename, subscriptionListPath, appListPath)\n",
							"    #cost_df = shorten_df(cost_df, size)\n",
							"\n",
							"\n",
							"    #df = cost_df.copy()\n",
							"    cost_df = expand_cost_tags(cost_df)\n",
							"    #print(df[['Tags', 'CostAllocationType', 'CostAllocationCode']])\n",
							"\n",
							"\n",
							"    subscription_list = expand_subscription_tags(subscription_list)\n",
							"    #print(subscription_list)\n",
							"    cost_df, subscription_list = merge_dataframes(cost_df, subscription_list)\n",
							"    cost_df, subscription_list = replace_empty_cost_fields_with_subscription_details(cost_df, subscription_list, appList)\n",
							"\n",
							"    #print(df[['CostAllocationType', 'CostAllocationCode', 'SubscriptionWBS', 'SubscriptionServiceNow-App', 'Tags']])\n",
							"    cost_df.reset_index(drop=True, inplace=True)\n",
							"    \n",
							"    return cost_df     "
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']\n",
							"months = ['05', '06', '07']\n",
							"#months = ['06']\n",
							"#years = ['2021', '2022', '2023']\n",
							"#years = ['2021', '2022']\n",
							"years = ['2023']\n",
							"#months = ['01']\n",
							"#reportTypes = ['ActualCost', 'AmortizedCost']\n",
							"#reportTypes = ['ActualCost']\n",
							"reportTypes = ['AmortizedCost']\n",
							"    \n",
							"for reportType in reportTypes:\n",
							"\n",
							"    print(f\"------ {reportType} -----------\")\n",
							"\n",
							"    for year in years:\n",
							"\n",
							"        print(f\"------ Year: {year} -----------\")\n",
							"\n",
							"        for month in months:\n",
							"\n",
							"            print(f\"------ Month: {month} -----------\")\n",
							"\n",
							"            fromDate = f'{year}{month}01'\n",
							"\n",
							"            sourceCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"\n",
							"            month_range = calendar.monthrange(datetime(int(year), int(month), 1).year, datetime(int(year), int(month), 1).month)\n",
							"            end_of_month_day = month_range[1]\n",
							"            toDate = f'{year}{month}{end_of_month_day}'\n",
							"            longToDate = f'{year}-{month}-{end_of_month_day}'\n",
							"\n",
							"            dateRange = fromDate + '-' + toDate\n",
							"\n",
							"            print(dateRange)\n",
							"            #sourceFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            #sourceCostFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/Extended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            costSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            costDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/Extended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            #destinationFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationPath + '/' + reportType + '/CostTagsExtended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            #destinationFilename = sourceFilename\n",
							"            #subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationPath + '/subscriptions.json'\n",
							"            if str(longToDate) < '2021-11-30':\n",
							"                print(longToDate)\n",
							"                print(f'Using default 2021-11-30 subscription json file')\n",
							"                subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_2021-11-30.json'\n",
							"            else:\n",
							"                print(f'Using {longToDate} subscription json file')\n",
							"                subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + longToDate + '.json'\n",
							"            appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/applications/applicationList.parquet'\n",
							"\n",
							"            cost_df, subscription_list, appList = load_source_files(costSourcefilename, subscriptionListPath, appListPath)\n",
							"            cost_df = expand_ai_column(cost_df, year, month, reportType)\n",
							"            cost_df = populate_wbs_columns(cost_df, subscription_list, year, month, reportType)\n",
							"            write_output_file(cost_df, costDestinationfilename)\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Anomaly_Detection_v1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Anomaly Detection"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Anomaly_Detection_v1_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "9a888982-250c-4e07-a953-246616f1ed8a"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Anomaly_Detection_v1_notebookSparkPoolIdRef')]",
						"name": "[parameters('Anomaly_Detection_v1_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Anomaly_Detection_v1_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Pipeline parameter\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T\r\n",
							"from pyspark.sql.window import Window"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def preprocessing_anomaly_detection(df):\r\n",
							"\r\n",
							"    # Selecting just relevant columns for anomaly detection\r\n",
							"    new_df = df.select('SubscriptionName', 'ResourceGroup', 'MeterCategory', 'ActiveWBS', 'Date', 'CostInBillingCurrency')\r\n",
							"\r\n",
							"    # Filtering out data older than 90 days to get only the latest historical data\r\n",
							"    threshold = F.date_sub(F.current_date(), 90)\r\n",
							"    filtered_df = new_df.filter(F.col('Date') >= threshold)\r\n",
							"\r\n",
							"    # Grouping the data by each filtering level and getting the sum of all costs related to the filtering columns\r\n",
							"    grouped_df = filtered_df.groupBy('SubscriptionName',\r\n",
							"                                     'ResourceGroup',\r\n",
							"                                     'MeterCategory',\r\n",
							"                                     'ActiveWBS',\r\n",
							"                                     'Date').agg(F.round(\r\n",
							"                                                  F.sum(\r\n",
							"                                                   F.col('CostInBillingCurrency')), 1).alias('TotalCost'))\r\n",
							"\r\n",
							"    return grouped_df"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def anomaly_detection_classifier(df,\r\n",
							"                                 filter_column_1,\r\n",
							"                                 filter_column_2,\r\n",
							"                                 filter_column_3,\r\n",
							"                                 filter_column_4,\r\n",
							"                                 window_size=30):\r\n",
							"\r\n",
							"    # Setting a partition window to divide the dataset in the filter options and order it by the Date\r\n",
							"    windowSpec = Window.partitionBy(filter_column_1, filter_column_2, filter_column_3, filter_column_4).orderBy('Date').rowsBetween(-window_size, 0)\r\n",
							"\r\n",
							"    # Set a moving average that is set by the n previous days\r\n",
							"    costs_by_dates = df.withColumn('MovingAverage', F.round(F.avg(F.col('TotalCost')).over(windowSpec), 1))\r\n",
							"\r\n",
							"    # Set a moving standard deviation of the same period\r\n",
							"    costs_by_dates = costs_by_dates.withColumn('MovingStdDev', F.round(F.stddev(F.col('TotalCost')).over(windowSpec), 1))\r\n",
							"\r\n",
							"    # Setting a scaling mechanism on the threshold in order to reduce the threshold when the costs are very high\r\n",
							"    am_curve = lambda x: 13.6 * x ** -0.22\r\n",
							"    \r\n",
							"    # Set a minimum scale of 0.1 and a maximum scale of 3.5\r\n",
							"    costs_by_dates = costs_by_dates.withColumn('Scaler', F.when(F.col('MovingStdDev') > 0.1, am_curve(F.col('MovingStdDev'))).otherwise(F.lit(0.1)))\r\n",
							"    costs_by_dates = costs_by_dates.withColumn('Scaler', F.when(F.col('Scaler') > 3.5, F.lit(3.5)).otherwise(F.col('Scaler')))\r\n",
							"\r\n",
							"    costs_by_dates = costs_by_dates.withColumn('Threshold', F.col('MovingAverage') + (F.col('MovingStdDev') * F.col('Scaler')))\r\n",
							"\r\n",
							"     # If the cost is more than the stddev threshold (+ some noise cancellation), then set the datapoint to be 1, otherwise 0\r\n",
							"    costs_by_dates = costs_by_dates.withColumn('AboveThreshold', F.when(F.col('TotalCost') > (F.col('Threshold') + 1), F.lit(1))\\\r\n",
							"                                                                                 .otherwise(F.lit(0)))\r\n",
							"    return costs_by_dates"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def anomaly_notification_filtration(df,\r\n",
							"                                    filter_column_1,\r\n",
							"                                    filter_column_2,\r\n",
							"                                    filter_column_3,\r\n",
							"                                    filter_column_4):\r\n",
							"\r\n",
							"    # Setting a new rolling window for which to track previous days anomalies\r\n",
							"    window_spec = Window.partitionBy(filter_column_1, filter_column_2, filter_column_3, filter_column_4).orderBy('Date')\r\n",
							"    \r\n",
							"    # Applying a lag for yesterday and the day before in order to see if there are anomalies on previous days\r\n",
							"    thres_df = df.withColumn('AboveThres1Day', F.lag(F.col('AboveThreshold'), 1).over(window_spec))\r\n",
							"    thres_df = thres_df.withColumn('AboveThresFor2Days', F.lag(F.col('AboveThreshold'), 2).over(window_spec))\r\n",
							"    \r\n",
							"    # The masks that will determine which anomalies we will report\r\n",
							"    # If an anomaly occured for three days straight\r\n",
							"    thres_mask = (F.col('AboveThreshold') == 1) & (F.col('AboveThres1Day') == 1) & (F.col('AboveThresFor2Days') == 1)\r\n",
							"    # If the daily cost where anomalies occured is 10.000 NOK or more\r\n",
							"    cost_mask = F.col('TotalCost') >= 10000\r\n",
							"    # If the date is on yesterdays date (the most updated data we recieve contains yesterdays costs)\r\n",
							"    date_mask = F.col('Date') >= F.date_sub(F.current_date(), 1)\r\n",
							"\r\n",
							"    # For Testing\r\n",
							"    thres_df = thres_df.withColumn('NotifyAnomaly', F.when(thres_mask & cost_mask, F.lit(True)).otherwise(F.lit(False)))\r\n",
							"\r\n",
							"    # # For Production\r\n",
							"    # thres_df = thres_df.withColumn('NotifyAnomaly', F.when(thres_mask & date_mask & cost_mask, F.lit(True)).otherwise(F.lit(False)))\r\n",
							"\r\n",
							"    # Dropping columns that are unimportant\r\n",
							"    dropped_df = thres_df.drop('Scaler', 'AboveThreshold', 'AboveThres1Day', 'AboveThresFor2Days')\r\n",
							"\r\n",
							"    # Filtering only the relevant data\r\n",
							"    filtered_df = dropped_df.filter(F.col('NotifyAnomaly') == True)\r\n",
							"\r\n",
							"    return filtered_df"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"def merge_with_subscription(input_df, subscription_path):\r\n",
							"\r\n",
							"    # Reading in useful columns from the subscription.json file\r\n",
							"    sub_df = spark.read.format('parquet').load(subscription_path).select('SubscriptionName', 'ProductOwnerEmail', 'TechnicalOwnerEmail')\r\n",
							"    sub_df = sub_df.withColumnRenamed('SubscriptionName','SNSubscriptionName')\r\n",
							"\r\n",
							"    # Merging on subscription names\r\n",
							"    merged_df = input_df.join(sub_df, on=input_df.SubscriptionName == sub_df.SNSubscriptionName, how='left')\r\n",
							"    \r\n",
							"    # Dropping the right-join column to avoid duplicate records\r\n",
							"    merged_df = merged_df.drop('SNSubscriptionName')\r\n",
							"\r\n",
							"    return merged_df"
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"source_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_OneYear.parquet\"\r\n",
							"destination_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_AnomalyDetection_3mnth.parquet\"\r\n",
							"subscription_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/subscriptions/servicenow/latest-optimized.parquet\"\r\n",
							"\r\n",
							"print(f\"Reading data from: {source_path}\")\r\n",
							"df = spark.read.format('parquet').load(source_path)\r\n",
							"\r\n",
							"preproc_data = preprocessing_anomaly_detection(df)\r\n",
							"\r\n",
							"\r\n",
							"filter_1 = 'SubscriptionName'\r\n",
							"filter_2 = 'ResourceGroup'\r\n",
							"filter_3 = 'MeterCategory'\r\n",
							"filter_4 = 'ActiveWBS'\r\n",
							"\r\n",
							"\r\n",
							"print(\"Running the Anomaly Detection Classifier for Subscription-partitioned data\")\r\n",
							"anomaly_df =  anomaly_detection_classifier(df=preproc_data,\r\n",
							"                                           filter_column_1=filter_1,\r\n",
							"                                           filter_column_2=filter_2,\r\n",
							"                                           filter_column_3=filter_3,\r\n",
							"                                           filter_column_4=filter_4,\r\n",
							"                                           window_size=60)\r\n",
							"\r\n",
							"\r\n",
							"filtered_df = anomaly_notification_filtration(anomaly_df,\r\n",
							"                                              filter_column_1=filter_1,\r\n",
							"                                              filter_column_2=filter_2,\r\n",
							"                                              filter_column_3=filter_3,\r\n",
							"                                              filter_column_4=filter_4)\r\n",
							"if filtered_df.count() == 0:\r\n",
							"    print('No Anomalies today!')\r\n",
							"else:\r\n",
							"    merged_df = merge_with_subscription(filtered_df, \r\n",
							"                                        subscription_path)\r\n",
							"\r\n",
							"\r\n",
							"    print(f\"Writing classification data to this path: {destination_path}\")\r\n",
							"    merged_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(destination_path)\r\n",
							"    print('Write Complete!')"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# display(merged_df)"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Finding Hyper-parameters for the Scaling-Function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# import numpy as np\r\n",
							"# from scipy.optimize import curve_fit\r\n",
							"# import matplotlib.pyplot as plt\r\n",
							"\r\n",
							"# # The function we want to use to apply the scaling function \r\n",
							"# def scaling_function(x, a, b):\r\n",
							"#     return a * np.power(x, b)\r\n",
							"\r\n",
							"# # Costs are the \"input values\" and the degree of scaling are the output values\r\n",
							"# input_values = np.array([1000, 10000, 100000])\r\n",
							"# output_values = np.array([3, 2, 1])\r\n",
							"\r\n",
							"# # Finding the unknown parameters (a, b) for the scaling function\r\n",
							"# params, covariance = curve_fit(scaling_function, input_values, output_values)\r\n",
							"\r\n",
							"# print(f\"'a' has value: {params[0]}\")\r\n",
							"# print(f\"'b' has value: {params[1]}\")\r\n",
							"\r\n",
							"# # Plotting the scaling function against a range\r\n",
							"# x = range(0, 100000, 1000)\r\n",
							"# y = [scaling_function(i, 13.6, -0.22) for i in x]\r\n",
							"# plt.figure(figsize=(14, 10))\r\n",
							"# plt.plot(x, y, c='blue', label='Fitted curve')\r\n",
							"# plt.scatter(input_values, output_values, c='red', label='Input data points')\r\n",
							"# plt.legend()\r\n",
							"# plt.show()"
						],
						"outputs": [],
						"execution_count": 32
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Anomaly_Detection_v2')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Anomaly Detection"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Anomaly_Detection_v2_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "c1168926-5016-4986-bf86-4ada020b7812"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Anomaly_Detection_v2_notebookSparkPoolIdRef')]",
						"name": "[parameters('Anomaly_Detection_v2_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Anomaly_Detection_v2_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Pipeline parameter\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 56
					},
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T\r\n",
							"from pyspark.sql.window import Window"
						],
						"outputs": [],
						"execution_count": 57
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Constants\r\n",
							"DETECTOR_WINDOW_SIZE = 60\r\n",
							"ANOMALY_COST_THRESHOLD = 10000"
						],
						"outputs": [],
						"execution_count": 58
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"source_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_OneYear.parquet\"\r\n",
							"cost_df = spark.read.format('parquet').load(source_path)"
						],
						"outputs": [],
						"execution_count": 59
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Preprocess cost data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Selecting just relevant columns for anomaly detection\r\n",
							"cost_df = cost_df.select('SubscriptionName', 'ResourceGroup', 'Date', 'CostInBillingCurrency')\r\n",
							"\r\n",
							"# Filtering out data older than 90 days to get only the latest historical data\r\n",
							"threshold = F.date_sub(F.current_date(), 90)\r\n",
							"cost_df = cost_df.filter(F.col('Date') >= threshold)\r\n",
							"\r\n",
							"# Grouping the data by each filtering level and getting the sum of all costs related to the filtering columns\r\n",
							"anomaly_df = cost_df.groupBy('SubscriptionName',\r\n",
							"                                    'ResourceGroup',\r\n",
							"                                    'Date').agg(F.round(\r\n",
							"                                                F.sum(\r\n",
							"                                                F.col('CostInBillingCurrency')), 1).alias('TotalCost'))"
						],
						"outputs": [],
						"execution_count": 60
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Classify anomalies"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Setting a partition window to divide the dataset in the filter options and order it by the Date\r\n",
							"windowSpec = Window.partitionBy('SubscriptionName', 'ResourceGroup').orderBy('Date').rowsBetween(-DETECTOR_WINDOW_SIZE, 0)\r\n",
							"\r\n",
							"# Set a moving average that is set by the n previous days\r\n",
							"anomaly_df = anomaly_df.withColumn('MovingAverage', F.round(F.avg(F.col('TotalCost')).over(windowSpec), 1))\r\n",
							"\r\n",
							"# Set a moving standard deviation of the same period\r\n",
							"anomaly_df = anomaly_df.withColumn('MovingStdDev', F.round(F.stddev(F.col('TotalCost')).over(windowSpec), 1))\r\n",
							"\r\n",
							"# Setting a scaling mechanism on the threshold in order to reduce the threshold when the costs are very high\r\n",
							"am_curve = lambda x: 13.6 * x ** -0.22\r\n",
							"\r\n",
							"# Set a minimum scale of 0.1 and a maximum scale of 3.5\r\n",
							"anomaly_df = anomaly_df.withColumn('Scaler', F.when(F.col('MovingStdDev') > 0.1, am_curve(F.col('MovingStdDev'))).otherwise(F.lit(0.1)))\r\n",
							"anomaly_df = anomaly_df.withColumn('Scaler', F.when(F.col('Scaler') > 3.5, F.lit(3.5)).otherwise(F.col('Scaler')))\r\n",
							"\r\n",
							"anomaly_df = anomaly_df.withColumn('Threshold', F.col('MovingAverage') + (F.col('MovingStdDev') * F.col('Scaler')))\r\n",
							"\r\n",
							"# If the cost is more than the stddev threshold (+ some noise cancellation), then set the datapoint to be 1, otherwise 0\r\n",
							"anomaly_df = anomaly_df.withColumn('AboveThreshold', F.when(F.col('TotalCost') > (F.col('Threshold') + 1), F.lit(1))\\\r\n",
							"                                                                                .otherwise(F.lit(0)))"
						],
						"outputs": [],
						"execution_count": 61
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Filter detected anomalies"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							" # Only consider cost items that is above threshold\r\n",
							"notification_df = anomaly_df.filter(F.col('AboveThreshold') == 1)\r\n",
							"\r\n",
							"# Set rolling window to capture date of previous anomaly in resource group\r\n",
							"window_spec = Window.partitionBy('SubscriptionName', 'ResourceGroup').orderBy('Date')\r\n",
							"notification_df = notification_df.withColumn('PrevDate', F.lag('Date').over(window_spec))\r\n",
							"\r\n",
							"# Compute number of days between anomalies in resource group\r\n",
							"notification_df = notification_df.withColumn('DateDiff', F.datediff(F.col('Date'), F.col('PrevDate')))\r\n",
							"\r\n",
							"# Notify anomaly if anomalies haven't occured on subsequent days\r\n",
							"notify_mask = (F.col('DateDiff').isNull()) | (F.col('DateDiff') > 1)\r\n",
							"notification_df = notification_df.withColumn('NotifyAnomaly', F.when( notify_mask, F.lit(True)).otherwise(F.lit(False)))\r\n",
							"\r\n",
							"# Only use cost items exceeding 10.000 NOK\r\n",
							"notification_df = notification_df.filter(F.col('TotalCost') >= ANOMALY_COST_THRESHOLD)\r\n",
							"\r\n",
							"# Dropping insignificant columns\r\n",
							"notification_df = notification_df.drop('Scaler', 'PrevDate', 'DateDiff')\r\n",
							"\r\n",
							"# Filtering only the relevant data\r\n",
							"notification_df = notification_df.filter(F.col('NotifyAnomaly') == True)"
						],
						"outputs": [],
						"execution_count": 62
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Combine anomalies with subscription data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"subscription_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/subscriptions/servicenow/latest-optimized.parquet\"\r\n",
							"sub_df = spark.read.format('parquet').load(subscription_path)\r\n",
							"\r\n",
							"sub_df = sub_df.select('Name', 'ProductOwnerUserName', 'TechnicalOwnerUserName')\r\n",
							"sub_df = sub_df.withColumnRenamed('Name','SNSubscriptionName')"
						],
						"outputs": [],
						"execution_count": 63
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Merging on subscription names\r\n",
							"notification_df = notification_df.join(sub_df, on=notification_df.SubscriptionName == sub_df.SNSubscriptionName, how='left')\r\n",
							"notification_df = notification_df.drop('SNSubscriptionName')"
						],
						"outputs": [],
						"execution_count": 64
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Write anomalies to optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"destination_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_AnomalyDetection_3mnth.parquet\"\r\n",
							"notification_df.write.format('parquet').mode('overwrite').save(destination_path)"
						],
						"outputs": [],
						"execution_count": 66
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# display(anomaly_df.filter((F.col('SubscriptionName') == 'Unassigned') & (F.col('ResourceGroup') == '')))"
						],
						"outputs": [],
						"execution_count": 67
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Finding Hyper-parameters for the Scaling-Function"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# import numpy as np\r\n",
							"# from scipy.optimize import curve_fit\r\n",
							"# import matplotlib.pyplot as plt\r\n",
							"\r\n",
							"# # The function we want to use to apply the scaling function \r\n",
							"# def scaling_function(x, a, b):\r\n",
							"#     return a * np.power(x, b)\r\n",
							"\r\n",
							"# # Costs are the \"input values\" and the degree of scaling are the output values\r\n",
							"# input_values = np.array([1000, 10000, 100000])\r\n",
							"# output_values = np.array([3, 2, 1])\r\n",
							"\r\n",
							"# # Finding the unknown parameters (a, b) for the scaling function\r\n",
							"# params, covariance = curve_fit(scaling_function, input_values, output_values)\r\n",
							"\r\n",
							"# print(f\"'a' has value: {params[0]}\")\r\n",
							"# print(f\"'b' has value: {params[1]}\")\r\n",
							"\r\n",
							"# # Plotting the scaling function against a range\r\n",
							"# x = range(0, 100000, 1000)\r\n",
							"# y = [scaling_function(i, 13.6, -0.22) for i in x]\r\n",
							"# plt.figure(figsize=(14, 10))\r\n",
							"# plt.plot(x, y, c='blue', label='Fitted curve')\r\n",
							"# plt.scatter(input_values, output_values, c='red', label='Input data points')\r\n",
							"# plt.legend()\r\n",
							"# plt.show()"
						],
						"outputs": [],
						"execution_count": 68
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/CostTagExpansion')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('CostTagExpansion_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "ef2dc14b-362a-482a-9041-66628e00badc"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('CostTagExpansion_notebookSparkPoolIdRef')]",
						"name": "[parameters('CostTagExpansion_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('CostTagExpansion_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"amortizedCostPath = 'exports/monthly/ACMMonthlyAmortizedCost/'\n",
							"actualCostPath = 'exports/monthly/ACMMonthlyActualCost/'\n",
							"toDate = '20230430'\n",
							"fromDate = '20230401'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"source": [
							"import pandas as pd\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath, fileType):\n",
							"    \n",
							"    #print('Loading Source Parquet file....')\n",
							"    #orig_df = pd.read_parquet(path)\n",
							"    \n",
							"    if fileType == 'parquet':\n",
							"        print('Loading Source Parquet file....')\n",
							"        df = pd.read_parquet(path)\n",
							"    else:  \n",
							"        print('Loading Source Parquet file....')\n",
							"        df = pd.read_csv(path)  \n",
							"    df['CostAllocationType'] = np.nan\n",
							"    df['CostAllocationCode'] = np.nan\n",
							"    df['ActiveWBSReason'] = np.nan\n",
							"    print('Loading Subscription list...')\n",
							"    subscription_list = pd.read_json(subscription_path)\n",
							"    print('Loading SNOW Application list...')\n",
							"    appList = pd.read_parquet(appListPath)\n",
							"    print('File loading complete!')\n",
							"\n",
							"    return df, subscription_list, appList\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def shorten_df(orig_df, size):\n",
							"\n",
							"    if size > 0:\n",
							"        orig_df = orig_df.head(size)\n",
							"        return orig_df\n",
							"    else:\n",
							"        return orig_df\n",
							""
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\n",
							"\n",
							"    print('Expanding the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list Tags field into their own fields...')\n",
							"\n",
							"    subscription_tags_df = subscription_list.pop('tags').apply(pd.Series)\n",
							"    subscription_list['SubscriptionWBS'] = subscription_tags_df['WBS']\n",
							"    subscription_list['SubscriptionServiceNow-App'] = subscription_tags_df['ServiceNow-App']\n",
							"    \n",
							"    subscription_list.rename(columns={\"id\": \"SubscriptionId\"}, inplace=True)\n",
							"    columns_to_keep = ['SubscriptionId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\n",
							"    \n",
							"    subscription_list.drop(columns=subscription_list.columns.difference(columns_to_keep), inplace=True)\n",
							"        \n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(df, subscription_list):\n",
							"\n",
							"    print('Merging the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list into the cost dataframe...')\n",
							"    df = df.merge(subscription_list, how='left', on='SubscriptionId')\n",
							"    \n",
							"    return df, subscription_list\n",
							""
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def replace_empty_cost_fields_with_subscription_details(df, subscription_list, appList):\n",
							"\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\n",
							"\n",
							"    df['CostAllocationCode'].replace('', np.nan, inplace=True)\n",
							"    df['CostAllocationType'].replace('', np.nan, inplace=True)\n",
							"    df['ActiveWBS'] = df.loc[df['CostAllocationType'] == 'WBS', 'CostAllocationCode']\n",
							"\n",
							"    mask = (df['CostAllocationType'] != \"WBS\") & (df['CostAllocationType'] != \"APPID\") & (df['CostAllocationType'] != \"CI\") & (df['CostAllocationType'] != \"SubscriptionWBS\")\n",
							"    df.loc[mask, ['ActiveWBSReason']] = 'Invalid CostAllocationType: not APPID, CI or WBS'\n",
							"\n",
							"    mask = (df['CostAllocationCode'].str.contains('^[a-zA-Z]\\.\\S*', regex=True) == False) & (df['CostAllocationType'] == 'WBS')\n",
							"    df.loc[mask, 'ActiveWBS'] = df.loc[mask, 'SubscriptionWBS']\n",
							"    df.loc[mask, 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'Invalid CostAllocationCode WBS'\n",
							"    \n",
							"    df['ActiveWBS'] = df['ActiveWBS'].fillna(df['CostAllocationCode'].map(appList.set_index('u_number')['u_operational_wbs']))\n",
							"    df['ActiveWBS'] = df['ActiveWBS'].fillna(df['CostAllocationCode'].map(appList.set_index('name')['u_operational_wbs']))\n",
							"    df['ActiveWBS'].replace('TOBESPECIFIED', np.nan, inplace=True)  \n",
							"    \n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationCode'] = np.nan\n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    df.loc[df['ActiveWBS'].isnull(), 'ActiveWBS'] = df['SubscriptionWBS']\n",
							"    \n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'CI')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'CI WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'APPID')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'APPID WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'WBS')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'WBS Cost Tag used'\n",
							"\n",
							"    mask = (df['Tags'].str.contains('CostAllocationCode', case=False, na=False) == False) | (df['Tags'].str.contains('CostAllocationType', case=False, na=False) == False)\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'CostAllocationType or CostAllocationCode not present in Tags'\n",
							"\n",
							"    return df, subscription_list"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(df, destinationFilename, fileType):\n",
							"    \n",
							"    if fileType == 'parquet':\n",
							"        #print(f'Writing output file to: \"{destinationFilename}.parquet\"')\n",
							"        print(f'Writing output file to: {destinationFilename}')\n",
							"        #df.to_parquet(destinationFilename + '.parquet')\n",
							"        df.to_parquet(destinationFilename)\n",
							"        print('File write complete!')\n",
							"    else:\n",
							"        print(f'Writing output file to: \"{destinationFilename}.csv\"')\n",
							"        df.to_csv(destinationFilename + '.csv')\n",
							"        print('File write complete!')"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationcode_list(tag):\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               tag_array = tag.split('\",\"')\n",
							"               #print(f\"Tag array is: {tag_array}\")\n",
							"               #print(type(tag_array))\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    #print(f'x is: {x}')\n",
							"                    #print(f'y is: {y}')\n",
							"                    #temp =  x.replace('\"','').upper()\n",
							"                    #print(f'if test: {temp}')\n",
							"                    if x.replace(\"\\\"\",\"\").upper() == \"COSTALLOCATIONCODE\":\n",
							"                         #print(\"here1\")\n",
							"                         #print(y.replace(\"\\\"\",\"\").strip('\\n').strip().upper())\n",
							"                         return y.replace(\"\\\"\",\"\").strip('\\n').strip().upper()\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationtype_list(tag):\n",
							"\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          #print(\"Here2 - null\")\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               type_list = ['WBS', 'CI', 'APPID']\n",
							"               tag_array = tag.split('\",\"')\n",
							"               #print(f\"Tag array is: {tag_array}\")\n",
							"               #print(type(tag_array))\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    #print(f'x is: {x}')\n",
							"                    #print(f'y is: {y}')\n",
							"                    #temp =  x.replace('\"','').upper()\n",
							"                    #print(f'if test: {temp}')\n",
							"                    #if temp == 'C.BAX.20.021':\n",
							"                              #print(\"here1\")\n",
							"                              #print(temp)\n",
							"                              #print(tag_array)\n",
							"                    if x.replace('\"','').upper() == \"COSTALLOCATIONTYPE\":\n",
							"                         #temp2 = y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         #print(temp2)\n",
							"                         if y.replace('\"','').strip('\\n').strip().upper() in type_list:\n",
							"                              return y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         else:\n",
							"                              #print(\"here2\")\n",
							"                              #print(temp2)\n",
							"                              #print(tag_array)\n",
							"                              return np.nan\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(df):\n",
							"\n",
							"    print(\"Extracting cost Type and Code and storing in dedicated columns...\")\n",
							"\n",
							"    df['CostAllocationType'] = df.apply(lambda x: return_costallocationtype_list(x['Tags']), axis = 1)\n",
							"    df['CostAllocationCode'] = df.apply(lambda x: return_costallocationcode_list(x['Tags']), axis = 1)\n",
							"\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pd.set_option('max_colwidth', 50)\n",
							"\n",
							"years = ['2021']\n",
							"#months = ['01', '02', '03', '04', '05', '06', '06', '07', '08', '09', '10', '11', '12']\n",
							"months = ['10', '11', '12']\n",
							"#months = ['07', '08', '09', '10', '11', '12']\n",
							"\n",
							"for year in years:\n",
							"    for month in months:\n",
							"        fromDate = year + month + '01'    \n",
							"        inputDate = datetime(int(year), int(month), 1)\n",
							"        res = calendar.monthrange(int(year), int(month))\n",
							"        lastDay = res[1]\n",
							"        toDate = year + month + str(lastDay)\n",
							"        print(toDate)\n",
							"\n",
							"        dateRange = fromDate + '-' + toDate\n",
							"\n",
							"        longToDate = datetime.strptime(toDate, '%Y%m%d').strftime('%Y-%m-%d')\n",
							"\n",
							"        extended_actual_cost_data_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"        subscription_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + longToDate + '.json'\n",
							"        #subscription_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions.json'\n",
							"        appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/applications/applicationList.parquet'\n",
							"\n",
							"        #extended_actual_cost_data_path = 'data/2022 Actual cost (10k rows).csv'\n",
							"        #extended_actual_cost_data_path = 'data/ACMMonthlyActualCost_20220101-20220131.parquet'\n",
							"        #extended_actual_cost_data_path = 'data/ACMMonthlyActualCost_20220201-20220228.parquet'\n",
							"        #size = 100000\n",
							"        #subscription_path = 'data/subscriptions.json'\n",
							"        #appListPath = 'data/applicationList.parquet'\n",
							"\n",
							"        df, subscription_list, appList = load_source_files(extended_actual_cost_data_path, subscription_path, appListPath, 'parquet')\n",
							"        #df, subscription_list, appList = load_source_files(extended_actual_cost_data_path, subscription_path, appListPath, 'csv')\n",
							"        #df = shorten_df(df, size)\n",
							"\n",
							"        #df = orig_df.copy()\n",
							"        df = expand_cost_tags(df)\n",
							"        #print(df[['Tags', 'CostAllocationType', 'CostAllocationCode']])\n",
							"        subscription_list = expand_subscription_tags(subscription_list)\n",
							"        #print(subscription_list)\n",
							"        df, subscription_list = merge_dataframes(df, subscription_list)\n",
							"        df, subscription_list = replace_empty_cost_fields_with_subscription_details(df, subscription_list, appList)\n",
							"        write_output_file(df, extended_actual_cost_data_path, 'parquet')"
						],
						"outputs": [],
						"execution_count": 12
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Daily Extend AI column and WBS tags_v1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Daily Extend AI column and WBS tags_v1_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "04ed4281-956d-438f-b961-ed930fc70c1f"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Daily Extend AI column and WBS tags_v1_notebookSparkPoolIdRef')]",
						"name": "[parameters('Daily Extend AI column and WBS tags_v1_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Daily Extend AI column and WBS tags_v1_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Input data\n",
							"toDate = '20231031'\n",
							"fromDate = '20231001'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import pyspark.pandas as ps\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings\n",
							"\n",
							"import pyspark.sql.functions as F\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath):\r\n",
							"    \r\n",
							"    csv_options = {'header' : True,\r\n",
							"                   'delimiter' : ',',\r\n",
							"                   'quote' : '\"',\r\n",
							"                   'escape' : '\"'}\r\n",
							"\r\n",
							"    print(f'Loading Cost file list - {path}')\r\n",
							"    cost_df = spark.read.options(**csv_options).csv(path)\r\n",
							"    print(f\"Cost file contains: {cost_df.count()} rows\")\r\n",
							"    \r\n",
							"    \r\n",
							"    print(f'Loading Subscription list - {subscription_path}...')\r\n",
							"    subscription_list = spark.read.json(subscription_path)\r\n",
							"    print(f\"Subscription file contains: {subscription_list.count()} rows\")\r\n",
							"\r\n",
							"    print(f'Loading SNOW application list - {appListPath}...')\r\n",
							"    appList = spark.read.format('parquet').load(appListPath)\r\n",
							"    appList = appList.withColumn('AppID', F.col('AppID').cast(\"int\"))\r\n",
							"    print(f'App list contains: {appList.count()}')\r\n",
							"\r\n",
							"    return cost_df, subscription_list, appList"
						],
						"outputs": [],
						"execution_count": 19
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(cost_df):\r\n",
							"\r\n",
							"    # Populating the Azure Hybrid Benefit Column\r\n",
							"    cost_df = cost_df.withColumn('Azure_Hybrid_Benefit', F.when(F.col('MeterSubCategory').contains('Windows'), \"Not Enabled\")\\\r\n",
							"                                                         .when(F.col('ServiceInfo2') == 'Windows Server BYOL', \"Enabled\")\\\r\n",
							"                                                         .otherwise('Not Supported'))\r\n",
							"\r\n",
							"    # Populating the isRIUsage Column\r\n",
							"    cost_df = cost_df.withColumn('IsRIUsage',\r\n",
							"                                 F.when(F.col('ReservationId').isNull(), 'On Demand Usage')\\\r\n",
							"                                  .otherwise('RI Usage'))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 20
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(cost_df):\r\n",
							"    # Extend AdditionalInfo Column\r\n",
							"    cost_df = cost_df.withColumn('AdditionalInfo', F.from_json('AdditionalInfo', 'map<string,string>', options={'inferSchema': 'true'}))\r\n",
							"\r\n",
							"    # Creating an ID column\r\n",
							"    cost_df = cost_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    # Creating a list of columns we want to keep\r\n",
							"    cols_to_keep = [\"UsageType\", \r\n",
							"                    \"ImageType\",\r\n",
							"                    \"ServiceType\",\r\n",
							"                    \"VMName\",\r\n",
							"                    \"VMApplicationName\",\r\n",
							"                    \"VMProperties\",\r\n",
							"                    \"VCPUs\",\r\n",
							"                    \"AHB\",\r\n",
							"                    \"vCores\",\r\n",
							"                    \"RINormalizationRatio\",\r\n",
							"                    \"ConsumedQuantity\",\r\n",
							"                    \"DatabaseName\"]\r\n",
							"\r\n",
							"    for col in cols_to_keep:\r\n",
							"        cost_df = cost_df.withColumn('ai_' + col, F.coalesce(F.col(f'AdditionalInfo.{col}'), F.lit(None)))\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 21
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(cost_df):\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ai_VCPUs', F.col('ai_VCPUs').cast('int'))\r\n",
							"    cost_df = cost_df.na.fill({'ai_VCPUs' : 0})\r\n",
							"    cost_df = cost_df.withColumn('AHB_CPUs', F.when(F.col('ai_VCPUs') == 0, 0)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') < 8, 8)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') < 16, 16)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') == 20, 24)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') > 20, F.col('ai_VCPUs'))\\\r\n",
							"                                              .otherwise(0))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 22
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(cost_df):\r\n",
							"\r\n",
							"    # cost_df = cost_df.withColumnRenamed('ai_VMName', 'ai_Container_VMName')\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Instance_Name', F.when(F.col('ai_VMName').isNull(), F.col('ResourceName'))\\\r\n",
							"                                                   .when(F.col('ai_VMName').isNotNull(), F.col('ai_VMName'))\\\r\n",
							"                                                   .otherwise(0))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('UnitPrice', F.col('UnitPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('PayGPrice', F.col('PayGPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Quantity', F.col('Quantity').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('EffectivePrice', F.col('EffectivePrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('CostInBillingCurrency', F.col('CostInBillingCurrency').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Date', F.to_date(F.col('Date'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodStartDate', F.to_date(F.col('BillingPeriodStartDate'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodEndDate', F.to_date(F.col('BillingPeriodEndDate'), 'MM/dd/yyyy'))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\r\n",
							"        \r\n",
							"    subscription_list = subscription_list.withColumnRenamed('id', 'SubId')\r\n",
							"    subscription_list = subscription_list.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    try:\r\n",
							"        subscription_list = subscription_list.withColumn('tags', F.from_json(F.col('tags')))\r\n",
							"    except:\r\n",
							"        print('Already a json file')\r\n",
							"\r\n",
							"    # Expanding the tags list into separate columns\r\n",
							"    subscription_list = subscription_list.withColumn('SubscriptionWBS', F.col('tags.WBS'))\r\n",
							"    subscription_list = subscription_list.withColumn('SubscriptionServiceNow-App', F.col('tags.ServiceNow-App'))\r\n",
							"    subscription_list = subscription_list.drop('tags')\r\n",
							"\r\n",
							"    # Dropping unnecessary columns and setting the schema\r\n",
							"    columns_to_keep = ['SubId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\r\n",
							"    subscription_list = subscription_list.select(columns_to_keep)\r\n",
							"\r\n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(cost_df, subscription_list):\r\n",
							"    \r\n",
							"    cost_df = cost_df.join(subscription_list, cost_df.SubscriptionId == subscription_list.SubId, how='left')\r\n",
							"    cost_df = cost_df.drop('SubId')\r\n",
							"\r\n",
							"    return cost_df, subscription_list"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(cost_df):\r\n",
							"    \r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationType\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_extract(F.col('Tags'), 'CostAllocationType\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_replace(F.col('CostAllocationType'), 'CostAllocationType\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.split(F.col('CostAllocationType'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType') == \"\", None).otherwise(F.col('CostAllocationType')))\r\n",
							"\r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_extract(F.col('Tags'), 'CostAllocationCode\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_replace(F.col('CostAllocationCode'), 'CostAllocationCode\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.split(F.col('CostAllocationCode'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(F.col('CostAllocationCode') == \"\", None).otherwise(F.col('CostAllocationCode')))\r\n",
							"    \r\n",
							"    print(\"Cost Tags expansion complete\")\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def replace_empty_cost_fields_with_subscription_details(cost_df, appList):\r\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\r\n",
							"\r\n",
							"    # Apply Upper-case for all CostAllocationTypes and Codes\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.upper(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.upper(F.col('CostAllocationCode')))\r\n",
							"\r\n",
							"    # When the tag does not contain CostAllocationCode or CostAllocationType, then we fill/replace the value in ActiveWBSReason\r\n",
							"    invalidCostAllocationMask = F.col('CostAllocationCode').isNull() | F.col('CostAllocationType').isNull()\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(invalidCostAllocationMask, F.lit('CostAllocationType or CostAllocationCode not present in Tags')))\r\n",
							"\r\n",
							"    # When either value in mask appears in AcitveWBS, add invalid reason in new column\r\n",
							"    validCostAllocationType = ['WBS', 'APPID', 'CI']\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('Invalid CostAllocationType: not APPID, CI or WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # When the values in the columns below match the mask and the cost type is WBS, then:\r\n",
							"    # regex pattern states that the string should start with a case insensitive letter, followed by a dot, followed by either letters, numbers or dots\r\n",
							"    pattern = r'^[a-zA-Z]\\.[a-zA-Z0-9.]+$'\r\n",
							"    rmask = F.col('CostAllocationCode').rlike(pattern)\r\n",
							"    cost_wbs = (F.col('CostAllocationType') == 'WBS')\r\n",
							"\r\n",
							"    # Applying valid WBS' as Active WBS'\r\n",
							"    # 1. Where the CostAllocationCode follows the regex and the CostAllocationType is WBS, we apply the CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(cost_wbs & rmask, F.col('CostAllocationCode')))\r\n",
							"    # 2. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, we set the ActiveWBSReason to be \"Invalid CostAllocationCode WBS\"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(cost_wbs & ~rmask, F.lit('Invalid CostAllocationCode WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    # 3. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, the CostAllocationType is changed to \"SubscriptionWBS\"\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(cost_wbs & ~rmask, F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"\r\n",
							"    # Applying valid AppIDs as Active WBS'\r\n",
							"    # If the CostAllocationCode is empty, we fill/replace the column ActiveWBS with Operational WBS in the AppList\r\n",
							"    map_app = appList.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'OperationalWBS')\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'APPID') & (cost_df.CostAllocationCode == map_app.AppID), how='left')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.drop('OperationalWBS')\r\n",
							"\r\n",
							"    # Applying valid CIs as Active WBS'\r\n",
							"    # Same here as above, but we merge the dataframes on ApplicationNames rather than AppID\r\n",
							"    map_app = appList.select('ApplicationName', 'OperationalWBS')\r\n",
							"    # Apply join with case insensitivity\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'CI') & (cost_df.CostAllocationCode == map_app.ApplicationName_upper), how='left').drop('ApplicationName_upper')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    \r\n",
							"    # Alternative 1 remove \"AppID\" \r\n",
							"    cost_df = cost_df.drop('ApplicationName', 'OperationalWBS')\r\n",
							"\r\n",
							"    # When ActiveWBS value is string 'TOBESPECIFIED', we replace the value with None. # Why this ActiveWBS have TOBSPECIFIED value? \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.upper(F.col('ActiveWBS')) == 'TOBESPECIFIED', F.lit(None)).otherwise(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # When Subscriptions are not attached to the costs (unassigned), we fill the values with Unassigned and state the ActiveWBSReason.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned Subscription, possibly unused RI/SP')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # Now that we have filled in most places in ActiveWBS, if the rest of ActiveWBS is Null, then we apply the CostCenter WBS\r\n",
							"    # When CostAllocationType is null, we fill it with the value from SubscriptionWBS\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'APPID'), F.lit('AppID CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'CI'), F.lit('CI CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('ActiveWBS').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('CostCenter')).otherwise(F.col('ActiveWBS'))) # Cost Center is identical to SubscriptionWBS. So we can remove subscription.json.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType'))) #  Can be removed.\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBSReason').isNull() & (F.col('CostAllocationType') == 'SubscriptionWBS'), F.lit('No valid AppID, WBS or CI')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    \r\n",
							"\r\n",
							"    # When CostAllocationType is a specific string, we fill/replace the value in ActiveWBSReason \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'CI', F.lit('CI WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'APPID', F.lit('AppID WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'WBS', F.lit('WBS Cost Tag used')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.upper(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # For cases that where CostAllocationCode is empty, we will use AppID from SerivceNow and Application from Subscription.json to replace.\r\n",
							"    mask3 = (F.col('CostAllocationType').isin(['APPID']) & F.col('CostAllocationCode').isNull())\r\n",
							"    mask4 = (F.col('CostAllocationType').isin(['CI']) & F.col('CostAllocationCode').isNull())\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(mask3, F.col('AppID')) \\\r\n",
							"                                                       .when(mask4, F.col('SubscriptionServiceNow-App')) \\\r\n",
							"                                                       .otherwise(F.col('CostAllocationCode'))).drop('AppID')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_application_names(cost_df, appList):\r\n",
							"\r\n",
							"    # Masks for CI and AppID\r\n",
							"    ci_mask = F.col('CostAllocationType') == 'CI'\r\n",
							"    appid_mask = F.col('CostAllocationType') == 'APPID'\r\n",
							"\r\n",
							"    # When AppID is present, we use the application name from the Service-Now Application list\r\n",
							"    # First convert AppID to a string, then select the desired columns\r\n",
							"    map_app = appList.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'ApplicationName')\r\n",
							"\r\n",
							"    # Apply case insensitivity merge by creating upper case columns\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode_upper',F.upper(F.col('CostAllocationCode')))\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    # Merge CostAllocationCode on APPID\r\n",
							"    cost_df = cost_df.join(map_app, cost_df.CostAllocationCode_upper == map_app.AppID, how='left')\r\n",
							"\r\n",
							"    # Make copy of service now app list for second merge\r\n",
							"    map_app_copy = map_app.alias('map_app_copy').withColumnRenamed('AppID', 'NewAppID').withColumnRenamed('ApplicationName_upper', 'NewApplicationName_upper').withColumnRenamed('ApplicationName', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Merge CostAllicationCode on ApplicationName copy\r\n",
							"    cost_df = cost_df.join(map_app_copy, cost_df.CostAllocationCode_upper == map_app_copy.NewApplicationName_upper, how='left')\r\n",
							"\r\n",
							"    # Populate original AppId and ApplicationName columns from the copied columns\r\n",
							"    cost_df = cost_df.withColumn('AppID', F.when(F.col('AppID').isNull(), F.col('NewAppID')).otherwise(F.col('AppID')))\r\n",
							"    cost_df = cost_df.withColumn('ApplicationName', F.when(F.col('ApplicationName').isNull(), F.col('NewApplicationName')).otherwise(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    cost_df = cost_df.drop('CostAllocationCode_upper', 'ApplicationName_upper', 'NewAppID', 'NewApplicationName_upper', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Create Application_Name column based on Application from ServiceNow to start with.\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.col('ApplicationName'))\r\n",
							"\r\n",
							"    # Resolve CostAllocationCode and CostAllocationType typo by replacing Application_name with SubscriptionServiceNow-App value \r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when((F.col('CostAllocationType') == 'APPID') & F.col('CostAllocationCode').cast('int').isNull(),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                    .when((F.col('CostAllocationType') == 'CI') & F.col('CostAllocationCode').cast('int').isNotNull(),F.col('SubscriptionServiceNow-App')).otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when(((F.col('CostAllocationType') == \"SubscriptionWBS\") | (F.col('CostAllocationType') == \"WBS\"))&(F.col('Application_Name').isNull()),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                     .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name_upper',F.upper(F.col('Application_Name')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowAppID',F.col('AppID')).drop('AppID')\r\n",
							"\r\n",
							"    # Lookup application in ServiceNow. Those applications that can be found will be merged.\r\n",
							"    cost_df = cost_df.join(map_app,cost_df.Application_Name_upper==map_app.ServiceNowApplicationName_upper,how='left')\r\n",
							"\r\n",
							"    # Fill empty AppID with AppID from ServiceNow\r\n",
							"    cost_df = cost_df.withColumn('AppID',F.when(F.col('AppID').isNull(),F.col('ServiceNowAppID'))\\\r\n",
							"                                          .otherwise(F.col('AppID'))) \r\n",
							"\r\n",
							"    # Remove unused Columns\r\n",
							"    cost_df = cost_df.drop('Application_Name_upper','ApplicationName','ServiceNowAppID','ServiceNowApplicationName_upper','ApplicationName_upper')\r\n",
							"\r\n",
							"\r\n",
							"    # Application Name will be \"Application not defined or not found\" when SubscriptionServiceNow-App is equal to Application_name as well as AppID is empty.\r\n",
							"    # This indicates that application from subscription.json file can not be found in ServiceNow. One of Application example is DATAHUB - MARKETING AND SUPPLY, not found in ServiceNow.\r\n",
							"    cost_df = cost_df.withColumn('Application_Name', F.when((F.upper(F.col('SubscriptionServiceNow-App'))==F.upper(F.col('Application_Name'))) & (F.col('AppID').isNull()),F.lit('Application not defined or not found'))\\\r\n",
							"                                                    .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    # For anything that left ApplicationName will be \"Application not defined or not found\" and For anything that left AppID will be 0.\r\n",
							"    cost_df = cost_df.na.fill({'AppID': 0, 'Application_Name': 'Application not defined or not found'})\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_ai_column(cost_df):\r\n",
							"\r\n",
							"    warnings.simplefilter(action='ignore', category=FutureWarning)\r\n",
							"    cost_df = populate_columns(cost_df)\r\n",
							"    cost_df = extend_additional_info(cost_df)\r\n",
							"    cost_df = AHB_column(cost_df)\r\n",
							"    cost_df = instance_name(cost_df)\r\n",
							"    \r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_wbs_columns(cost_df, subscription_list, appList):\r\n",
							"\r\n",
							"    cost_df = expand_cost_tags(cost_df)\r\n",
							"    subscription_list = expand_subscription_tags(subscription_list)\r\n",
							"    cost_df, subscription_list = merge_dataframes(cost_df, subscription_list)\r\n",
							"    cost_df = replace_empty_cost_fields_with_subscription_details(cost_df, appList)\r\n",
							"    print('WBS population complete. Populating application names')\r\n",
							"    cost_df = get_application_names(cost_df, appList)    \r\n",
							"    print('App-name population complete')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"\n",
							"    cost_df = cost_df.drop('id', 'AdditionalInfo') \n",
							"    print('start to write to container')\n",
							"    cost_df.write.format('parquet').mode('overwrite').option('path', destinationFilename).save()\n",
							"    print('File write complete!')"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"print(f'fromDate: {fromDate}')\n",
							"print(f'toDate: {toDate}')\n",
							"reportTypes = ['ActualCost', 'AmortizedCost']\n",
							"year = toDate[:4]\n",
							"month = toDate[4:6]\n",
							"day = toDate[6:]\n",
							"\n",
							"print(f\"------ From: {fromDate}, To: {toDate} -----------\")\n",
							"\n",
							"for reportType in reportTypes:\n",
							"\n",
							"    print(f\"------ {reportType} -----------\")\n",
							"\n",
							"    sourceCostPath = 'exports/daily/ACMDaily' + reportType + '/'\n",
							"    destinationCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"\n",
							"    longToDate = f'{toDate[0:4]}-{toDate[4:6]}-{toDate[6:]}'\n",
							"    print(f'longToDate: {longToDate}')\n",
							"    dateRange = fromDate + '-' + toDate\n",
							"    print(f'dateRange: {dateRange}')\n",
							"\n",
							"    print(dateRange)\n",
							"    costSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/*.csv'\n",
							"    costDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationCostPath + dateRange + '/Extended_v2_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"    print(f\"Cost data path: {costSourcefilename}\")\n",
							"    print(f\"Cost destination path: {costDestinationfilename}\")\n",
							"    \n",
							"    if str(longToDate) < '2021-11-30':\n",
							"        print(longToDate)\n",
							"        print(f'Using default 2021-11-30 subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_2021-11-30.json'\n",
							"        print(f\"Subscription path: {subscriptionListPath}\")\n",
							"    \n",
							"    else:\n",
							"        # Converting month string into integer\n",
							"        month_int = int(toDate[4:6])\n",
							"        year_int = int(toDate[:4])\n",
							"\n",
							"        # Getting the last month-value\n",
							"        previous_month = (month_int - 1) if month_int > 1 else 12\n",
							"        previous_year = year_int if month_int > 1 else (year_int - 1)\n",
							"\n",
							"        # Converting it back into a string\n",
							"        previous_month_str = str(previous_month).zfill(2)\n",
							"        previous_year_str = str(previous_year)\n",
							"\n",
							"        # Calculating the last day of the month\n",
							"        last_day = calendar.monthrange(previous_year, previous_month)[1]\n",
							"\n",
							"        # Converting it into a string\n",
							"        last_day_str = str(last_day).zfill(2)\n",
							"\n",
							"        # Creating a string date for last month\n",
							"        previousMonthDate = previous_year_str + '-' + previous_month_str + '-' + last_day_str\n",
							"\n",
							"        print(f'Using {longToDate} subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + previousMonthDate + '.json'\n",
							"        print(f\"Subscription path: {subscriptionListPath}\")\n",
							"\n",
							"    appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/applications/ServiceNow-Application-List-Extended.parquet'\n",
							"    print(f\"App-list path: {appListPath}\")\n",
							"    cost_df, subscription_list, appList = load_source_files(costSourcefilename, subscriptionListPath, appListPath)\n",
							"    cost_df = expand_ai_column(cost_df)\n",
							"    cost_df = populate_wbs_columns(cost_df, subscription_list, appList)\n",
							"    write_output_file(cost_df, costDestinationfilename)\n",
							"    \n",
							"    print(' ')"
						],
						"outputs": [],
						"execution_count": 32
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Cost File')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Extend Cost File_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "fe69609e-d933-436c-a7c7-9669e6b073da"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Extend Cost File_notebookSparkPoolIdRef')]",
						"name": "[parameters('Extend Cost File_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Extend Cost File_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"amortizedCostPath = 'exports/monthly/ACMMonthlyAmortizedCost/'\n",
							"actualCostPath = 'exports/monthly/ACMMonthlyActualCost/'\n",
							"toDate = '20230131'\n",
							"fromDate = '20230101'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"#import pyarrow.parquet as pq\n",
							"#import pyarrow as pa\n",
							"#import fastparquet import warnings\n",
							"import warnings"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source(actualCostSourcefilename):\n",
							"\n",
							"    print('Loading Actual Cost df...')\n",
							"    print(actualCostSourcefilename)\n",
							"    actualCost_df = pd.read_parquet(actualCostSourcefilename)\n",
							"    #actualCost_df = pd.read_parquet(actualCostSourcefilename, engine='fastparquet')\n",
							"    #actualCost_df = pq.read_table(source=actualCostSourcefilename).to_pandas()\n",
							"    print(f'Source file contains {len(actualCost_df):,} rows')\n",
							"\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(actualCost_df):\n",
							"\n",
							"    # Populating the Azure Hynbrid Benefit Column\n",
							"    actualCost_df['Azure Hybrid Benefit'] = np.where(actualCost_df['MeterSubCategory'].str.contains(\"Windows\"), \"Not enabled\", np.where(actualCost_df['ServiceInfo2'] == \"Windows Server BYOL\", \"Enabled\", \"Not supported\"))\n",
							"\n",
							"    # Populating the isRIUsage Column\n",
							"    actualCost_df['IsRIUsage'] = np.where(actualCost_df['ReservationId'].isna(), \"On Demand Usage\", \"RI Usage\")\n",
							"\n",
							"    # Extend AdditionalInfo Column\n",
							"    print('Calculating Mask....')\n",
							"    mask = actualCost_df['AdditionalInfo'].notna()\n",
							"    actualCost_df.loc[mask, 'AdditionalInfo'] = actualCost_df.loc[mask, 'AdditionalInfo'].apply(json.loads)\n",
							"    \n",
							"\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(actualCost_df):\n",
							"    \n",
							"    print('Expanding the AdditionalInfo column...')\n",
							"    #actualCost_df = pd.concat([actualCost_df, actualCost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')], axis=1)\n",
							"    AddiationalInfo_df = actualCost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')\n",
							"    #AddiationalInfo_df = AddiationalInfo_df[[\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]]\n",
							"    columns_to_keep = [\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]\n",
							"    AddiationalInfo_df.drop(AddiationalInfo_df.columns.difference(columns_to_keep), axis=1, inplace=True)\n",
							"\n",
							"    # Concatenating AdditionalInfo Column with the rest of the DataFrame\n",
							"    print('Concatenating AdditionalInfo Column with the rest of the DataFrame....')\n",
							"    actualCost_df = pd.concat([actualCost_df, AddiationalInfo_df], axis=1)\n",
							"\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(actualCost_df):\n",
							"    \n",
							"    print('Populating the AHB vCPUs column...')\n",
							"    actualCost_df['ai_VCPUs'] = actualCost_df['ai_VCPUs'].fillna(0)\n",
							"    actualCost_df['ai_VCPUs'] = actualCost_df['ai_VCPUs'].astype(int)\n",
							"    actualCost_df['AHB vCPUs'] = np.where(actualCost_df['ai_VCPUs'] == 0, 0, \n",
							"        np.where(actualCost_df['ai_VCPUs'] < 8, 8, \n",
							"        np.where(actualCost_df['ai_VCPUs'] <= 16, 16,\n",
							"        np.where(actualCost_df['ai_VCPUs'] == 20, 24,\n",
							"        np.where(actualCost_df['ai_VCPUs'] > 20, actualCost_df['ai_VCPUs'], 0)))))\n",
							"\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(actualCost_df):    \n",
							"    \n",
							"    print('Populating the Instance Name column...')\n",
							"    actualCost_df.rename({'ai_VmName':'ai_Container_VmName'}, axis=1, inplace=True)\n",
							"    actualCost_df['Instance Name'] = np.where(actualCost_df['ai_VMName'].isna(), actualCost_df['ResourceName'],\n",
							"        np.where(actualCost_df['ai_VMName'].notna(), actualCost_df['ai_VMName'], pd.NA))\n",
							"\n",
							"    actualCost_df['Date'] = actualCost_df['Date'].dt.date\n",
							"    \n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output(actualCost_df, actualCostDestinationfilename):\n",
							"\n",
							"    print('Writing Extended file...')\n",
							"    actualCost_df.to_parquet(actualCostDestinationfilename)\n",
							"    #actualCost_df.to_parquet(actualCostDestinationfilename, engine='fastparquet')\n",
							"    '''table = pa.Table.from_pandas(actualCost_df, preserve_index=True)\n",
							"    print(table)\n",
							"    pq.write_table(table, actualCostDestinationfilename)'''\n",
							"    del actualCost_df\n",
							"    print('Extended file write complete!')\n",
							""
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"warnings.simplefilter(action='ignore', category=FutureWarning)\n",
							"\n",
							"#years = ['2020']\n",
							"#months = ['12', '11', '10', '09', '08', '07', '06', '05', '04', '03', '02', '01']\n",
							"#months = ['05', '04', '03', '02', '01', '06']\n",
							"\n",
							"#for year in years:\n",
							"#    for month in months:\n",
							"#fromDate = year + month + '01'    \n",
							"#inputDate = datetime(int(year), int(month), 1)\n",
							"#res = calendar.monthrange(int(year), int(month))\n",
							"#lastDay = res[1]\n",
							"#toDate = year + month + str(lastDay)\n",
							"#print(toDate)\n",
							"\n",
							"dateRange = fromDate + '-' + toDate\n",
							"\n",
							"actualCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"actualCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"#amortizedCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"#amortizedCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"\n",
							"actualCost_df = load_source(actualCostSourcefilename)\n",
							"actualCost_df = populate_columns(actualCost_df)\n",
							"actualCost_df = extend_additional_info(actualCost_df)\n",
							"actualCost_df = AHB_column(actualCost_df)\n",
							"actualCost_df = instance_name(actualCost_df)\n",
							"write_output(actualCost_df,actualCostDestinationfilename)\n",
							""
						],
						"outputs": [],
						"execution_count": 9
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Extend Cost File_v2')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Extend Cost File_v2_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "c2216ffe-84ee-4a51-abea-458cbeebf7a8"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Extend Cost File_v2_notebookSparkPoolIdRef')]",
						"name": "[parameters('Extend Cost File_v2_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Extend Cost File_v2_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"amortizedCostPath = 'exports/monthly/ACMMonthlyAmortizedCost/'\r\n",
							"actualCostPath = 'exports/monthly/ACMMonthlyActualCost/'\r\n",
							"toDate = '20230731'\r\n",
							"fromDate = '20230701'\r\n",
							"container = 'usage'\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.pandas as ps\r\n",
							"import json\r\n",
							"import numpy as np\r\n",
							"import pandas as pd\r\n",
							"import warnings\r\n",
							"\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source(actualCostSourcefilename):\r\n",
							"\r\n",
							"    print('Loading Actual Cost df...')\r\n",
							"    print(actualCostSourcefilename)\r\n",
							"    actualCost_df = spark.read.format('parquet').load(actualCostSourcefilename)\r\n",
							"    #actualCost_df = pd.read_parquet(actualCostSourcefilename, engine='fastparquet')\r\n",
							"    #actualCost_df = pq.read_table(source=actualCostSourcefilename).to_pandas()\r\n",
							"    print(f'Source file contains {actualCost_df.count():,} rows')\r\n",
							"\r\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(actualCost_df):\r\n",
							"\r\n",
							"    actualCost_df = actualCost_df.withColumn('Azure_Hybrid_Benefit', F.when(F.col('MeterSubCategory').contains('Windows'), \"Not Enabled\")\\\r\n",
							"                                                                      .when(F.col('ServiceInfo2') == 'Windows Server BYOL', \"Enabled\")\\\r\n",
							"                                                                      .otherwise('Not Supported'))\r\n",
							"\r\n",
							"    actualCost_df = actualCost_df.withColumn('IsRIUsage', F.when(F.col('ReservationId').isNull(), 'On Demand Usage').otherwise('RI Usage'))\r\n",
							"\r\n",
							"    return actualCost_df\r\n",
							"    "
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(actualCost_df):\r\n",
							"    # Convert column into Json-dict\r\n",
							"    actualCost_df = actualCost_df.withColumn('AdditionalInfo', F.from_json(F.col('AdditionalInfo'), 'map<string,string>', options={'inferSchema': 'true'}))\r\n",
							"\r\n",
							"    actualCost_df = actualCost_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    cols_to_keep = [\"UsageType\",\r\n",
							"                    \"ImageType\",\r\n",
							"                    \"ServiceType\",\r\n",
							"                    \"VMName\",\r\n",
							"                    \"VMProperties\",\r\n",
							"                    \"VCPUs\",\r\n",
							"                    \"AHB\",\r\n",
							"                    \"vCores\",\r\n",
							"                    \"RINormalizationRatio\",\r\n",
							"                    \"ConsumedQuantity\",\r\n",
							"                    \"DatabaseName\"]\r\n",
							"\r\n",
							"    for col in cols_to_keep:\r\n",
							"        actualCost_df = actualCost_df.withColumn('ai_' + col, F.coalesce(F.col(f'AdditionalInfo.{col}'), F.lit(None)))\r\n",
							"\r\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(actualCost_df):\r\n",
							"    print('Populating the AHB vCPUs column...')\r\n",
							"    actualCost_df = actualCost_df.withColumn('ai_VCPUs', F.col('ai_VCPUs').cast('int'))\r\n",
							"    actualCost_df = actualCost_df.na.fill({'ai_VCPUs' : 0})\r\n",
							"    actualCost_df = actualCost_df.withColumn('AHB_CPUs', F.when(F.col('ai_VCPUs') == 0, 0)\\\r\n",
							"                                                          .when(F.col('ai_VCPUs') < 8, 8)\\\r\n",
							"                                                          .when(F.col('ai_VCPUs') < 16, 16)\\\r\n",
							"                                                          .when(F.col('ai_VCPUs') == 20, 24)\\\r\n",
							"                                                          .when(F.col('ai_VCPUs') > 20, F.col('ai_VCPUs'))\\\r\n",
							"                                                          .otherwise(0))\r\n",
							"\r\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_wbs_columns(cost_df, subscription_list, year, month, reportType):\r\n",
							"\r\n",
							"    cost_df = expand_cost_tags(cost_df)\r\n",
							"    subscription_list = expand_subscription_tags(subscription_list)\r\n",
							"    cost_df, subscription_list = merge_dataframes(cost_df, subscription_list)\r\n",
							"    cost_df = replace_empty_cost_fields_with_subscription_details(cost_df, appList)\r\n",
							"\r\n",
							"    print('WBS population complete')\r\n",
							"    \r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(actualCost_df):    \r\n",
							"    \r\n",
							"    print('Populating the Instance Name column...')\r\n",
							"    # actualCost_df = actualCost_df.withColumnRenamed('ai_VMName', 'ai_Container_VmName'})\r\n",
							"    actualCost_df = actualCost_df.withColumn('Instance_Name', F.when(F.col('ai_VMName').isNull(), F.col('ResourceName'))\\\r\n",
							"                                                               .when(F.col('ai_VMName').isNotNull(), F.col('ai_VMName'))\\\r\n",
							"                                                               .otherwise(0))  \r\n",
							"    \r\n",
							"\r\n",
							"    actualCost_df = actualCost_df.withColumn('Date', F.col('Date').cast(T.DateType()))\r\n",
							"    \r\n",
							"    return actualCost_df"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output(actualCost_df, actualCostDestinationfilename):\r\n",
							"\r\n",
							"    # Dropping some columns before writing the output\r\n",
							"    actualCost_df = actualCost_df.drop('id', 'AdditionalInfo')\r\n",
							"\r\n",
							"    print('Writing Extended file...')\r\n",
							"    actualCost_df.write.format('parquet').mode('overwrite').option('path', actualCostDestinationfilename).save()\r\n",
							"\r\n",
							"    del actualCost_df\r\n",
							"    print('Extended file write complete!')"
						],
						"outputs": [],
						"execution_count": 32
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"warnings.simplefilter(action='ignore', category=FutureWarning)\r\n",
							"\r\n",
							"dateRange = fromDate + '-' + toDate\r\n",
							"\r\n",
							"#actualCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\r\n",
							"#actualCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\r\n",
							"\r\n",
							"actualCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + dateRange + '/ACMMonthlyAmortizedCost_' + dateRange + '.parquet'\r\n",
							"actualCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + dateRange + '/Extended_ACMMonthlyAmortizedCost_' + dateRange + '.parquet'\r\n",
							"\r\n",
							"actualCost_df = load_source(actualCostSourcefilename)\r\n",
							"actualCost_df = populate_columns(actualCost_df)\r\n",
							"actualCost_df = extend_additional_info(actualCost_df)\r\n",
							"actualCost_df = AHB_column(actualCost_df)\r\n",
							"actualCost_df = instance_name(actualCost_df)\r\n",
							"write_output(actualCost_df, actualCostDestinationfilename)\r\n",
							"\r\n",
							"# display(actualCost_df)"
						],
						"outputs": [],
						"execution_count": 33
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Get RI Recommendations')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Get RI Recommendations_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": true,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "f3adde53-7fd2-4a1a-aa9a-095ac265cec3"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Get RI Recommendations_notebookSparkPoolIdRef')]",
						"name": "[parameters('Get RI Recommendations_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Get RI Recommendations_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"container = 'tbc'\n",
							"folder = 'tbc'\n",
							"filename = 'tbc'\n",
							"scope = 'Shared'\n",
							"billingAccount = 'tbc'\n",
							"lookBackPeriod = 'Last30Days'\n",
							"resourceType = 'tbc'\n",
							"term = 'P3Y'\n",
							"storageAccount = ''"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from azure.identity import DefaultAzureCredential\n",
							"from azure.mgmt.consumption import ConsumptionManagementClient\n",
							"from azure.keyvault.secrets import SecretClient\n",
							"from azure.identity import DefaultAzureCredential, ClientSecretCredential, ManagedIdentityCredential\n",
							"from notebookutils import mssparkutils\n",
							"import json\n",
							"import pandas as pd\n",
							"\n",
							"def get_ri_recommendations(scope, lookBackPeriod, term):\n",
							"    keyVaultName = 'acm-toolkit-kv'\n",
							"    KVUri = f\"https://{keyVaultName}.vault.azure.net\"\n",
							"    \n",
							"    tenantIdSecretName = 'tenantID'\n",
							"    clientIdSecretName = 'sp-ClientID'\n",
							"    secretName = 'sp-password'\n",
							"    subscriptionId = '13d66f54-0a19-4912-b4f3-54d15897368d'\n",
							"    \n",
							"    secret = mssparkutils.credentials.getSecret(keyVaultName, secretName)\n",
							"    ClientID = mssparkutils.credentials.getSecret(keyVaultName, clientIdSecretName)\n",
							"    tenantID = mssparkutils.credentials.getSecret(keyVaultName, tenantIdSecretName)\n",
							"\n",
							"    resource_scope = \"subscriptions/\" + subscriptionId\n",
							"    queryFilter = \"properties/scope eq '\" + scope + \"' and properties/lookBackPeriod eq '\" + lookBackPeriod + \"' AND properties/term eq '\" + term + \"'\"\n",
							"    \n",
							"    print(f\"Retrieving your secret from {keyVaultName}.\")\n",
							"\n",
							"    credential = ClientSecretCredential(tenant_id=tenantID, client_id=ClientID, client_secret=secret)\n",
							"    client = ConsumptionManagementClient(\n",
							"        credential=credential,\n",
							"        subscription_id=subscriptionId,\n",
							"    )\n",
							"\n",
							"    paged_recommendations = client.reservation_recommendations.list(\n",
							"        #resource_scope=\"providers/Microsoft.Billing/billingAccounts/57950773\",\n",
							"        resource_scope=resource_scope, filter=queryFilter\n",
							"    )\n",
							"\n",
							"    # Finished with the consumption client so shutting it down    \n",
							"    client.close()\n",
							"\n",
							"    # Creating blank array to hold the unpaged results\n",
							"    recommendations = []\n",
							"\n",
							"    # for each paged recommendation store the unpaged data in the recommendations array\n",
							"    for item in paged_recommendations:\n",
							"        if item.term == term:\n",
							"            recommendations.append(item.serialize(dict.items))\n",
							"\n",
							"    recommendations_df = pd.json_normalize(recommendations, max_level=1, sep='_')\n",
							"\n",
							"    #print(recommendations_df)\n",
							"    return recommendations_df\n",
							"\n",
							"def save_df_to_csv(recommendations_df, container, folder, filename, scope, billingAccount, lookBackPeriod, resourceType):\n",
							"    ri_recs_filename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + folder + '/' + filename\n",
							"    print('Saving Recommendation DataFrame to csv file at: ', ri_recs_filename)\n",
							"    recommendations_df.to_csv()\n",
							"    print(recommendations_df)\n",
							"\n",
							"if __name__ == \"__main__\":\n",
							"    recommendations_df = get_ri_recommendations(scope, lookBackPeriod, term)\n",
							"    save_df_to_csv(recommendations_df, container, folder, filename, scope, billingAccount, lookBackPeriod, resourceType)"
						],
						"outputs": [],
						"execution_count": 4
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB Savings')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('HUB Savings_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "ca476b31-5bed-46cb-857a-b0b8202f8932"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('HUB Savings_notebookSparkPoolIdRef')]",
						"name": "[parameters('HUB Savings_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('HUB Savings_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"start_date = '2022-06-01'\n",
							"end_date = '2022-06-30'\n",
							"storageAccount = 's037costmgmt'\n",
							"\n",
							"source_filename = 'data/' + start_date + '_' + end_date + '-cleaned.parquet'\n",
							"\n",
							"pricelist_file = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/pricesheet-LATEST.parquet'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from turtle import st\n",
							"import pandas as pd\n",
							"import numpy as np\n",
							"import pyarrow as pa\n",
							"#import fastparquet as fp\n",
							"import json\n",
							"from notebookutils import mssparkutils\n",
							"import calendar\n",
							"\n",
							"'''mssparkutils.fs.unmount(\"/usage\") \n",
							"print('Mounting storage container \"usage@s037costmgmt.dfs.core.windows.net\" to \"/usage\"...')\n",
							"mssparkutils.fs.mount( \n",
							"    \"abfss://usage@s037costmgmt.dfs.core.windows.net\", \n",
							"    \"/usage\", \n",
							"    {\"linkedService\":\"s037-cost-management-WorkspaceDefaultStorage\"} \n",
							")\n",
							"\n",
							"#path = 'synfs:/'+str(mssparkutils.env.getJobId())+filePath+fileName\n",
							"#print(mssparkutils.fs.ls(path))'''\n",
							"\n",
							"def calculate_hub_saving(path, year, month, pricelist):\n",
							"    \n",
							"    start_date = year + '-' + month + '-01'\n",
							"    end_date = year + '-' + month + '-' + str(calendar.monthrange(int(year), int(month))[1])\n",
							"\n",
							"    print(path)\n",
							"    print(start_date)\n",
							"    print(end_date)\n",
							"    \n",
							"    #Read in the source Parquet file\n",
							"    print('Reading in monthly usage parquet')\n",
							"    df = pd.read_parquet(path + start_date + '_' + end_date + '-cleaned.parquet')\n",
							"    #df = pd.read_csv(csv_file)\n",
							"\n",
							"    print('Dropping all non HUB entries from the usage df')\n",
							"    #Drop all entries where ServiceInfo2 does not contain 'Windows Server BYOL' i.e. remove all entries that are not Windows Server HUB\n",
							"    df = df.drop(df.loc[df['ServiceInfo2'] != 'Windows Server BYOL'].index).reset_index()\n",
							"\n",
							"    print('Expanding the AdditionalInfo Column')\n",
							"    # Expand the json in the AdditionalInfo column into its own columns in a pd.Series then join it with the source dataframe\n",
							"    ser = df['AdditionalInfo'].apply(lambda s: pd.json_normalize(json.loads(s)))\n",
							"    ##df.to_csv('data/1st.csv')\n",
							"    ser2 = pd.concat(list(ser), ignore_index=True)\n",
							"    df = df.join(ser2,)\n",
							"\n",
							"    print('Dropping all usage columns that are not required')\n",
							"    # Drop all columns except those in the columns_to_keep that we define below\n",
							"    columns_to_keep = ['ServiceType', 'VCPUs', 'Date', 'ConsumedQuantity','PartNumber','Product','ServiceInfo2']\n",
							"    df = df[columns_to_keep]\n",
							"\n",
							"    print('Populating the priceListService column')\n",
							"    df['priceListService'] = f'Windows Server - ' + df[\"VCPUs\"].astype(str) + ' vCPU VM License'\n",
							"    #print(df[df['VCPUs'] == 8])\n",
							"\n",
							"    print('Dropping all pricelist entries whos offerId != MS-AZR-017P')\n",
							"    pricelist.drop(pricelist[pricelist['offerId'] != 'MS-AZR-0017P'].index, inplace=True)\n",
							"    columns_to_keep = ['meterName','unitOfMeasure',\t'includedQuantity', 'partNumber', 'unitPrice']\n",
							"    pricelist = pricelist[columns_to_keep]\n",
							"    #print(pricelist)\n",
							"    #print(pricelist[pricelist['meterName'] == 'Windows Server - 4 vCPU VM License']['unitPrice'])\n",
							"    print('Merging usage df priceListService Column with pricelist details')\n",
							"    df = df.merge(pricelist, left_on='priceListService', right_on='meterName')\n",
							"    df.drop(['priceListService', 'includedQuantity'], axis = 1, inplace=True)\n",
							"    print('Removing extra text in the Units Column')\n",
							"    df['Units'] = df['unitOfMeasure']\n",
							"    df['Units'] = df['Units'].str.replace(' Hours', '')\n",
							"    df['Units'] = df['Units'].str.replace(' Hour', '')\n",
							"    df['Units'] = df['Units'].astype(float)\n",
							"    print('Calculating the unitPricePH')\n",
							"    df['unitPricePH'] = df['unitPrice'] / df['Units']\n",
							"    print('Calculating the Saving')\n",
							"    df['Saving'] = df['ConsumedQuantity'] * df['unitPricePH']\n",
							"    df = df.groupby(['ServiceType', 'Date'], as_index=False).aggregate({'VCPUs':np.mean, 'ConsumedQuantity':np.sum,'unitPrice':np.mean, 'Units':np.mean, 'unitPricePH': np.mean, 'Saving':np.sum})\n",
							"    #print(df)\n",
							"    print(df['Saving'].sum())\n",
							"    #print(df.columns)\n",
							"    #print(df[df['ServiceType'] == 'Standard_D4s_v3']['Saving'].sum())\n",
							"    print('Writing Saving to CSV')\n",
							"    df.to_csv('abfss://savings@'+storageAccount+'.dfs.core.windows.net/monthly/'+year+'/'+month+'/'+start_date + '_' + end_date + '-HUB_Windows.csv', index=False)\n",
							"    print('Writing Saving to Parquet')\n",
							"    df.to_parquet('abfss://savings@'+storageAccount+'.dfs.core.windows.net/monthly/'+year+'/'+month+'/'+start_date + '_' + end_date + '-HUB_Windows.parquet', index=False)\n",
							"\n",
							"\n",
							"pricelist = pd.read_parquet(pricelist_file)\n",
							"#print(source_filename)\n",
							"\n",
							"year_list = mssparkutils.fs.ls(f'abfss://usage@{storageAccount}.dfs.core.windows.net/monthly')\n",
							"\n",
							"schema = ['path','name','size']\n",
							"year_list_df = pd.DataFrame([[getattr(i,j) for j in schema] for i in year_list], columns = schema)\n",
							"#print(dir_list_df)\n",
							"\n",
							"for year in year_list_df['name']:\n",
							"    month_list = mssparkutils.fs.ls('abfss://usage@' + storageAccount + '.dfs.core.windows.net/monthly/' + year)\n",
							"    schema = ['path','name','size']\n",
							"    month_list_df = pd.DataFrame([[getattr(i,j) for j in schema] for i in month_list], columns = schema)\n",
							"    #print(month_list_df)\n",
							"    for month in month_list_df['name']:\n",
							"        calculate_hub_saving('abfss://usage' + storageAccount + '.dfs.core.windows.net/monthly/' + year + '/' + month + '/', year, month, pricelist)\n",
							"\n",
							"\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": 2
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/HUB_Daily_File')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('HUB_Daily_File_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": true,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "8eaa0d12-895b-4a65-bc7d-5735d32ee980"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('HUB_Daily_File_notebookSparkPoolIdRef')]",
						"name": "[parameters('HUB_Daily_File_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('HUB_Daily_File_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from datetime import timedelta, datetime\n",
							"from dateutil.relativedelta import relativedelta\n",
							"import calendar\n",
							"import json\n",
							"import pandas as pd\n",
							"from notebookutils import mssparkutils\n",
							"from azure.storage.blob import BlobServiceClient\n",
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"KEY_VAULT_NAME = 'acm-toolkit-kv'\r\n",
							"LINKED_SERVICE_NAME = 'ACM_Toolkit_kv'"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"hubAutomationConnectionString = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'hubautomation-sa-connectionstring', LINKED_SERVICE_NAME)"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_dates_last_month():\r\n",
							"    last_month_start = (datetime.now() - relativedelta(months=1)).strftime('%Y%m01')\r\n",
							"    today = datetime.now()\r\n",
							"    first = today.replace(day=1)\r\n",
							"    res = first - timedelta(days=1)\r\n",
							"    last_month_end = res.date().strftime('%Y%m%d')\r\n",
							"    return last_month_start, last_month_end"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"end_date = (datetime.now().strftime('%Y-%m-%d'))\r\n",
							"vm_start_date = (datetime.now() - timedelta(days=2)).strftime('%Y-%m-%d')\r\n",
							"sql_start_date = (datetime.now() - timedelta(days=3)).strftime('%Y-%m-%d')"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"daily_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/daily/ACMDailyActualCost/ACMDailyActualCost.parquet'\r\n",
							"daily_df = spark.read.format('parquet').load(daily_path)\r\n",
							"\r\n",
							"last_month_start, last_month_end = get_dates_last_month()\r\n",
							"\r\n",
							"monthly_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/{last_month_start}-{last_month_end}/ACMMonthlyActualCost_{last_month_start}-{last_month_end}.parquet'\r\n",
							"monthly_df = spark.read.format('parquet').load(monthly_path)\r\n",
							"\r\n",
							"cost_df = daily_df.union(monthly_df)"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Write pricesheet to HUBAutomation"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pricesheet_source_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-latest'\r\n",
							"pricesheet_target_path = 'abfss://win-activity@hubautomation.dfs.core.windows.net/usage_details/pricesheet.csv'\r\n",
							"\r\n",
							"print('Loading the latest pricesheet from source parquet')\r\n",
							"pricesheet = spark.read.format('parquet').load(pricesheet_source_path)\r\n",
							"print('Writing pricesheet to destination csv file')\r\n",
							"pricesheet.toPandas().to_csv(pricesheet_target_path, index=False)"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load cost data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"vm_cost_df = cost_df.where(F.col('Date') >= vm_start_date)\r\n",
							"sql_cost_df = cost_df.where(F.col('Date') == sql_start_date)"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute VM related cost"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(vm_cost_df.count())\n",
							"\n",
							"is_vm_cost = ((F.col('ResourceId').contains('/virtualMachines/')) | (F.col('ResourceId').contains('/virtualMachineScaleSets/'))) \\\n",
							"    & ((F.col('MeterSubCategory').contains('Windows')) | (F.col('ServiceInfo2').contains('Windows Server BYOL')))\n",
							"\n",
							"vm_cost_df = vm_cost_df.where(is_vm_cost)\n",
							"\n",
							"vm_columns_to_keep = ['SubscriptionId', 'SubscriptionName','Date','ResourceGroup', 'ResourceName', 'ResourceId', \n",
							"    'MeterCategory', 'MeterSubCategory', 'MeterName','UnitOfMeasure','Quantity','UnitPrice','EffectivePrice',\n",
							"    'CostInBillingCurrency', 'ServiceInfo2', 'PartNumber', 'AdditionalInfo']\n",
							"\n",
							"vm_cost_df = vm_cost_df.select(*vm_columns_to_keep)\n",
							"\n",
							"print(vm_cost_df.count())"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Fetch SQL config MeterSubCategories"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"blob_service_client = BlobServiceClient.from_connection_string(hubAutomationConnectionString)\r\n",
							"\r\n",
							"# get a reference to the blob container and file\r\n",
							"container_name = 'sql-config'\r\n",
							"blob_name = 'config.json'\r\n",
							"container_client = blob_service_client.get_container_client(container_name)\r\n",
							"blob_client = container_client.get_blob_client(blob_name)\r\n",
							"\r\n",
							"# download the blob content as a string\r\n",
							"blob_content = blob_client.download_blob().content_as_text()\r\n",
							"\r\n",
							"# parse the JSON string into a Python dictionary\r\n",
							"sql_config = json.loads(blob_content)\r\n",
							"\r\n",
							"sql_metersubcategory_array = sql_config['MeterSubCategory']\r\n",
							"print(sql_metersubcategory_array)"
						],
						"outputs": [],
						"execution_count": 15
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute SQL related cost"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sql_columns_to_keep = ['SubscriptionId', 'SubscriptionName','Date','ResourceGroup', 'ResourceName', 'ResourceId', \r\n",
							"    'MeterCategory', 'MeterSubCategory', 'MeterName','UnitOfMeasure','Quantity','UnitPrice','EffectivePrice',\r\n",
							"    'CostInBillingCurrency', 'ServiceInfo2', 'PartNumber', 'ProductName', 'AdditionalInfo']\r\n",
							"\r\n",
							"sql_cost_df = sql_cost_df.select(*sql_columns_to_keep)"
						],
						"outputs": [],
						"execution_count": 16
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(sql_cost_df.count())\r\n",
							"sql_cost_df = sql_cost_df.where(F.col('MeterSubCategory').isin(sql_metersubcategory_array))\r\n",
							"print(sql_cost_df.count())"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Write result to optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"win_output_path = 'abfss://win-activity@hubautomation.dfs.core.windows.net/usage_details/'\n",
							"sql_output_path = 'abfss://sql-activity@hubautomation.dfs.core.windows.net/usage_details/'\n",
							"\n",
							"# Write VM usage details\n",
							"print('Writing DataFrame to parquet file: ', win_output_path + 'vm_' + end_date + '.csv')\n",
							"vm_cost_df.toPandas().to_csv(win_output_path + 'vm_' + end_date + '.csv')\n",
							"\n",
							"print('Writing DataFrame to parquet file: ', win_output_path + 'vm_today.csv')\n",
							"vm_cost_df.toPandas().to_csv(win_output_path + 'vm_today.csv')\n",
							"\n",
							"# Write SQL usage details\n",
							"print('Writing DataFrame to parquet file: ', sql_output_path + 'sql_' + end_date + '.csv')\n",
							"sql_cost_df.toPandas().to_csv(sql_output_path + 'sql_' + end_date + '.csv')\n",
							"\n",
							"print('Writing DataFrame to parquet file: ', sql_output_path + 'sql_today.csv')\n",
							"sql_cost_df.toPandas().to_csv(sql_output_path + 'sql_today.csv')\n",
							"\n",
							"print('File write complete.')"
						],
						"outputs": [],
						"execution_count": 22
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Monthly Extend AI column and WBS tags')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Monthly Extend AI column and WBS tags_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "67786a6c-5389-4e35-b72c-ef4b24e89859"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Monthly Extend AI column and WBS tags_notebookSparkPoolIdRef')]",
						"name": "[parameters('Monthly Extend AI column and WBS tags_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Monthly Extend AI column and WBS tags_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"#amortizedCostPath = 'exports/monthly/ACMMonthlyAmortizedCost/'\n",
							"#actualCostPath = 'exports/monthly/ACMMonthlyActualCost/'\n",
							"toDate = '20230531'\n",
							"fromDate = '20230501'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 53
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings"
						],
						"outputs": [],
						"execution_count": 54
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath):\n",
							"    \n",
							"    print(f'Loading Source Parquet file - {path}...')\n",
							"    cost_df = pd.read_parquet(path)\n",
							"    print(f'Loading Subscription list - {subscription_path}...')\n",
							"    subscription_list = pd.read_json(subscription_path)\n",
							"    print(f'Loading SNOW application list - {appListPath}...')\n",
							"    appList = pd.read_parquet(appListPath)\n",
							"\n",
							"    #cost_df.dropna(subset=['AdditionalInfo'], inplace=True)\n",
							"    #cost_df = cost_df.head(10000)\n",
							"\n",
							"    return cost_df, subscription_list, appList"
						],
						"outputs": [],
						"execution_count": 55
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(cost_df):\n",
							"\n",
							"    # Populating the Azure Hynbrid Benefit Column\n",
							"    cost_df['Azure_Hybrid_Benefit'] = np.where(cost_df['MeterSubCategory'].str.contains(\"Windows\"), \"Not enabled\", np.where(cost_df['ServiceInfo2'] == \"Windows Server BYOL\", \"Enabled\", \"Not supported\"))\n",
							"\n",
							"    # Populating the isRIUsage Column\n",
							"    cost_df['IsRIUsage'] = np.where(cost_df['ReservationId'].isna(), \"On Demand Usage\", \"RI Usage\")\n",
							"\n",
							"    # Extend AdditionalInfo Column\n",
							"    print('Calculating Mask....')\n",
							"    mask = cost_df['AdditionalInfo'].notna()\n",
							"    cost_df.loc[mask, 'AdditionalInfo'] = cost_df.loc[mask, 'AdditionalInfo'].apply(json.loads)\n",
							"    \n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 56
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(cost_df):\n",
							"    \n",
							"    print('Expanding the AdditionalInfo column...')\n",
							"    #cost_df = pd.concat([cost_df, cost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')], axis=1)\n",
							"    AdditionalInfo_df = cost_df.pop('AdditionalInfo').apply(pd.Series).add_prefix('ai_')\n",
							"    #AdditionalInfo_df = AdditionalInfo_df[[\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]]\n",
							"    columns_to_keep = [\"ai_UsageType\", \"ai_ImageType\", \"ai_ServiceType\", \"ai_VMName\", \"ai_VMProperties\", \"ai_VCPUs\", \"ai_AHB\", \"ai_vCores\", \"ai_RINormalizationRatio\", \"ai_ConsumedQuantity\", \"ai_DatabaseName\"]\n",
							"    AdditionalInfo_df.drop(AdditionalInfo_df.columns.difference(columns_to_keep), axis=1, inplace=True)\n",
							"\n",
							"    # Manually creating the columns in the columns_to_keep array encase any columns are not present in the AdditionalInfo column.\n",
							"    # This avoids schema conflict with the usage file for other months that may have the missing columns\n",
							"    cost_df[columns_to_keep] = len(columns_to_keep) * [np.nan]\n",
							"    \n",
							"    # Updating the 'columns_to_keep' columns in cost_df with the values from AdditionalInfo_df\n",
							"    AdditionalInfo_df.dropna(inplace=True, how='all')\n",
							"    cost_df.update(AdditionalInfo_df)\n",
							"  \n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 57
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(cost_df):\n",
							"    \n",
							"    print('Populating the AHB vCPUs column...')\n",
							"    cost_df['ai_VCPUs'] = cost_df['ai_VCPUs'].fillna(0)\n",
							"    cost_df['ai_VCPUs'] = cost_df['ai_VCPUs'].astype(int)\n",
							"    cost_df['AHB_vCPUs'] = np.where(cost_df['ai_VCPUs'] == 0, 0, \n",
							"        np.where(cost_df['ai_VCPUs'] < 8, 8, \n",
							"        np.where(cost_df['ai_VCPUs'] <= 16, 16,\n",
							"        np.where(cost_df['ai_VCPUs'] == 20, 24,\n",
							"        np.where(cost_df['ai_VCPUs'] > 20, cost_df['ai_VCPUs'], 0)))))\n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 58
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(cost_df):    \n",
							"    \n",
							"    print('Populating the Instance Name column...')\n",
							"    cost_df.rename({'ai_VmName':'ai_Container_VmName'}, axis=1, inplace=True)\n",
							"    cost_df['Instance_Name'] = np.where(cost_df['ai_VMName'].isna(), cost_df['ResourceName'],\n",
							"        np.where(cost_df['ai_VMName'].notna(), cost_df['ai_VMName'], pd.NA))\n",
							"\n",
							"    cost_df['Date'] = cost_df['Date'].dt.date\n",
							"    \n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 59
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\n",
							"\n",
							"    print('Expanding the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list Tags field into their own fields...')\n",
							"\n",
							"    try:\n",
							"        subscription_tags_df = subscription_list.pop('tags').apply(pd.Series)\n",
							"    except:\n",
							"        print('Error processing the subscriptions json file!')\n",
							"\n",
							"    subscription_list['SubscriptionWBS'] = subscription_tags_df['WBS']\n",
							"    subscription_list['SubscriptionServiceNow-App'] = subscription_tags_df['ServiceNow-App']\n",
							"    \n",
							"    subscription_list.rename(columns={\"id\": \"SubscriptionId\"}, inplace=True)\n",
							"    columns_to_keep = ['SubscriptionId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\n",
							"\n",
							"    subscription_list.drop(columns=subscription_list.columns.difference(columns_to_keep), inplace=True)\n",
							"    \n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": 60
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(cost_df, subscription_list):\n",
							"\n",
							"    print('Merging the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list into the cost dataframe...')\n",
							"\n",
							"    #cost_df['SubscriptionWBS'] = subscription_list(subscription_list.index, cost_df['SubscriptionId'])\n",
							"    \n",
							"    #print(subscription_list.columns)\n",
							"    #print(subscription_list[list('SubscriptionId')])\n",
							"    #cost_df = pd.merge(left=cost_df, right=subscription_list, left_on='SubscriptionId', right_on='id', how='left')\n",
							"    print(len(cost_df))\n",
							"    print(f\"cost_df Cost total is: {cost_df['CostInBillingCurrency'].sum()}\")\n",
							"    cost_df = cost_df.merge(subscription_list, how='left', on='SubscriptionId')\n",
							"    print(f\"cost_df Cost total is: {cost_df['CostInBillingCurrency'].sum()}\")\n",
							"    print(len(cost_df))\n",
							"    #print(cost_df[cost_df['ActiveWBS'].isnull()])\n",
							"    \n",
							"    return cost_df, subscription_list\n",
							""
						],
						"outputs": [],
						"execution_count": 61
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def replace_empty_cost_fields_with_subscription_details(cost_df, subscription_list, appList):\n",
							"\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\n",
							"\n",
							"    cost_df['CostAllocationCode'].replace('', np.nan, inplace=True)\n",
							"    cost_df['CostAllocationType'].replace('', np.nan, inplace=True)\n",
							"    cost_df['ActiveWBS'] = cost_df.loc[cost_df['CostAllocationType'] == 'WBS', 'CostAllocationCode']\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] != \"WBS\") & (cost_df['CostAllocationType'] != \"APPID\") & (cost_df['CostAllocationType'] != \"CI\") & (cost_df['CostAllocationType'] != \"SubscriptionWBS\")\n",
							"    cost_df.loc[mask, ['ActiveWBSReason']] = 'Invalid CostAllocationType: not APPID, CI or WBS'\n",
							"\n",
							"    mask = (cost_df['CostAllocationCode'].str.contains('^[a-zA-Z]\\.\\S*', regex=True) == False) & (cost_df['CostAllocationType'] == 'WBS')\n",
							"    cost_df.loc[mask, 'ActiveWBS'] = cost_df.loc[mask, 'SubscriptionWBS']\n",
							"    cost_df.loc[mask, 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'Invalid CostAllocationCode WBS'\n",
							"    \n",
							"    appList = appList.astype({'u_number': 'str'})\n",
							"    cost_df['ActiveWBS'] = cost_df['ActiveWBS'].fillna(cost_df['CostAllocationCode'].map(appList.set_index('u_number')['u_operational_wbs']))\n",
							"    cost_df['ActiveWBS'] = cost_df['ActiveWBS'].fillna(cost_df['CostAllocationCode'].map(appList.set_index('name')['u_operational_wbs']))\n",
							"    cost_df['ActiveWBS'].replace('TOBESPECIFIED', np.nan, inplace=True)  \n",
							"    \n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationCode'] = np.nan\n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    cost_df.loc[cost_df['ActiveWBS'].isnull(), 'ActiveWBS'] = cost_df['SubscriptionWBS']\n",
							"    \n",
							"    cost_df.loc[cost_df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'CI')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'CI WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'APPID')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'APPID WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (cost_df['CostAllocationType'] == 'WBS')\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'WBS Cost Tag used'\n",
							"\n",
							"    mask = (cost_df['Tags'].str.contains('CostAllocationCode', case=False, na=False) == False) | (cost_df['Tags'].str.contains('CostAllocationType', case=False, na=False) == False)\n",
							"    cost_df.loc[mask, 'ActiveWBSReason'] = 'CostAllocationType or CostAllocationCode not present in Tags'\n",
							"\n",
							"    return cost_df, subscription_list"
						],
						"outputs": [],
						"execution_count": 62
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"    \n",
							"    print(f'Writing output file to: \"{destinationFilename}\"')\n",
							"    print(f'Dataframe length is: {len(cost_df)}')\n",
							"    cost_df.to_parquet(destinationFilename)\n",
							"    print('File write complete!')\n",
							"    "
						],
						"outputs": [],
						"execution_count": 63
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationcode_list(tag):\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               tag_array = tag.split('\",\"')\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    temp =  x.replace('\"','').upper()\n",
							"                    if x.replace(\"\\\"\",\"\").upper() == \"COSTALLOCATIONCODE\":\n",
							"                         return y.replace(\"\\\"\",\"\").strip('\\n').strip().upper()\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {cost_df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 64
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationtype_list(tag):\n",
							"\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               type_list = ['WBS', 'CI', 'APPID']\n",
							"               tag_array = tag.split('\",\"')\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    if x.replace('\"','').upper() == \"COSTALLOCATIONTYPE\":\n",
							"                         if y.replace('\"','').strip('\\n').strip().upper() in type_list:\n",
							"                              return y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         else:\n",
							"                              return np.nan\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {cost_df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 65
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(df):\n",
							"\n",
							"    print(\"Extracting cost Type and Code and storing in dedicated columns...\")\n",
							"\n",
							"    cost_df['CostAllocationType'] = cost_df.apply(lambda x: return_costallocationtype_list(x['Tags']), axis = 1)\n",
							"    cost_df['CostAllocationCode'] = cost_df.apply(lambda x: return_costallocationcode_list(x['Tags']), axis = 1)\n",
							"\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 66
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_ai_column(cost_df):\n",
							"\n",
							"    warnings.simplefilter(action='ignore', category=FutureWarning)\n",
							"\n",
							"    #actualCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #actualCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + actualCostPath + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #amortizedCostSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"    #amortizedCostDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + amortizedCostPath + '/' + dateRange + '/Extended_ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"\n",
							"    #cost_df = load_source(actualCostSourcefilename)\n",
							"    cost_df = populate_columns(cost_df)\n",
							"    cost_df = extend_additional_info(cost_df)\n",
							"    cost_df = AHB_column(cost_df)\n",
							"    cost_df = instance_name(cost_df)\n",
							"    \n",
							"    return cost_df\n",
							""
						],
						"outputs": [],
						"execution_count": 67
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_wbs_columns(cost_df, subscription_list):\n",
							"\n",
							"    pd.set_option('max_colwidth', 50)\n",
							"\n",
							"    #cost_data_path = 'data/2022 Actual cost (10k rows).csv'\n",
							"    #size = 100\n",
							"    #subscription_path = 'data/subscriptions.json'\n",
							"\n",
							"    #df, subscription_list, appList = load_source_files(sourceFilename, subscriptionListPath, appListPath)\n",
							"    #cost_df = shorten_df(cost_df, size)\n",
							"\n",
							"\n",
							"    #df = cost_df.copy()\n",
							"    cost_df = expand_cost_tags(cost_df)\n",
							"    #print(df[['Tags', 'CostAllocationType', 'CostAllocationCode']])\n",
							"\n",
							"\n",
							"    subscription_list = expand_subscription_tags(subscription_list)\n",
							"    #print(subscription_list)\n",
							"    cost_df, subscription_list = merge_dataframes(cost_df, subscription_list)\n",
							"    cost_df, subscription_list = replace_empty_cost_fields_with_subscription_details(cost_df, subscription_list, appList)\n",
							"\n",
							"    #print(df[['CostAllocationType', 'CostAllocationCode', 'SubscriptionWBS', 'SubscriptionServiceNow-App', 'Tags']])\n",
							"    cost_df.reset_index(drop=True, inplace=True)\n",
							"    \n",
							"    return cost_df     "
						],
						"outputs": [],
						"execution_count": 68
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(f'fromDate: {fromDate}')\n",
							"print(f'toDate: {toDate}')\n",
							"reportTypes = ['ActualCost', 'AmortizedCost']\n",
							"    \n",
							"print(f\"------ From: {fromDate}, To: {toDate} -----------\")\n",
							"\n",
							"for reportType in reportTypes:\n",
							"\n",
							"    print(f\"------ {reportType} -----------\")\n",
							"\n",
							"    sourceCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"\n",
							"    longToDate = f'{toDate[0:4]}-{toDate[4:6]}-{toDate[6:]}'\n",
							"    print(f'longToDate: {longToDate}')\n",
							"    dateRange = fromDate + '-' + toDate\n",
							"    print(f'dateRange: {dateRange}')\n",
							"\n",
							"    print(dateRange)\n",
							"    costSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"    costDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/Extended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"    if str(longToDate) < '2021-11-30':\n",
							"        print(longToDate)\n",
							"        print(f'Using default 2021-11-30 subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_2021-11-30.json'\n",
							"    else:\n",
							"        print(f'Using {longToDate} subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + longToDate + '.json'\n",
							"    appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/applications/applicationList.parquet'\n",
							"\n",
							"    cost_df, subscription_list, appList = load_source_files(costSourcefilename, subscriptionListPath, appListPath)\n",
							"    cost_df = expand_ai_column(cost_df)\n",
							"    cost_df = populate_wbs_columns(cost_df, subscription_list)\n",
							"    write_output_file(cost_df, costDestinationfilename)\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": 69
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Monthly Extend AI column and WBS tags_v2')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Monthly Extend AI column and WBS tags_v2_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "f315f77e-55c0-470d-8073-39658b59e6c6"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Monthly Extend AI column and WBS tags_v2_notebookSparkPoolIdRef')]",
						"name": "[parameters('Monthly Extend AI column and WBS tags_v2_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Monthly Extend AI column and WBS tags_v2_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Input data\n",
							"toDate = '20230531'\n",
							"fromDate = '20230501'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 71
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import pyspark.pandas as ps\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings\n",
							"\n",
							"import pyspark.sql.functions as F\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 72
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath):\r\n",
							"    \r\n",
							"    print(f'Loading Cost file list - {path}')\r\n",
							"    cost_df = spark.read.format('parquet').load(path)\r\n",
							"    print(f\"Cost file contains: {cost_df.count()} rows\")\r\n",
							"    \r\n",
							"    print(f'Loading Subscription list - {subscription_path}...')\r\n",
							"    subscription_list = spark.read.json(subscription_path)\r\n",
							"    print(f\"Subscription file contains: {subscription_list.count()} rows\")\r\n",
							"\r\n",
							"    print(f'Loading SNOW application list - {appListPath}...')\r\n",
							"    appList = spark.read.format('parquet').load(appListPath)\r\n",
							"    appList = appList.withColumn('AppID', F.col('AppID').cast(\"int\"))\r\n",
							"\r\n",
							"    print(f'App list contains: {appList.count()}')\r\n",
							"\r\n",
							"    return cost_df, subscription_list, appList"
						],
						"outputs": [],
						"execution_count": 73
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_columns(cost_df):\r\n",
							"\r\n",
							"    # Populating the Azure Hybrid Benefit Column\r\n",
							"    cost_df = cost_df.withColumn('Azure_Hybrid_Benefit', F.when(F.col('MeterSubCategory').contains('Windows'), \"Not Enabled\")\\\r\n",
							"                                                         .when(F.col('ServiceInfo2') == 'Windows Server BYOL', \"Enabled\")\\\r\n",
							"                                                         .otherwise('Not Supported'))\r\n",
							"\r\n",
							"    # Populating the isRIUsage Column\r\n",
							"    cost_df = cost_df.withColumn('IsRIUsage',\r\n",
							"                                 F.when(F.col('ReservationId').isNull(), 'On Demand Usage')\\\r\n",
							"                                  .otherwise('RI Usage'))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 74
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def extend_additional_info(cost_df):\r\n",
							"    # Extend AdditionalInfo Column\r\n",
							"    cost_df = cost_df.withColumn('AdditionalInfo', F.from_json('AdditionalInfo', 'map<string,string>', options={'inferSchema': 'true'}))\r\n",
							"\r\n",
							"    # Creating an ID column\r\n",
							"    cost_df = cost_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    # Creating a list of columns we want to keep\r\n",
							"    cols_to_keep = [\"UsageType\", \r\n",
							"                    \"ImageType\",\r\n",
							"                    \"ServiceType\",\r\n",
							"                    \"VMName\",\r\n",
							"                    \"VMApplicationName\",\r\n",
							"                    \"VMProperties\",\r\n",
							"                    \"VCPUs\",\r\n",
							"                    \"AHB\",\r\n",
							"                    \"vCores\",\r\n",
							"                    \"RINormalizationRatio\",\r\n",
							"                    \"ConsumedQuantity\",\r\n",
							"                    \"DatabaseName\"]\r\n",
							"\r\n",
							"    for col in cols_to_keep:\r\n",
							"        cost_df = cost_df.withColumn('ai_' + col, F.coalesce(F.col(f'AdditionalInfo.{col}'), F.lit(None)))\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 75
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def AHB_column(cost_df):\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ai_VCPUs', F.col('ai_VCPUs').cast('int'))\r\n",
							"    cost_df = cost_df.na.fill({'ai_VCPUs' : 0})\r\n",
							"    cost_df = cost_df.withColumn('AHB_CPUs', F.when(F.col('ai_VCPUs') == 0, 0)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') < 8, 8)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') < 16, 16)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') == 20, 24)\\\r\n",
							"                                              .when(F.col('ai_VCPUs') > 20, F.col('ai_VCPUs'))\\\r\n",
							"                                              .otherwise(0))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 76
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def instance_name(cost_df):\r\n",
							"\r\n",
							"    # cost_df = cost_df.withColumnRenamed('ai_VMName', 'ai_Container_VMName')\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Instance_Name', F.when(F.col('ai_VMName').isNull(), F.col('ResourceName'))\\\r\n",
							"                                                   .when(F.col('ai_VMName').isNotNull(), F.col('ai_VMName'))\\\r\n",
							"                                                   .otherwise(0))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('UnitPrice', F.col('UnitPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('PayGPrice', F.col('PayGPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Quantity', F.col('Quantity').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('EffectivePrice', F.col('EffectivePrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('CostInBillingCurrency', F.col('CostInBillingCurrency').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Date', F.to_date(F.col('Date'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodStartDate', F.to_date(F.col('BillingPeriodStartDate'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodEndDate', F.to_date(F.col('BillingPeriodEndDate'), 'MM/dd/yyyy'))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 77
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": true
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\r\n",
							"        \r\n",
							"    subscription_list = subscription_list.withColumnRenamed('id', 'SubId')\r\n",
							"    subscription_list = subscription_list.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    try:\r\n",
							"        subscription_list = subscription_list.withColumn('tags', F.from_json(F.col('tags')))\r\n",
							"    except:\r\n",
							"        print('Already a json file')\r\n",
							"\r\n",
							"    # Expanding the tags list into separate columns\r\n",
							"    subscription_list = subscription_list.withColumn('SubscriptionWBS', F.col('tags.WBS'))\r\n",
							"    subscription_list = subscription_list.withColumn('SubscriptionServiceNow-App', F.col('tags.ServiceNow-App'))\r\n",
							"    subscription_list = subscription_list.drop('tags')\r\n",
							"\r\n",
							"    # Dropping unnecessary columns and setting the schema\r\n",
							"    columns_to_keep = ['SubId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\r\n",
							"    subscription_list = subscription_list.select(columns_to_keep)\r\n",
							"\r\n",
							"    \r\n",
							"\r\n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": 78
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(cost_df, subscription_list):\r\n",
							"    \r\n",
							"    cost_df = cost_df.join(subscription_list, cost_df.SubscriptionId == subscription_list.SubId, how='left')\r\n",
							"    cost_df = cost_df.drop('SubId')\r\n",
							"\r\n",
							"    return cost_df, subscription_list"
						],
						"outputs": [],
						"execution_count": 79
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(cost_df):\r\n",
							"    \r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationType\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_extract(F.col('Tags'), 'CostAllocationType\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_replace(F.col('CostAllocationType'), 'CostAllocationType\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.split(F.col('CostAllocationType'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType') == \"\", None).otherwise(F.col('CostAllocationType')))\r\n",
							"\r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_extract(F.col('Tags'), 'CostAllocationCode\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_replace(F.col('CostAllocationCode'), 'CostAllocationCode\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.split(F.col('CostAllocationCode'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(F.col('CostAllocationCode') == \"\", None).otherwise(F.col('CostAllocationCode')))\r\n",
							"    \r\n",
							"    print(\"Cost Tags expansion complete\")\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 80
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def replace_empty_cost_fields_with_subscription_details(cost_df, appList):\r\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\r\n",
							"\r\n",
							"    # Apply Upper-case for all CostAllocationTypes and Codes\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.upper(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.upper(F.col('CostAllocationCode')))\r\n",
							"\r\n",
							"    # When the tag does not contain CostAllocationCode or CostAllocationType, then we fill/replace the value in ActiveWBSReason\r\n",
							"    invalidCostAllocationMask = F.col('CostAllocationCode').isNull() | F.col('CostAllocationType').isNull()\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(invalidCostAllocationMask, F.lit('CostAllocationType or CostAllocationCode not present in Tags')))\r\n",
							"\r\n",
							"    # When either value in mask appears in AcitveWBS, add invalid reason in new column\r\n",
							"    validCostAllocationType = ['WBS', 'APPID', 'CI']\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('Invalid CostAllocationType: not APPID, CI or WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # When the values in the columns below match the mask and the cost type is WBS, then:\r\n",
							"    # regex pattern states that the string should start with a case insensitive letter, followed by a dot, followed by either letters, numbers or dots\r\n",
							"    pattern = r'^[a-zA-Z]\\.[a-zA-Z0-9.]+$'\r\n",
							"    rmask = F.col('CostAllocationCode').rlike(pattern)\r\n",
							"    cost_wbs = (F.col('CostAllocationType') == 'WBS')\r\n",
							"\r\n",
							"    # Applying valid WBS' as Active WBS'\r\n",
							"    # 1. Where the CostAllocationCode follows the regex and the CostAllocationType is WBS, we apply the CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(cost_wbs & rmask, F.col('CostAllocationCode')))\r\n",
							"    # 2. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, we set the ActiveWBSReason to be \"Invalid CostAllocationCode WBS\"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(cost_wbs & ~rmask, F.lit('Invalid CostAllocationCode WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    # 3. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, the CostAllocationType is changed to \"SubscriptionWBS\"\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(cost_wbs & ~rmask, F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"\r\n",
							"    # Applying valid AppIDs as Active WBS'\r\n",
							"    # If the CostAllocationCode is empty, we fill/replace the column ActiveWBS with Operational WBS in the AppList\r\n",
							"    map_app = appList.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'OperationalWBS')\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'APPID') & (cost_df.CostAllocationCode == map_app.AppID), how='left')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.drop('OperationalWBS')\r\n",
							"\r\n",
							"    # Applying valid CIs as Active WBS'\r\n",
							"    # Same here as above, but we merge the dataframes on ApplicationNames rather than AppID\r\n",
							"    map_app = appList.select('ApplicationName', 'OperationalWBS')\r\n",
							"    # Apply join with case insensitivity\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'CI') & (cost_df.CostAllocationCode == map_app.ApplicationName_upper), how='left').drop('ApplicationName_upper')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    \r\n",
							"    # Alternative 1 remove \"AppID\" \r\n",
							"    cost_df = cost_df.drop('ApplicationName', 'OperationalWBS')\r\n",
							"\r\n",
							"    # When ActiveWBS value is string 'TOBESPECIFIED', we replace the value with None. # Why this ActiveWBS have TOBSPECIFIED value? \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.upper(F.col('ActiveWBS')) == 'TOBESPECIFIED', F.lit(None)).otherwise(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # When Subscriptions are not attached to the costs (unassigned), we fill the values with Unassigned and state the ActiveWBSReason.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned Subscription, possibly unused RI/SP')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # Now that we have filled in most places in ActiveWBS, if the rest of ActiveWBS is Null, then we apply the CostCenter WBS\r\n",
							"    # When CostAllocationType is null, we fill it with the value from SubscriptionWBS\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'APPID'), F.lit('AppID CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'CI'), F.lit('CI CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('ActiveWBS').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('CostCenter')).otherwise(F.col('ActiveWBS'))) # Cost Center is identical to SubscriptionWBS. So we can remove subscription.json.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType'))) #  Can be removed.\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBSReason').isNull() & (F.col('CostAllocationType') == 'SubscriptionWBS'), F.lit('No valid AppID, WBS or CI')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    \r\n",
							"\r\n",
							"    # When CostAllocationType is a specific string, we fill/replace the value in ActiveWBSReason \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'CI', F.lit('CI WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'APPID', F.lit('AppID WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'WBS', F.lit('WBS Cost Tag used')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.upper(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # For cases that where CostAllocationCode is empty, we will use AppID from SerivceNow and Application from Subscription.json to replace.\r\n",
							"    mask3 = (F.col('CostAllocationType').isin(['APPID']) & F.col('CostAllocationCode').isNull())\r\n",
							"    mask4 = (F.col('CostAllocationType').isin(['CI']) & F.col('CostAllocationCode').isNull())\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(mask3, F.col('AppID')) \\\r\n",
							"                                                       .when(mask4, F.col('SubscriptionServiceNow-App')) \\\r\n",
							"                                                       .otherwise(F.col('CostAllocationCode'))).drop('AppID')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 81
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_application_names(cost_df, appList):\r\n",
							"\r\n",
							"    # Masks for CI and AppID\r\n",
							"    ci_mask = F.col('CostAllocationType') == 'CI'\r\n",
							"    appid_mask = F.col('CostAllocationType') == 'APPID'\r\n",
							"\r\n",
							"    # When AppID is present, we use the application name from the Service-Now Application list\r\n",
							"    # First convert AppID to a string, then select the desired columns\r\n",
							"    map_app = appList.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'ApplicationName')\r\n",
							"\r\n",
							"    # Apply case insensitivity merge by creating upper case columns\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode_upper',F.upper(F.col('CostAllocationCode')))\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    # Merge CostAllocationCode on APPID\r\n",
							"    cost_df = cost_df.join(map_app, cost_df.CostAllocationCode_upper == map_app.AppID, how='left')\r\n",
							"\r\n",
							"    # Make copy of service now app list for second merge\r\n",
							"    map_app_copy = map_app.alias('map_app_copy').withColumnRenamed('AppID', 'NewAppID').withColumnRenamed('ApplicationName_upper', 'NewApplicationName_upper').withColumnRenamed('ApplicationName', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Merge CostAllicationCode on ApplicationName copy\r\n",
							"    cost_df = cost_df.join(map_app_copy, cost_df.CostAllocationCode_upper == map_app_copy.NewApplicationName_upper, how='left')\r\n",
							"\r\n",
							"    # Populate original AppId and ApplicationName columns from the copied columns\r\n",
							"    cost_df = cost_df.withColumn('AppID', F.when(F.col('AppID').isNull(), F.col('NewAppID')).otherwise(F.col('AppID')))\r\n",
							"    cost_df = cost_df.withColumn('ApplicationName', F.when(F.col('ApplicationName').isNull(), F.col('NewApplicationName')).otherwise(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    cost_df = cost_df.drop('CostAllocationCode_upper', 'ApplicationName_upper', 'NewAppID', 'NewApplicationName_upper', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Create Application_Name column based on Application from ServiceNow to start with.\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.col('ApplicationName'))\r\n",
							"\r\n",
							"    # Resolve CostAllocationCode and CostAllocationType typo by replacing Application_name with SubscriptionServiceNow-App value \r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when((F.col('CostAllocationType') == 'APPID') & F.col('CostAllocationCode').cast('int').isNull(),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                    .when((F.col('CostAllocationType') == 'CI') & F.col('CostAllocationCode').cast('int').isNotNull(),F.col('SubscriptionServiceNow-App')).otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when(((F.col('CostAllocationType') == \"SubscriptionWBS\") | (F.col('CostAllocationType') == \"WBS\"))&(F.col('Application_Name').isNull()),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                     .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name_upper',F.upper(F.col('Application_Name')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowAppID',F.col('AppID')).drop('AppID')\r\n",
							"\r\n",
							"    # Lookup application in ServiceNow. Those applications that can be found will be merged.\r\n",
							"    cost_df = cost_df.join(map_app,cost_df.Application_Name_upper==map_app.ServiceNowApplicationName_upper,how='left')\r\n",
							"\r\n",
							"    # Fill empty AppID with AppID from ServiceNow\r\n",
							"    cost_df = cost_df.withColumn('AppID',F.when(F.col('AppID').isNull(),F.col('ServiceNowAppID'))\\\r\n",
							"                                          .otherwise(F.col('AppID'))) \r\n",
							"\r\n",
							"    # Remove unused Columns\r\n",
							"    cost_df = cost_df.drop('Application_Name_upper','ApplicationName','ServiceNowAppID','ServiceNowApplicationName_upper','ApplicationName_upper')\r\n",
							"\r\n",
							"\r\n",
							"    # Application Name will be \"Application not defined or not found\" when SubscriptionServiceNow-App is equal to Application_name as well as AppID is empty.\r\n",
							"    # This indicates that application from subscription.json file can not be found in ServiceNow. One of Application example is DATAHUB - MARKETING AND SUPPLY, not found in ServiceNow.\r\n",
							"    cost_df = cost_df.withColumn('Application_Name', F.when((F.upper(F.col('SubscriptionServiceNow-App'))==F.upper(F.col('Application_Name'))) & (F.col('AppID').isNull()),F.lit('Application not defined or not found'))\\\r\n",
							"                                                    .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    # For anything that left ApplicationName will be \"Application not defined or not found\" and For anything that left AppID will be 0.\r\n",
							"    cost_df = cost_df.na.fill({'AppID': 0, 'Application_Name': 'Application not defined or not found'})\r\n",
							"\r\n",
							"    return cost_df\r\n",
							""
						],
						"outputs": [],
						"execution_count": 82
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_ai_column(cost_df):\r\n",
							"\r\n",
							"    warnings.simplefilter(action='ignore', category=FutureWarning)\r\n",
							"    cost_df = populate_columns(cost_df)\r\n",
							"    cost_df = extend_additional_info(cost_df)\r\n",
							"    cost_df = AHB_column(cost_df)\r\n",
							"    cost_df = instance_name(cost_df)\r\n",
							"    \r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 83
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def populate_wbs_columns(cost_df, subscription_list, appList):\r\n",
							"\r\n",
							"    cost_df = expand_cost_tags(cost_df)\r\n",
							"    subscription_list = expand_subscription_tags(subscription_list)\r\n",
							"    cost_df, subscription_list = merge_dataframes(cost_df, subscription_list)\r\n",
							"    cost_df = replace_empty_cost_fields_with_subscription_details(cost_df, appList)\r\n",
							"    print('WBS population complete. Populating application names')\r\n",
							"    cost_df = get_application_names(cost_df, appList)    \r\n",
							"    print('App-name population complete')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 84
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"\n",
							"    cost_df = cost_df.drop('id', 'AdditionalInfo') \n",
							"    print('start to write to container')\n",
							"    cost_df.write.format('parquet').mode('overwrite').option('path', destinationFilename).save()\n",
							"    print('File write complete!')"
						],
						"outputs": [],
						"execution_count": 85
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"print(f'fromDate: {fromDate}')\n",
							"print(f'toDate: {toDate}')\n",
							"reportTypes = ['ActualCost', 'AmortizedCost']\n",
							"year = toDate[:4]\n",
							"month = toDate[4:6]\n",
							"day = toDate[6:]\n",
							"\n",
							"print(f\"------ From: {fromDate}, To: {toDate} -----------\")\n",
							"\n",
							"for reportType in reportTypes:\n",
							"\n",
							"    print(f\"------ {reportType} -----------\")\n",
							"\n",
							"    sourceCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"\n",
							"    longToDate = f'{toDate[0:4]}-{toDate[4:6]}-{toDate[6:]}'\n",
							"    print(f'longToDate: {longToDate}')\n",
							"    dateRange = fromDate + '-' + toDate\n",
							"    print(f'dateRange: {dateRange}')\n",
							"\n",
							"    print(dateRange)\n",
							"    costSourcefilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"    costDestinationfilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/Extended_v2_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"    if str(longToDate) < '2021-11-30':\n",
							"        print(longToDate)\n",
							"        print(f'Using default 2021-11-30 subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_2021-11-30.json'\n",
							"    else:\n",
							"        print(f'Using {longToDate} subscription json file')\n",
							"        subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + longToDate + '.json'\n",
							"    appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/applications/ServiceNow-Application-List-Extended.parquet'\n",
							"\n",
							"    cost_df, subscription_list, appList = load_source_files(costSourcefilename, subscriptionListPath, appListPath)\n",
							"    cost_df = expand_ai_column(cost_df)\n",
							"    cost_df = populate_wbs_columns(cost_df, subscription_list, appList)\n",
							"    write_output_file(cost_df, costDestinationfilename)\n",
							"    print(' ')"
						],
						"outputs": [],
						"execution_count": 86
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/New API - Calculate Savings')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('New API - Calculate Savings_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "a4b6b6de-a3ef-49fb-8efd-50f9f22ca139"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('New API - Calculate Savings_notebookSparkPoolIdRef')]",
						"name": "[parameters('New API - Calculate Savings_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('New API - Calculate Savings_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"year = '2022'\n",
							"month = '01'\n",
							"reportType = 'ActualCost'\n",
							"dateRange = '20220101-20220131'\n",
							"path = ''\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"\n",
							"if reportType == 'ActualCost':\n",
							"    source_filename = 'abfss://usage@' + storageAccount + '.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/' + dateRange + '/ACMMonthlyActualCost_' + dateRange + '.parquet'\n",
							"elif reportType == 'AmortizedCost':\n",
							"    source_filename = 'abfss://usage@' + storageAccount + '.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/' + dateRange + '/ACMMonthlyAmortizedCost_' + dateRange + '.parquet'\n",
							"\n",
							"print(f'Loading source file... ',source_filename)\n",
							"#usage = pd.read_csv(source_filename)\n",
							"usage = pd.read_parquet(source_filename)\n",
							"\n",
							"columns_to_keep = ['UnitPrice','EffectivePrice','Quantity','TotalUsedSavings','ReservationName','ProductOrderName','Date','UnitOfMeasure','SubscriptionId','SubscriptionName','ResourceGroup','ProductName','MeterCategory','MeterName','CostInBillingCurrency','ResourceId','AdditionalInfo','ServiceInfo2','ReservationId','Term','ChargeType','PartNumber','PayGPrice','benefitId','benefitName']\n",
							"\n",
							"#usage = usage.loc[:, [columns_to_keep]]\n",
							"usage.drop(usage.columns.difference(columns_to_keep), 1, inplace=True)\n",
							"\n",
							"usage = usage[usage['ReservationName'].notna()]\n",
							"usage = usage[usage['ChargeType'] == 'Usage']\n",
							"usage['TotalUsedSavings'] = (usage['UnitPrice'] - usage['EffectivePrice']) * usage['Quantity']\n",
							"\n",
							"if reportType == 'ActualCost':\n",
							"    dest_filename = 'abfss://savings@' + storageAccount + '.dfs.core.windows.net/New-monthly/' + dateRange + '/' + dateRange + '-RI_Savings'\n",
							"elif reportType == 'AmortizedCost':\n",
							"    dest_filename = 'abfss://savings@' + storageAccount + '.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/' + dateRange + '/ACMMonthlyAmortizedCost_' + dateRange + '-RI_Savings'\n",
							"\n",
							"print(f'Writing csv savings file... ',dest_filename+'.csv')\n",
							"usage.to_csv(dest_filename+'.csv')\n",
							"print(f'Writing parquet savings file... ',dest_filename+'.parquet')\n",
							"usage.to_parquet(dest_filename+'.parquet')"
						],
						"outputs": [],
						"execution_count": 28
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Populate Cost Code and Cost Type fields')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse/Keep"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Populate Cost Code and Cost Type fields_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 4,
					"runAsWorkspaceSystemIdentity": true,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "4",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "5fb1e517-48b6-4232-861d-379b8cb17b83"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Populate Cost Code and Cost Type fields_notebookSparkPoolIdRef')]",
						"name": "[parameters('Populate Cost Code and Cost Type fields_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Populate Cost Code and Cost Type fields_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"reportType = 'ActualCost'\n",
							"#reportType = 'AmortizedCost'\n",
							"sourceCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"destinationPath = 'benchmark'\n",
							"container = 'usage'\n",
							"year = '2023'\n",
							"month = '05'\n",
							"storageAccount = 's037costmgmt'\n",
							""
						],
						"outputs": [],
						"execution_count": 47
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import numpy as np\n",
							"import calendar\n",
							"from datetime import datetime"
						],
						"outputs": [],
						"execution_count": 48
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_source_files(path, subscription_path, appListPath):\n",
							"    \n",
							"    print(f'Loading Source Parquet file - {path}...')\n",
							"    orig_df = pd.read_parquet(path)\n",
							"    print(f'Loading Subscription list - {subscription_path}...')\n",
							"    subscription_list = pd.read_json(subscription_path)\n",
							"    print(f'Loading SNOW application list - {appListPath}...')\n",
							"    appList = pd.read_parquet(appListPath)\n",
							"\n",
							"    return orig_df, subscription_list, appList\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": 49
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def shorten_df(orig_df, size):\n",
							"\n",
							"    if size > 0:\n",
							"        orig_df = orig_df.head(size)\n",
							"        return orig_df\n",
							"    else:\n",
							"        return orig_df\n",
							""
						],
						"outputs": [],
						"execution_count": 50
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_subscription_tags(subscription_list):\n",
							"\n",
							"    print('Expanding the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list Tags field into their own fields...')\n",
							"\n",
							"    try:\n",
							"        print('Here3')\n",
							"        subscription_tags_df = subscription_list.pop('tags').apply(pd.Series)\n",
							"    except:\n",
							"        print('Error processing the subscriptions json file!')\n",
							"\n",
							"    subscription_list['SubscriptionWBS'] = subscription_tags_df['WBS']\n",
							"    subscription_list['SubscriptionServiceNow-App'] = subscription_tags_df['ServiceNow-App']\n",
							"    \n",
							"    subscription_list.rename(columns={\"id\": \"SubscriptionId\"}, inplace=True)\n",
							"    columns_to_keep = ['SubscriptionId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\n",
							"\n",
							"    print(subscription_list.columns)\n",
							"    subscription_list.drop(columns=subscription_list.columns.difference(columns_to_keep), inplace=True)\n",
							"    print(subscription_list.columns)\n",
							"    \n",
							"    return subscription_list"
						],
						"outputs": [],
						"execution_count": 51
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_dataframes(df, subscription_list):\n",
							"\n",
							"    print('Merging the SubscriptionWBS and SubscriptionServiceNow-App fields from the subscription list into the cost dataframe...')\n",
							"\n",
							"    #df['SubscriptionWBS'] = subscription_list(subscription_list.index, df['SubscriptionId'])\n",
							"    \n",
							"    #print(subscription_list.columns)\n",
							"    #print(subscription_list[list('SubscriptionId')])\n",
							"    #df = pd.merge(left=df, right=subscription_list, left_on='SubscriptionId', right_on='id', how='left')\n",
							"    print(len(df))\n",
							"    print(f\"df Cost total is: {df['CostInBillingCurrency'].sum()}\")\n",
							"    df = df.merge(subscription_list, how='left', on='SubscriptionId')\n",
							"    print(f\"df Cost total is: {df['CostInBillingCurrency'].sum()}\")\n",
							"    print(len(df))\n",
							"    #print(df[df['ActiveWBS'].isnull()])\n",
							"    \n",
							"    return df, subscription_list\n",
							""
						],
						"outputs": [],
						"execution_count": 52
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"\n",
							"def replace_empty_cost_fields_with_subscription_details(df, subscription_list, appList):\n",
							"\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\n",
							"\n",
							"    df['CostAllocationCode'].replace('', np.nan, inplace=True)\n",
							"    df['CostAllocationType'].replace('', np.nan, inplace=True)\n",
							"    df['ActiveWBS'] = df.loc[df['CostAllocationType'] == 'WBS', 'CostAllocationCode']\n",
							"\n",
							"    mask = (df['CostAllocationType'] != \"WBS\") & (df['CostAllocationType'] != \"APPID\") & (df['CostAllocationType'] != \"CI\") & (df['CostAllocationType'] != \"SubscriptionWBS\")\n",
							"    df.loc[mask, ['ActiveWBSReason']] = 'Invalid CostAllocationType: not APPID, CI or WBS'\n",
							"\n",
							"    mask = (df['CostAllocationCode'].str.contains('^[a-zA-Z]\\.\\S*', regex=True) == False) & (df['CostAllocationType'] == 'WBS')\n",
							"    df.loc[mask, 'ActiveWBS'] = df.loc[mask, 'SubscriptionWBS']\n",
							"    df.loc[mask, 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'Invalid CostAllocationCode WBS'\n",
							"    \n",
							"    df['ActiveWBS'] = df['ActiveWBS'].fillna(df['CostAllocationCode'].map(appList.set_index('u_number')['u_operational_wbs']))\n",
							"    df['ActiveWBS'] = df['ActiveWBS'].fillna(df['CostAllocationCode'].map(appList.set_index('name')['u_operational_wbs']))\n",
							"    df['ActiveWBS'].replace('TOBESPECIFIED', np.nan, inplace=True)  \n",
							"    \n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationCode'] = np.nan\n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"    df.loc[df['ActiveWBS'].isnull(), 'ActiveWBS'] = df['SubscriptionWBS']\n",
							"    \n",
							"    df.loc[df['CostAllocationType'].isnull(), 'CostAllocationType'] = 'SubscriptionWBS'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'CI')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'CI WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'APPID')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'APPID WBS Lookup from SNOW'\n",
							"\n",
							"    mask = (df['CostAllocationType'] == 'WBS')\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'WBS Cost Tag used'\n",
							"\n",
							"    mask = (df['Tags'].str.contains('CostAllocationCode', case=False, na=False) == False) | (df['Tags'].str.contains('CostAllocationType', case=False, na=False) == False)\n",
							"    df.loc[mask, 'ActiveWBSReason'] = 'CostAllocationType or CostAllocationCode not present in Tags'\n",
							"\n",
							"    return df, subscription_list"
						],
						"outputs": [],
						"execution_count": 53
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(df, destinationFilename):\n",
							"    \n",
							"    print(f'Writing output file to: \"{destinationFilename}\"')\n",
							"    df.to_parquet(destinationFilename)\n",
							"    print('File write complete!')\n",
							"    "
						],
						"outputs": [],
						"execution_count": 54
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationcode_list(tag):\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               tag_array = tag.split('\",\"')\n",
							"               #print(f\"Tag array is: {tag_array}\")\n",
							"               #print(type(tag_array))\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    #print(f'x is: {x}')\n",
							"                    #print(f'y is: {y}')\n",
							"                    temp =  x.replace('\"','').upper()\n",
							"                    #print(f'if test: {temp}')\n",
							"                    if x.replace(\"\\\"\",\"\").upper() == \"COSTALLOCATIONCODE\":\n",
							"                         #print(\"here1\")\n",
							"                         #print(y.replace(\"\\\"\",\"\").strip('\\n').strip().upper())\n",
							"                         return y.replace(\"\\\"\",\"\").strip('\\n').strip().upper()\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 55
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def return_costallocationtype_list(tag):\n",
							"\n",
							"    \n",
							"     if pd.isnull(tag):\n",
							"          #print(\"Here2 - null\")\n",
							"          return np.nan\n",
							"     else:\n",
							"          try:\n",
							"               type_list = ['WBS', 'CI', 'APPID']\n",
							"               tag_array = tag.split('\",\"')\n",
							"               #print(f\"Tag array is: {tag_array}\")\n",
							"               #print(type(tag_array))\n",
							"               for pair in tag_array:\n",
							"                    x,y = pair.split('\": \"')\n",
							"                    #print(f'x is: {x}')\n",
							"                    #print(f'y is: {y}')\n",
							"                    #temp =  x.replace('\"','').upper()\n",
							"                    #print(f'if test: {temp}')\n",
							"                    #if temp == 'C.BAX.20.021':\n",
							"                              #print(\"here1\")\n",
							"                              #print(temp)\n",
							"                              #print(tag_array)\n",
							"                    if x.replace('\"','').upper() == \"COSTALLOCATIONTYPE\":\n",
							"                         #temp2 = y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         #print(temp2)\n",
							"                         if y.replace('\"','').strip('\\n').strip().upper() in type_list:\n",
							"                              return y.replace('\"','').strip('\\n').strip().upper()\n",
							"                         else:\n",
							"                              #print(\"here2\")\n",
							"                              #print(temp2)\n",
							"                              #print(tag_array)\n",
							"                              return np.nan\n",
							"          except:\n",
							"               return \"ERROR\"\n",
							"               #print(f\"Isnull = false, Index is {index}, Tags is {df['Tags'][index]}\")"
						],
						"outputs": [],
						"execution_count": 56
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(df):\n",
							"\n",
							"    print(\"Extracting cost Type and Code and storing in dedicated columns...\")\n",
							"\n",
							"    df['CostAllocationType'] = df.apply(lambda x: return_costallocationtype_list(x['Tags']), axis = 1)\n",
							"    df['CostAllocationCode'] = df.apply(lambda x: return_costallocationcode_list(x['Tags']), axis = 1)\n",
							"\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 57
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#months = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12']\n",
							"months = ['01']\n",
							"#years = ['2021', '2022']\n",
							"years = ['2023']\n",
							"#months = ['05']\n",
							"#reportTypes = ['ActualCost', 'AmortizedCost']\n",
							"reportTypes = ['ActualCost']\n",
							"\n",
							"for reportType in reportTypes:\n",
							"\n",
							"    print(f\"------ {reportType} -----------\")\n",
							"\n",
							"    for year in years:\n",
							"\n",
							"        print(f\"------ Year: {year} -----------\")\n",
							"\n",
							"        for month in months:\n",
							"\n",
							"            print(f\"------ Month: {month} -----------\")\n",
							"\n",
							"            fromDate = f'{year}{month}01'\n",
							"\n",
							"            sourceCostPath = 'exports/monthly/ACMMonthly' + reportType + '/'\n",
							"\n",
							"            month_range = calendar.monthrange(datetime(int(year), int(month), 1).year, datetime(int(year), int(month), 1).month)\n",
							"            end_of_month_day = month_range[1]\n",
							"            toDate = f'{year}{month}{end_of_month_day}'\n",
							"            longToDate = f'{year}-{month}-{end_of_month_day}'\n",
							"\n",
							"            dateRange = fromDate + '-' + toDate\n",
							"\n",
							"            print(dateRange)\n",
							"            #sourceFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            sourceFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + sourceCostPath + dateRange + '/Extended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            #destinationFilename = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationPath + '/' + reportType + '/CostTagsExtended_ACMMonthly' + reportType + '_' + dateRange + '.parquet'\n",
							"            destinationFilename = sourceFilename\n",
							"            #subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationPath + '/subscriptions.json'\n",
							"            if str(longToDate) < '2021-11-30':\n",
							"                print(longToDate)\n",
							"                print('here1')\n",
							"                subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_2021-11-30.json'\n",
							"            else:\n",
							"                print('here2')\n",
							"                subscriptionListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/subscriptions/subscriptions_' + longToDate + '.json'\n",
							"            appListPath = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + destinationPath + '/applicationList.parquet'\n",
							"\n",
							"            pd.set_option('max_colwidth', 50)\n",
							"\n",
							"            #cost_data_path = 'data/2022 Actual cost (10k rows).csv'\n",
							"            #size = 100\n",
							"            #subscription_path = 'data/subscriptions.json'\n",
							"\n",
							"            df, subscription_list, appList = load_source_files(sourceFilename, subscriptionListPath, appListPath)\n",
							"            #orig_df = shorten_df(orig_df, size)\n",
							"\n",
							"\n",
							"            #df = orig_df.copy()\n",
							"            df = expand_cost_tags(df)\n",
							"            #print(df[['Tags', 'CostAllocationType', 'CostAllocationCode']])\n",
							"\n",
							"\n",
							"            subscription_list = expand_subscription_tags(subscription_list)\n",
							"            #print(subscription_list)\n",
							"            df, subscription_list = merge_dataframes(df, subscription_list)\n",
							"            df, subscription_list = replace_empty_cost_fields_with_subscription_details(df, subscription_list, appList)\n",
							"\n",
							"            #print(df[['CostAllocationType', 'CostAllocationCode', 'SubscriptionWBS', 'SubscriptionServiceNow-App', 'Tags']])\n",
							"            df.reset_index(drop=True, inplace=True)\n",
							"            write_output_file(df, destinationFilename)"
						],
						"outputs": [],
						"execution_count": 58
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Prod_AzureAD_BusinessAreaLevel')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "3c68acb7-bc4d-4a61-b64d-a6287c68b2e5"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolIdRef')]",
						"name": "[parameters('Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Prod_AzureAD_BusinessAreaLevel_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"import pandas as pd \r\n",
							"import pyspark.pandas as ps\r\n",
							"from pyspark.sql import functions as F\r\n",
							"from pyspark.sql import SparkSession"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df_BusinessAreaLevel = spark.read.format('delta').load(f'abfss://usage@{storageAccount}.dfs.core.windows.net/AzureAD_BusinessAreaLevel/usersWithBusinessAreaSnapshot_v2.delta').toPandas()\r\n",
							""
						],
						"outputs": [],
						"execution_count": 19
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df_BusinessAreaLevel['userName'] = df_BusinessAreaLevel['userName'].str.lower()"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df_BusinessAreaLevel)"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"optimized_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/AzureAD_BusinessAreaLevel/AzureAD_BusinessAreaLevel.parquet\" \r\n",
							"#df.repartition(1).write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(optimized_path)\r\n",
							"spark.createDataFrame(df_BusinessAreaLevel).write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Clear cache in Spark session"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"currentSparkSession = SparkSession.builder.getOrCreate()\r\n",
							"spark.catalog.clearCache()"
						],
						"outputs": [],
						"execution_count": 2
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Prod_Calendar')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "create a calendar table and store in SQL warehouse",
				"folder": {
					"name": "NotebookInProduction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Prod_Calendar_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "86e0d14b-b922-421c-b6ea-ab2ee6210cf1"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Prod_Calendar_notebookSparkPoolIdRef')]",
						"name": "[parameters('Prod_Calendar_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Prod_Calendar_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\r\n",
							"from datetime import datetime as dt"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"source": [
							"def create_date_table(start='2000-01-01', end='2050-12-31'):\r\n",
							"    df = pd.DataFrame({'Date': pd.date_range(start, end)})\r\n",
							"    df['Day'] = df['Date'].dt.day\r\n",
							"    df['Month'] = df['Date'].dt.month\r\n",
							"    df['Quarter'] = df['Date'].dt.quarter\r\n",
							"    df['Year'] = df['Date'].dt.year\r\n",
							"    df['DayOfWeek'] = df['Date'].dt.dayofweek #Monday=0, Sunday=6\r\n",
							"    df['DayName'] = df['Date'].dt.day_name()\r\n",
							"    df['MonthName'] = df['Date'].dt.month_name()\r\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"calendar = create_date_table()"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#calendar.head()"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Save data in storage account"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define path to save the data\r\n",
							"path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/Calendar/delta/Calendar.delta\" \r\n",
							"\r\n",
							"#Save the data\r\n",
							"spark.createDataFrame(calendar).write.format('delta').mode('overwrite').option('overwriteSchema', 'True').save(path)"
						],
						"outputs": [],
						"execution_count": 16
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Prod_Extended_Amortized_Cost-Oneyear')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\n",
				"folder": {
					"name": "NotebookInProduction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "178a4842-4de1-4880-b84e-9c1d23f3aae9"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolIdRef')]",
						"name": "[parameters('Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Prod_Extended_Amortized_Cost-Oneyear_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"This notebook is used to extract all extended amortized cost files from storage account as dataframes and append them into one single dataframe.\r\n",
							"\r\n",
							"The purpose is to make PBI desktop convenient and faster to load the data. \r\n",
							"\r\n",
							"The appended data is considered as a large dataset with more than a hundred million rows and multiple columns. \r\n",
							"\r\n",
							"To reduce the size of the data, a years period with all columns has been selected. This has been verified and confirmed by the end-users (WBS owners).\r\n",
							""
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Import Libraries"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd \r\n",
							"import pyspark.pandas as ps\r\n",
							"from pyspark.sql import SparkSession\r\n",
							"from pyspark.sql import functions as F\r\n",
							"from pyspark.sql.functions import col\r\n",
							"from pyspark.sql.types import StructType\r\n",
							"from pyspark.sql.functions import lit\r\n",
							"from pyspark.sql.functions import year, month\r\n",
							"from notebookutils import mssparkutils\r\n",
							"from datetime import datetime, timedelta\r\n",
							"from pyspark.sql.functions import when\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Load the data"
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Collect the data schema"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Identify a years period\r\n",
							"date_one_year_ago = datetime.now().date()-timedelta(days=365)\r\n",
							"\r\n",
							"# Define a path for the data with random period\r\n",
							"path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/20230501-20230531/Extended_v3_ACMMonthlyAmortizedCost_20230501-20230531.parquet\"\r\n",
							"\r\n",
							"# Load the data schema and add a new column for Report Date\r\n",
							"df_schema_extended = spark.read.format('parquet').load(path)\r\n",
							"\r\n",
							"columns_to_keep = [\r\n",
							"    'Date',\r\n",
							"    'UnitPrice',\r\n",
							"    'Quantity',\r\n",
							"    'CostInBillingCurrency',\r\n",
							"    'EffectivePrice',\r\n",
							"    'ActiveWBS',\r\n",
							"    'ActiveWBSReason',\r\n",
							"    'AppID',\r\n",
							"    'Application_Name',\r\n",
							"    'ChargeType',\r\n",
							"    'ConsumedService',\r\n",
							"    'MeterSubCategory',\r\n",
							"    'PricingModel',\r\n",
							"    'CostAllocationCode',\r\n",
							"    'CostAllocationType',\r\n",
							"    'CostAllocationCodeTag',\r\n",
							"    'CostAllocationTypeTag',\r\n",
							"    'ResourceLocation',\r\n",
							"    'ServiceFamily',\r\n",
							"    'SubscriptionId',\r\n",
							"    'MeterCategory',\r\n",
							"    'MeterName',\r\n",
							"    'MeterRegion',\r\n",
							"    'SubscriptionName',\r\n",
							"    'SubscriptionWBS',\r\n",
							"    'UnitOfMeasure',\r\n",
							"    'ResourceGroup',\r\n",
							"    'ResourceId',\r\n",
							"    'ResourceName',\r\n",
							"    'ReservationName',\r\n",
							"    'ai_VCPUs',\r\n",
							"    'ai_ServiceType',\r\n",
							"    'WindowsAHB',\r\n",
							"    'SQLAHB',\r\n",
							"    'WindowsAHB_VCPUS',\r\n",
							"    'SQLAHB_VCPUS',\r\n",
							"    'ServiceModel',\r\n",
							"    'benefitName',\r\n",
							"    'SPStatus',\r\n",
							"    'NormalizedP3YSPUnitPrice',\r\n",
							"    'LicensePayGUnitPrice'\r\n",
							"]\r\n",
							"\r\n",
							"df_schema_extended = df_schema_extended.select(*columns_to_keep) \r\n",
							"\r\n",
							"df_schema_extended = df_schema_extended.withColumn('Report_Date',lit('') )\r\n",
							"df_schema_extended = df_schema_extended.withColumn('Report_Date_Partition',lit('') )"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load all ACMMonthlyAmortizedCost data and append to one dataframe."
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Create a SparkSession\r\n",
							"spark = SparkSession.builder.getOrCreate()\r\n",
							"\r\n",
							"# Define an empty schema\r\n",
							"schema = df_schema_extended.schema\r\n",
							"\r\n",
							"# Create an empty DataFrame with the specified schema\r\n",
							"df = spark.createDataFrame([], schema)\r\n",
							"\r\n",
							"# Define the root path\r\n",
							"root_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost\"\r\n",
							"\r\n",
							"# Collect all the folders under this root path\r\n",
							"folders = mssparkutils.fs.ls(root_path)\r\n",
							"\r\n",
							"\r\n",
							"for folder in folders:\r\n",
							"    # Collect all file path from the folder\r\n",
							"        datetime_str = folder.name[0:8]\r\n",
							"        year = int(datetime_str[0:4])\r\n",
							"        month = int(datetime_str[4:6])\r\n",
							"        day = int(datetime_str[6:8])\r\n",
							"        timestamp = pd.Timestamp(year=year, month=month, day=day).date()\r\n",
							"        if timestamp > date_one_year_ago:\r\n",
							"            file_paths = mssparkutils.fs.ls(root_path +'/'+ str(folder.name))\r\n",
							"            for file_path in file_paths:\r\n",
							"                # Focus on parquet file not csv file\r\n",
							"                if 'Extended_v3' in file_path.name:\r\n",
							"                    try:\r\n",
							"                        # Add a Report date column in the dataframe\r\n",
							"                        date = pd.to_datetime(folder.path.split('/')[-1].split('-')[0],format=\"%Y/%m/%d\")\r\n",
							"                        df_temp = spark.read.format('parquet').load(file_path.path).select(*columns_to_keep) \r\n",
							"                        print(date)\r\n",
							"                        print(\"Filepath:\", file_path.path)\r\n",
							"                        df_temp = df_temp.withColumn('Report_Date', lit(date))\r\n",
							"                        df_temp = df_temp.withColumn('Report_Date_Partition', lit(date))\r\n",
							"                        # Append the dataframe\r\n",
							"                        df = df.union(df_temp)\r\n",
							"                    except Exception as e:\r\n",
							"                        # Exclude the extended files that are developed by David.\r\n",
							"                        print(\"Those files will not be read\",file_path.path)\r\n",
							"                        print(df_temp.columns)\r\n",
							"                        print(df)\r\n",
							"                        print(len(df_temp.columns),len(df.columns))\r\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Display the dataframe"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Change the data type of the 'Report_Date' column to Datetime\r\n",
							"df = df.withColumn(\"Report_Date\", col(\"Report_Date\").cast(\"timestamp\"))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Change the column name\r\n",
							"df = df.withColumnRenamed(\"Application_Name\", \"ApplicationName\")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Save it to optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define optimized path to save the data\r\n",
							"optimized_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_OneYear.parquet\" \r\n",
							"\r\n",
							"# Save the data with partitioned by Report date\r\n",
							"df.write.format('parquet').mode('overwrite').partitionBy('Report_Date_Partition').option('overwriteSchema', 'true').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Prod_Extended_Amortized_Cost-Threeyears')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "\n",
				"folder": {
					"name": "NotebookInProduction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "fc52e4bd-3998-488c-9a0f-53bd61d1b6a3"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolIdRef')]",
						"name": "[parameters('Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Prod_Extended_Amortized_Cost-Threeyears_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"This notebook is used to extract all extended amortized cost files from storage account as dataframes and append them into one single dataframe.\r\n",
							"\r\n",
							"The purpose is to make PBI desktop convenient and faster to load the data. \r\n",
							"\r\n",
							"The appended data is considered as a large dataset with more than a hundred million rows and multiple columns. \r\n",
							"\r\n",
							"To reduce the size of the data, it has been aggregated to limited columns and a three years period have been selected. This has been verified and confirmed by the end-users (WBS owners).\r\n",
							"\r\n",
							""
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Import Libraries"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd \r\n",
							"import pyspark.pandas as ps\r\n",
							"from pyspark.sql import SparkSession\r\n",
							"from pyspark.sql import functions as F\r\n",
							"from pyspark.sql.functions import col\r\n",
							"from pyspark.sql.types import StructType\r\n",
							"from pyspark.sql.functions import lit\r\n",
							"from pyspark.sql.functions import year, month\r\n",
							"from notebookutils import mssparkutils\r\n",
							"from datetime import datetime, timedelta\r\n",
							"from pyspark.sql.functions import when\r\n",
							""
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Load the data"
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Collect the data schema"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Identify a three years period\r\n",
							"date_three_years_ago = datetime.now().date()-timedelta(days=1095)\r\n",
							"\r\n",
							"# Define a path for the data with random period\r\n",
							"path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/20210101-20210131/Extended_v3_ACMMonthlyAmortizedCost_20210101-20210131.parquet\"\r\n",
							"\r\n",
							"# Load the data schema for later use\r\n",
							"df_schema_extended = spark.read.format('parquet').load(path)\r\n",
							"\r\n",
							"# Add new empty date column for later use\r\n",
							"df_schema_extended = df_schema_extended.withColumn('Report_Date',lit('') )\r\n",
							"df_schema_extended = df_schema_extended.withColumn('Report_Date_Partition',lit('') )"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load all ACMMonthlyActualCost data and append to one dataframe."
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Create a SparkSession\r\n",
							"spark = SparkSession.builder.getOrCreate()\r\n",
							"\r\n",
							"# Define an empty schema\r\n",
							"schema = df_schema_extended.schema\r\n",
							"\r\n",
							"# Create an empty DataFrame with the specified schema\r\n",
							"df = spark.createDataFrame([], schema)\r\n",
							"\r\n",
							"# Define the root path\r\n",
							"root_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost\"\r\n",
							"\r\n",
							"# Collect all the folders under this root path\r\n",
							"folders = mssparkutils.fs.ls(root_path)\r\n",
							"\r\n",
							"\r\n",
							"for folder in folders:\r\n",
							"    # Collect all file path from the folder\r\n",
							"        datetime_str = folder.name[0:8]\r\n",
							"        datetime_year = int(datetime_str[0:4])\r\n",
							"        datetime_month = int(datetime_str[4:6])\r\n",
							"        datetime_day = int(datetime_str[6:8])\r\n",
							"        timestamp = pd.Timestamp(year=datetime_year, month=datetime_month, day=datetime_day).date()\r\n",
							"        if timestamp > date_three_years_ago:           \r\n",
							"            file_paths = mssparkutils.fs.ls(root_path +'/'+ str(folder.name))\r\n",
							"            for file_path in file_paths:\r\n",
							"                # Focus on parquet file not csv file\r\n",
							"                if 'Extended_v3' in file_path.name:\r\n",
							"                    try:\r\n",
							"                        # Add a Report date column in the dataframe\r\n",
							"                        date = pd.to_datetime(folder.path.split('/')[-1].split('-')[0],format=\"%Y/%m/%d\")\r\n",
							"                        df_temp = spark.read.format('parquet').load(file_path.path)\r\n",
							"                        print(date)\r\n",
							"                        df_temp = df_temp.withColumn('Report_Date', lit(date))\r\n",
							"                        df_temp = df_temp.withColumn('Report_Date_Partition', lit(date))\r\n",
							"                        # Append the dataframe\r\n",
							"                        df = df.union(df_temp)\r\n",
							"                    except Exception as e:\r\n",
							"                        # Exclude the extended files that are developed by David.\r\n",
							"                        print(\"Those files will not be read\",file_path.path)\r\n",
							"                        print(df_temp.columns)\r\n",
							"                        print(df)\r\n",
							"                        print(len(df_temp.columns),len(df.columns))"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Display the dataframe"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Change the column name\r\n",
							"df = df.withColumnRenamed(\"Application_Name\", \"ApplicationName\")"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Aggregate the data "
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"selected_cols = [\r\n",
							"    'SubscriptionId',\r\n",
							"    'ApplicationName',\r\n",
							"    'SubscriptionName',\r\n",
							"    'CostCenter',\r\n",
							"    'ResourceGroup',\r\n",
							"    'ResourceLocation',\r\n",
							"    'ResourceName',\r\n",
							"    'ResourceId',\r\n",
							"    'MeterName',\r\n",
							"    'MeterCategory',\r\n",
							"    'MeterSubCategory',\r\n",
							"    'Report_Date',\r\n",
							"    'Report_Date_Partition',\r\n",
							"    'ActiveWBS',\r\n",
							"    'ActiveWBSReason',\r\n",
							"    'CostAllocationType',\r\n",
							"    'AppID',\r\n",
							"    'ServiceModel',\r\n",
							"    'PricingModel',\r\n",
							"    'UnitPrice',\r\n",
							"    'EffectivePrice',\r\n",
							"    'ChargeType',\r\n",
							"    'benefitName',\r\n",
							"    'SPStatus',\r\n",
							"    'NormalizedP3YSPUnitPrice',\r\n",
							"    'LicensePayGUnitPrice',\r\n",
							"    'ai_VCPUs',\r\n",
							"    'Date'\r\n",
							"]"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df_agg = df \\\r\n",
							"    .groupBy(*selected_cols) \\\r\n",
							"    .agg(F.sum('Quantity').alias('TotalQuantity'),F.sum('CostInBillingCurrency').alias('CostInKroner'))"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Change the data type of the 'Report_Date_Partition' column to Datetime\r\n",
							"df_agg = df_agg.withColumn(\"Report_Date_Partition\", col(\"Report_Date_Partition\").cast(\"timestamp\"))"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Split the date column into year and month columns for partition purpose\r\n",
							"df_agg = df_agg.withColumn(\"year_partition\", year(df_agg[\"Report_Date_Partition\"]))\r\n",
							"df_agg = df_agg.withColumn(\"month_partition\", month(df_agg[\"Report_Date_Partition\"]))"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Display aggregated data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Change the data type of the 'Report_Date' column to Datetime\r\n",
							"df_agg = df_agg.withColumn(\"Report_Date\", col(\"Report_Date\").cast(\"timestamp\"))"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Select the columns needed for visualization\r\n",
							"new_cols = [\r\n",
							"    'TotalQuantity',\r\n",
							"    'CostInKroner',\r\n",
							"    'month_partition',\r\n",
							"    'year_partition'\r\n",
							"]\r\n",
							"\r\n",
							"selected_cols.remove('Report_Date_Partition')\r\n",
							"\r\n",
							"selected_cols = selected_cols + new_cols"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df_agg = df_agg.select(*selected_cols)"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Save in optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define optimized path to save the data\r\n",
							"optimized_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_Threeyears.parquet\" \r\n",
							"\r\n",
							"# Save the data with partitioned by Month and Year.\r\n",
							"df_agg.write.format('parquet').mode('overwrite').partitionBy('year_partition','month_partition').option('overwriteSchema', 'true').save(optimized_path)\r\n",
							"\r\n",
							"# Save the data with no partition.\r\n",
							"#df_agg.write.format('parquet').mode('overwrite').partitionBy('Report_date).option('overwriteSchema', 'true').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Clear cache in Spark session"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"currentSparkSession = SparkSession.builder.getOrCreate()\r\n",
							"currentSparkSession.catalog.clearCache()"
						],
						"outputs": [],
						"execution_count": 14
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Prod_import_most_recent')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Prod_import_most_recent_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "0cfa6f9e-4f52-4de9-943a-5ef419868042"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Prod_import_most_recent_notebookSparkPoolIdRef')]",
						"name": "[parameters('Prod_import_most_recent_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Prod_import_most_recent_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import re\r\n",
							"from notebookutils import mssparkutils\r\n",
							"from datetime import datetime\r\n",
							"\r\n",
							"\r\n",
							"#root_folder = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/subscriptions\"\r\n",
							"#file_name = \"subscriptions_\"\r\n",
							"#file_type = 'json'\r\n",
							"def most_recent(root_folder, file_name,file_type):\r\n",
							"    file_paths = [str(path) for path in mssparkutils.fs.ls(root_folder)]\r\n",
							"    filtered_paths = [path for path in file_paths if file_name in path]\r\n",
							"    years = [re.search('\\d{4}', str(x).split('_')[1]).group(0) for x in filtered_paths]\r\n",
							"\r\n",
							"    for year in years[::-1]:\r\n",
							"        months = [re.search('\\d{2}', str(x).split('-')[1]).group(0) for x in filtered_paths]\r\n",
							"                 \r\n",
							"        for month in months[::-1]:\r\n",
							"            days = [re.search('\\d{2}', str(x).split('-')[2]).group(0) for x in filtered_paths]\r\n",
							"\r\n",
							"            for day in days[::-1]:\r\n",
							"                folder_path = root_folder + '/' + file_name + year + '-' + month + '-' + day+'.'+ file_type\r\n",
							"\r\n",
							"                return folder_path\r\n",
							"                try:\r\n",
							"                    match = [x[1] for x in filtered_paths if x[1].startswith(file_name)][0]\r\n",
							"                    return(folder_path + match)\r\n",
							"                except:\r\n",
							"                    continue\r\n",
							"                    \r\n",
							"    print('Unable to find ', file_name,' in ', root_folder)\r\n",
							"#most_recent(root_folder,file_name)"
						],
						"outputs": [],
						"execution_count": 82
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/RI VM Savings')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('RI VM Savings_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "f250ff56-133e-4d13-9057-85e2cebfb1ec"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('RI VM Savings_notebookSparkPoolIdRef')]",
						"name": "[parameters('RI VM Savings_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('RI VM Savings_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"start_date = '2022-06-01'\n",
							"end_date = '2022-06-30'\n",
							"Year = '2022'\n",
							"Month = '06'\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 20
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import numpy as np\n",
							"import pyarrow as pa\n",
							"import json\n",
							"\n",
							"source_usage_filename = 'abfss://usage@' + storageAccount + '.dfs.core.windows.net/monthly/' + Year + '/' + Month + '/' + start_date + '_' + end_date + '-cleaned.parquet'\n",
							"\n",
							"reservation_charges_source_file = 'abfss://reservations@' + storageAccount + '.dfs.core.windows.net/' + Year + '/' + Month + '/reservation-charges.parquet'\n",
							"\n",
							"pricelist_file = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/pricesheet-LATEST.parquet'\n",
							"\n",
							"saving_file_parquet = 'abfss://savings@' + storageAccount + '.dfs.core.windows.net/monthly/' + Year + '/' + Month + '/' + start_date + '_' + end_date + '-RI-VM.parquet'\n",
							"saving_file_csv = 'abfss://savings@' + storageAccount + '.dfs.core.windows.net/monthly/' + Year + '/' + Month + '/' + start_date + '_' + end_date + '-RI-VM.csv'\n",
							"\n",
							"print(source_usage_filename)\n",
							"\n",
							"#Read in the source Parquet file\n",
							"ri_saving = pd.read_parquet(source_usage_filename)\n",
							"\n",
							"#Drop all entries where ServiceInfo2 does not contain 'Windows Server BYOL' i.e. remove all entries that are not Windows Server HUB\n",
							"#ri_saving = ri_saving.drop(ri_saving.loc[~(ri_saving['MeterCategory'] == 'Virtual Machines') & ~(ri_saving['MeterSubCategory'] == 'Reservation-Base VM')].index).reset_index()\n",
							"ri_saving = ri_saving[(ri_saving['MeterCategory'] == 'Virtual Machines') & (ri_saving['MeterSubCategory'] == 'Reservation-Base VM')].reset_index(drop=True)\n",
							"\n",
							"#Removing all columns not required, need to do this before the flattening and merge of the AdditionalInfo as the AccountName \n",
							"#column exists in the ri_saving as well as within the AdditionalInfo column\n",
							"print('Removing unused columns')\n",
							"columns_to_keep = ['AdditionalInfo', 'Date', 'ConsumedQuantity','SubscriptionName','ServiceInfo2','Location']\n",
							"ri_saving = ri_saving[columns_to_keep]\n",
							"\n",
							"#ri_saving.reset_index(drop=True)\n",
							"print('Flattening and merging the AdditionalInfo column with the rest of the DataFrame')\n",
							"# Expand the json in the AdditionalInfo column into its own columns in a pd.Series then join it with the source dataframe\n",
							"ser = ri_saving['AdditionalInfo'].apply(lambda s: pd.json_normalize(json.loads(s)))\n",
							"ser2 = pd.concat(list(ser), ignore_index=True)\n",
							"ri_saving = ri_saving.join(ser2,)\n",
							"\n",
							"#Repeating the column removal so only the columns we need (the ones specified below) are left\n",
							"print('Removing unused columns')\n",
							"columns_to_keep = ['ServiceType', 'ReservationOrderId', 'Date', 'ConsumedQuantity','SubscriptionName','ServiceInfo2','Location']\n",
							"ri_saving = ri_saving[columns_to_keep]\n",
							"\n",
							"ri_saving['VMType'] = ri_saving['ServiceType'].str.replace('Standard_','')\n",
							"ri_saving['VMType'] = ri_saving['VMType'].str.replace('_',' ')\n",
							"\n",
							"print('Reading in the latest Pricelist file...')\n",
							"pricelist = pd.read_parquet(pricelist_file)\n",
							"pricelist.drop(pricelist[pricelist['offerId'] != 'MS-AZR-0017P'].index, inplace=True)\n",
							"columns_to_keep = ['meterName','unitOfMeasure',\t'includedQuantity', 'partNumber', 'unitPrice']\n",
							"pricelist = pricelist[columns_to_keep]\n",
							"\n",
							"#As we are only interested in 'Virtual Machine' Picelist meterNames removing all others from the ri_saving\n",
							"pricelist = pricelist[pricelist['meterName'].str.startswith('Virtual Machines')]\n",
							"pricelist = pricelist[~pricelist['meterName'].str.contains('Windows')]\n",
							"\n",
							"ri_saving['search_string'] = ri_saving['VMType'] + ' - ' + ri_saving['Location']\n",
							"\n",
							"df2 = pricelist['meterName'].str.split(pat='-', n=1).str[-1]\n",
							"df3 = df2.str.rsplit(pat='/', n=1, expand=True)\n",
							"df3[1] = df3[1].fillna(np.nan)\n",
							"df3.rename(columns={1:'short_meterName'}, inplace=True)\n",
							"df3.rename(columns={0:'0'}, inplace=True)\n",
							"df3[['short_meterName','0']] = df3[['short_meterName','0']].bfill(axis='columns')\n",
							"df3['short_meterName'] = df3['short_meterName'].str.lstrip()\n",
							"pricelist = pricelist.join(df3)\n",
							"pricelist.rename(columns={1:'short_meterName'}, inplace=True)\n",
							"pricelist.drop(columns='0', axis=1, inplace=True)\n",
							"print('Merging Usage with pricelist file...')\n",
							"ri_saving = ri_saving.merge(pricelist, left_on='search_string', right_on='short_meterName',)\n",
							"ri_saving['unitOfMeasure'] = ri_saving['unitOfMeasure'].str.replace(\"s\",\"\").str.replace(\"Hour\", \"\").astype('int32')\n",
							"ri_saving['PAYG_Rate_PH'] = ri_saving['unitPrice'] / ri_saving['unitOfMeasure']\n",
							"ri_saving['Cost_Avoided'] = ri_saving['ConsumedQuantity'] * ri_saving['PAYG_Rate_PH']\n",
							"\n",
							"print('Reading in Reservation Charges file...')\n",
							"reservation_charges = pd.read_parquet(reservation_charges_source_file)\n",
							"reservation_charges = reservation_charges[~reservation_charges['description'].str.startswith('SQL')]\n",
							"grouped_ri_saving = ri_saving.groupby('ReservationOrderId', as_index=False).aggregate({'ConsumedQuantity':np.sum, 'Cost_Avoided':np.sum})\n",
							"reservation_charges.rename(columns={'amount':'RI_Cost'}, inplace=True)\n",
							"reservation_charges.rename(columns={'reservationOrderId':'ReservationOrderId'}, inplace=True)\n",
							"grouped_ri_saving = grouped_ri_saving.merge(reservation_charges, how='left', on='ReservationOrderId')\n",
							"grouped_ri_saving['Saving_%'] = grouped_ri_saving['RI_Cost'] / grouped_ri_saving['Cost_Avoided']\n",
							"grouped_ri_saving['Saving'] = grouped_ri_saving['Cost_Avoided'] - grouped_ri_saving['RI_Cost']\n",
							"grouped_ri_saving['shortDate'] = grouped_ri_saving['eventDate'].str[:7]\n",
							"\n",
							"print('Writing Saving Parquet & CSV files....')\n",
							"grouped_ri_saving.to_parquet(saving_file_parquet)\n",
							"grouped_ri_saving.to_csv(saving_file_csv)\n",
							"\n",
							"\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": 21
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/Run Notebook on Previous Dates_v1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "Double check with Joakim",
				"folder": {
					"name": "NotebookInProduction/Cost Extension"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('Run Notebook on Previous Dates_v1_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "d6f8667b-ca45-4f1f-99e4-7ce92eca6c93"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('Run Notebook on Previous Dates_v1_notebookSparkPoolIdRef')]",
						"name": "[parameters('Run Notebook on Previous Dates_v1_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('Run Notebook on Previous Dates_v1_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import time"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Setting a root directory to get all the dates. Whether it is Actual or Amortized isn't important seeing as we only want the dates\r\n",
							"container = 'usage'\r\n",
							"root_dir = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/'\r\n",
							"\r\n",
							"\r\n",
							"# Getting the dates from the directory folder\r\n",
							"date_paths = mssparkutils.fs.ls(root_dir)\r\n",
							"dates = [files.name for files in date_paths]\r\n",
							"dates = [date_string.split('-') for date_string in dates]\r\n",
							"\r\n",
							"report_types = ['ActualCost', 'AmortizedCost']"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# # For Testing Purposes\r\n",
							"#dates = [[toDate, fromDate] for (toDate, fromDate) in dates if toDate >= '20230101']"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# n = 0\r\n",
							"# For each date, we run the notebook for the specific period\r\n",
							"for (fromDate, toDate) in dates:\r\n",
							"    notebook_reference = 'monthly-cost-extend-v3' if fromDate != dates[-1][0] else 'daily-cost-extend-v3'\r\n",
							"\r\n",
							"    for report_type in report_types:\r\n",
							"        print(f'Running {notebook_reference} notebook with report type {report_type} and date range {fromDate}-{toDate}')\r\n",
							"\r\n",
							"        # Checking the run-time of the notebook for timeout-purposes\r\n",
							"        start_time = time.time()\r\n",
							"\r\n",
							"        # Running Monthly Extend-notebook with the variable arguments as inputs to the notebook.\r\n",
							"        mssparkutils.notebook.run(path=notebook_reference, \r\n",
							"                                timeout_seconds=600,\r\n",
							"                                arguments={'fromDate' : fromDate, \r\n",
							"                                            'toDate' : toDate, \r\n",
							"                                            'container' : container,\r\n",
							"                                            'reportType': report_type})\r\n",
							"        end_time = time.time()\r\n",
							"        print(f\"The runtime of the {report_type} notebook was: {round(end_time - start_time, 2)} seconds.\")"
						],
						"outputs": [],
						"execution_count": 5
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM-Performance')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookNotInUse"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('VM-Performance_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": true,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "9e64a836-4adb-46ee-8a5d-cb8ef720415d"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('VM-Performance_notebookSparkPoolIdRef')]",
						"name": "[parameters('VM-Performance_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('VM-Performance_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"KVUri = 'https://acm-toolkit-kv.vault.azure.net/'\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"source": [
							"# Import Azure Resource Graph library\n",
							"#import azure.mgmt.resourcegraph as arg\n",
							"\n",
							"# Import specific methods and models from other libraries\n",
							"from azure.mgmt.resource import SubscriptionClient\n",
							"from azure.keyvault.secrets import SecretClient\n",
							"from azure.identity import DefaultAzureCredential, ClientSecretCredential, AzureCliCredential, ManagedIdentityCredential\n",
							"import pandas as pd\n",
							"import json\n",
							"import requests\n",
							"from datetime import timedelta, datetime\n",
							"from requests.structures import CaseInsensitiveDict\n",
							"\n",
							"def get_token(KVUri):\n",
							"    \n",
							"    #KVUri = os.environ[\"CFG_KEY_VAULT_URL\"]\n",
							"    #credential = DefaultAzureCredential()\n",
							"    credential = ManagedIdentityCredential(client_id='6b32e22c-0279-46d8-a304-ae1fdf47100e')\n",
							"    #token = credential.get_token(\"https://vault.azure.net/.default\")\n",
							"    client = SecretClient(vault_url=KVUri, credential=credential)\n",
							"\n",
							"    client_id = client.get_secret('Azure-Cost-Management-Metrics-Reader-Client-Id').value\n",
							"    client_secret = client.get_secret('Python-Azure-Cost-Management-Metrics-Reader').value\n",
							"    tenant_id = client.get_secret('tenantID').value\n",
							"    #database = get_keyvault_value(key_vault_client, 'synapseDatabaseName')\n",
							"    #server = get_keyvault_value(key_vault_client, 'synapseServerName')\n",
							"    authorityHostUrl = client.get_secret('msAuthorityURL').value\n",
							"\n",
							"    credential = ClientSecretCredential(tenant_id, client_id, client_secret, authority=authorityHostUrl)\n",
							"    token = credential.get_token(\"https://management.azure.com/.default\")\n",
							"\n",
							"    return token, credential, client_id, client_secret, tenant_id\n",
							"\n",
							"# Wrap all the work in a function\n",
							"def get_subscription_list(credential):\n",
							"\n",
							"    # Get your credentials from Azure CLI (development only!) and get your subscription list\n",
							"    #credential = AzureCliCredential(scopes=\"http://S037-RI-Reporting-SP/.default\")\n",
							"    subsClient = SubscriptionClient(credential)\n",
							"    subsRaw = []\n",
							"    for sub in subsClient.subscriptions.list():\n",
							"        subsRaw.append(sub.as_dict())\n",
							"    subsList = []\n",
							"    for sub in subsRaw:\n",
							"        subsList.append(sub.get('subscription_id'))\n",
							"\n",
							"    #print(f'Subscription List: {subsList}')\n",
							"\n",
							"    return subsList\n",
							"\n",
							"def get_vm_list(credential, subsList, strQuery, resource_list, skip_token=''):\n",
							"\n",
							"    # Create Azure Resource Graph client and set options\n",
							"    argClient = arg.ResourceGraphClient(credential)\n",
							"\n",
							"    if skip_token == '':\n",
							"        argQueryOptions = arg.models.QueryRequestOptions(result_format=\"objectArray\")\n",
							"    else:\n",
							"        argQueryOptions = arg.models.QueryRequestOptions(skip_token=skip_token, result_format=\"objectArray\")\n",
							"\n",
							"    # Create query\n",
							"    argQuery = arg.models.QueryRequest(subscriptions=subsList, query=strQuery, options=argQueryOptions)\n",
							"\n",
							"    #print(f'Arg Query: {argQuery}')\n",
							"\n",
							"    # Run query\n",
							"    argResults = argClient.resources(argQuery)\n",
							"\n",
							"    # Show Python object\n",
							"    #print(f'Arg Results: {argResults}')\n",
							"\n",
							"    new_page = pd.read_json(json.dumps(argResults.data))\n",
							"    resource_list = pd.concat([resource_list, new_page], ignore_index=True)\n",
							"   \n",
							"    return resource_list, argResults.skip_token\n",
							"\n",
							"def get_access_token(url, client_id, client_secret):\n",
							"    response = requests.post(\n",
							"        url,\n",
							"        data={\"grant_type\": \"client_credentials\"},\n",
							"        auth=(client_id, client_secret),\n",
							"    )\n",
							"    print(f'Response: {response}')\n",
							"    return response.json()[\"access_token\"]\n",
							"\n",
							"container = 'performance'\n",
							"vm_path = 'vm'\n",
							"cpu_avg_folder = 'percentage_cpu'\n",
							"\n",
							"year = (datetime.now() - timedelta(days=1)).strftime('%Y')\n",
							"month = (datetime.now() - timedelta(days=1)).strftime('%m')\n",
							"day = (datetime.now() - timedelta(days=1)).strftime('%d')\n",
							"\n",
							"performance_store = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + vm_path + '/' + cpu_avg_folder + '/' + year + '/' + month + '/' + day + '/'\n",
							"\n",
							"## Get subscription, resourcegroup and name of every VM that the service principal has access to in graph   \n",
							"token, credential, client_id, client_secret, tenant_id = get_token(KVUri)\n",
							"resource_query = \"resources | where type == 'microsoft.compute/virtualmachines' or type == 'microsoft.compute/virtualmachinescalesets' | project subscriptionId, resourceGroup, name\"\n",
							"subsList = get_subscription_list(credential)\n",
							"resource_list = pd.DataFrame()\n",
							"resource_list, skip_token = get_vm_list(credential, subsList, resource_query, resource_list)\n",
							"while skip_token != None:\n",
							"    resource_list, skip_token = get_vm_list(credential, subsList, resource_query, resource_list, skip_token)\n",
							"resource_list.sort_values(by=['subscriptionId', 'resourceGroup', 'name'], inplace=True, ignore_index=True)\n",
							"print(resource_list)\n",
							"print(f'Number of VMs: {len(resource_list)}')\n",
							"\n",
							"## Retrieve the vCPU % performance indicator for each VM in the resource_list\n",
							"\n",
							"start_date = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')\n",
							"end_date = (datetime.now()).strftime('%Y-%m-%d')\n",
							"print(start_date)\n",
							"print(end_date)\n",
							"interval = 'PT1M'\n",
							"\n",
							"headers = CaseInsensitiveDict()\n",
							"headers[\"Authorization\"] = \"Bearer {}\".format(token.token)\n",
							"headers[\"Host\"] = \"management.azure.com\"\n",
							"\n",
							"vm_perf = pd.DataFrame(columns=['timeStamp', 'average', 'value.unit', 'value.name', 'value.id'])\n",
							"\n",
							"for index, row in resource_list.iterrows():\n",
							"    url = 'https://management.azure.com/subscriptions/' + row['subscriptionId'] + '/resourceGroups/' + row['resourceGroup'] + '/providers/Microsoft.Compute/virtualMachines/' + row['name'] + '/providers/microsoft.insights/metrics?api-version=2018-01-01&metricnames=Percentage CPU&timespan=' + start_date +'T00:00:00Z/' + end_date + 'T00:00:00Z&interval=' + interval\n",
							"\n",
							"    response = requests.get(url, headers=headers)\n",
							"    json_result = json.dumps(response.json())\n",
							"\n",
							"    vm_perf = pd.concat([vm_perf, pd.json_normalize(response.json(), \n",
							"                            record_path=['value', 'timeseries', 'data'],\n",
							"                            meta=[['value','id'], ['value', 'name'], ['value','unit']])], ignore_index=True)\n",
							"    print(f'Length is: {len(vm_perf)}')\n",
							"    print(row['name'])\n",
							"    print(vm_perf[['timeStamp', 'average']].tail(1))\n",
							"\n",
							"pd.set_option('display.max_columns', None)  \n",
							"print(vm_perf.columns)\n",
							"print(vm_perf)\n",
							"vm_perf['metric'] = vm_perf.apply(lambda x: (x['value.name'])['value'], axis = 1)\n",
							"vm_perf.drop(['value.name'], axis=1, inplace=True)\n",
							"vm_perf.rename(columns={\"value.id\": \"id\", \"value.unit\": \"unit\"}, errors=\"raise\", inplace=True)\n",
							"vm_perf = vm_perf[['timeStamp', 'average', 'unit', 'metric', 'id']]\n",
							"print(vm_perf)\n",
							"print(f'Start Date: {start_date}')\n",
							"print(f'End Date: {end_date}')\n",
							"print(f'Number of VMs: {len(resource_list)}')\n",
							"print('Writing performance data to file...')\n",
							"vm_perf.to_parquet(performance_store + 'cpu_avg.parquet')\n",
							"print('Done')\n",
							"\n",
							"\n",
							""
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							""
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM-utilization-aggregation')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/VMUtilization"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('VM-utilization-aggregation_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "c38bcc6c-0d84-4dbd-a5d9-3a649e5344d4"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('VM-utilization-aggregation_notebookSparkPoolIdRef')]",
						"name": "[parameters('VM-utilization-aggregation_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('VM-utilization-aggregation_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Script Initialization\r\n",
							"##### Set parameters, variables and scehma"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from datetime import datetime, timedelta\r\n",
							"import os\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Parameters\r\n",
							"storageAccount = 's037costmgmt'\r\n",
							"currentDate = '2023-10-19'"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Date variables\r\n",
							"startDate = datetime.strptime(currentDate, '%Y-%m-%d') - timedelta(days=90)"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Set Pyspark schema\r\n",
							"schema = T.StructType([\r\n",
							"    T.StructField(\"timestamp\", T.TimestampType(), True),\r\n",
							"    T.StructField(\"cpu_average\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"subscriptionId\", T.StringType(), True),\r\n",
							"    T.StructField(\"resourceGroupName\", T.StringType(), True),\r\n",
							"    T.StructField(\"virtualMachineName\", T.StringType(), True)\r\n",
							"])"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Extract data from source"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Find file paths for aggregation\r\n",
							"def compute_file_paths(start_date, file_paths=[]):\r\n",
							"    date_iter = start_date\r\n",
							"    while (date_iter < datetime.strptime(currentDate, '%Y-%m-%d')):\r\n",
							"        data_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-by-subscription/*/{date_iter.year}/{str(date_iter.month).zfill(2)}/{str(date_iter.day).zfill(2)}/vm_cpu_avg.parquet\"\r\n",
							"        file_paths.append(data_path)\r\n",
							"        date_iter += timedelta(days=1)\r\n",
							"    return file_paths"
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Load filedata to dataframe\r\n",
							"def load_to_df(start_date):\r\n",
							"    df = spark.createDataFrame([], schema=schema)\r\n",
							"    file_paths = compute_file_paths(start_date)\r\n",
							"    for file_path in file_paths:\r\n",
							"        try:\r\n",
							"            file_df = spark.read.parquet(file_path)\r\n",
							"            print(f\"Success reading file {file_path}\")\r\n",
							"            df = df.union(file_df)\r\n",
							"        except Exception as e:\r\n",
							"            print(f\"Error reading file {file_path}: {str(e)}\")\r\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Transform source data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"metrics_df = load_to_df(startDate)\r\n",
							"metrics_df = metrics_df.withColumn('Report_Date', F.to_date(\"timestamp\"))\r\n",
							"\r\n",
							"hourly_df = metrics_df.alias('hourly_df')\r\n",
							"daily_df = metrics_df.alias('daily_df')\r\n",
							"\r\n",
							"# Compute daily CPU average\r\n",
							"daily_df = daily_df.filter(F.col('cpu_average').isNotNull())\r\n",
							"daily_df = daily_df.groupBy('subscriptionId', 'resourceGroupName', 'virtualMachineName', 'Report_Date').agg(F.avg('cpu_average').alias('cpu_avg'))\r\n",
							"\r\n",
							"# Set null values in hourly CPU average to 0\r\n",
							"hourly_df = hourly_df.withColumn('cpu_average', F.when(F.col('cpu_average').isNull(), F.lit(0)).otherwise(F.col('cpu_average')))"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load transformed data to container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Write 3 month aggregation to ADLS\r\n",
							"daily_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-aggregates/vm_cpu_agg_daily_past_3_months.parquet\"\r\n",
							"daily_df.write.format('parquet').mode('overwrite').save(daily_path)\r\n",
							"\r\n",
							"hourly_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-aggregates/vm_cpu_agg_hourly_past_3_months.parquet\"\r\n",
							"hourly_df.write.format('parquet').mode('overwrite').save(hourly_path)"
						],
						"outputs": [],
						"execution_count": 32
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM-utilization-fetch')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/VMUtilization"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('VM-utilization-fetch_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "69b086fb-0f83-4dce-aec4-b38a990f9266"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('VM-utilization-fetch_notebookSparkPoolIdRef')]",
						"name": "[parameters('VM-utilization-fetch_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('VM-utilization-fetch_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Script Initialization\r\n",
							"##### Set parameters, constants, variables and scehma"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from datetime import datetime, timedelta\r\n",
							"from azure.identity import ClientSecretCredential, KnownAuthorities\r\n",
							"from notebookutils import mssparkutils\r\n",
							"import requests\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Parameters\r\n",
							"storageAccount = 's037costmgmt'\r\n",
							"subscriptionId = '061f6daa-2afe-427d-b3a5-a1919906d96f'\r\n",
							"startDate = '2023-10-17'"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Constants\r\n",
							"KEY_VAULT_NAME = 'acm-toolkit-kv'\r\n",
							"SCOPE = 'https://management.azure.com/.default'\r\n",
							"BASE_URL = 'https://management.azure.com/'\r\n",
							"LINKED_SERVICE_NAME = 'ACM_Toolkit_kv'"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Date variables\r\n",
							"next_day = datetime.strptime(startDate, '%Y-%m-%d') + timedelta(days=1)\r\n",
							"endDate = next_day.strftime('%Y-%m-%d')\r\n",
							"\r\n",
							"datesplit = startDate.split('-')\r\n",
							"year = datesplit[0]\r\n",
							"month = datesplit[1]\r\n",
							"day = datesplit[2]"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Set Pyspark schema\r\n",
							"\r\n",
							"api_schema = T.StructType([\r\n",
							"    T.StructField(\"metadatavalues\", T.ArrayType(\r\n",
							"        T.StructType([\r\n",
							"            T.StructField(\"name\", T.StructType([\r\n",
							"                T.StructField(\"value\", T.StringType()),\r\n",
							"                T.StructField(\"localizedValue\", T.StringType())\r\n",
							"            ])),\r\n",
							"            T.StructField(\"value\", T.StringType())\r\n",
							"        ])\r\n",
							"    )),\r\n",
							"    T.StructField(\"data\", T.ArrayType(\r\n",
							"        T.StructType([\r\n",
							"            T.StructField(\"timeStamp\", T.StringType()),\r\n",
							"            T.StructField(\"average\", T.DoubleType())\r\n",
							"        ])\r\n",
							"    ))\r\n",
							"])\r\n",
							"\r\n",
							"parquet_schema = T.StructType([\r\n",
							"    T.StructField(\"timestamp\", T.TimestampType(), True),\r\n",
							"    T.StructField(\"cpu_average\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"subscriptionId\", T.StringType(), True),\r\n",
							"    T.StructField(\"resourceGroupName\", T.StringType(), True),\r\n",
							"    T.StructField(\"virtualMachineName\", T.StringType(), True)\r\n",
							"])"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Extract data from source"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def read_subscription_locations(location_path):\r\n",
							"    location_df = spark.read.csv(location_path, header=True, inferSchema=True)\r\n",
							"    location_df = location_df.select('location').distinct()\r\n",
							"    location_list = [row['location'] for row in location_df.collect()]\r\n",
							"    unique_locations = [str(value) for value in location_list]\r\n",
							"    return unique_locations"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_access_token():\r\n",
							"    tenant_id = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'tenantID', LINKED_SERVICE_NAME)\r\n",
							"    client_id = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'Azure-Cost-Management-Metrics-Reader-Client-Id', LINKED_SERVICE_NAME)\r\n",
							"    client_secret = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'Azure-Cost-Management-Metrics-Reader-secret', LINKED_SERVICE_NAME)\r\n",
							"\r\n",
							"    credential = ClientSecretCredential(\r\n",
							"        authority=KnownAuthorities.AZURE_PUBLIC_CLOUD,\r\n",
							"        tenant_id=tenant_id,\r\n",
							"        client_id=client_id,\r\n",
							"        client_secret=client_secret\r\n",
							"    )\r\n",
							"\r\n",
							"    token = credential.get_token(SCOPE)\r\n",
							"    return token.token"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def build_api_endpoint(\r\n",
							"    subscription_id, \r\n",
							"    start_date, \r\n",
							"    end_date,\r\n",
							"    interval,\r\n",
							"    metric,\r\n",
							"    location,\r\n",
							"    aggregation,\r\n",
							"    api_version):\r\n",
							"\r\n",
							"    url = BASE_URL\r\n",
							"    url += f\"subscriptions/{subscription_id}/providers/microsoft.Insights/metrics?\"\r\n",
							"    url += f\"timespan={start_date}T00:00:00.000Z/{end_date}T00:00:00.000Z\"\r\n",
							"    url += f\"&interval={interval}\"\r\n",
							"    url += f\"&metricnames={metric}\"\r\n",
							"    url += f\"&region={location}\"\r\n",
							"    url += f\"&aggregation={aggregation}\"\r\n",
							"    url += f\"&api-version={api_version}\"\r\n",
							"    url += f\"&metricNamespace=microsoft.compute/virtualmachines&$filter=Microsoft.ResourceId eq '*'\"\r\n",
							"\r\n",
							"    return url"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def fetch_metrics(access_token, location):\r\n",
							"    # Build Azure management API metric endpoint\r\n",
							"    api_endpoint = build_api_endpoint(\r\n",
							"        subscription_id=subscriptionId,\r\n",
							"        start_date=startDate,\r\n",
							"        end_date=endDate,\r\n",
							"        interval=\"PT1H\",\r\n",
							"        metric=\"Percentage CPU\",\r\n",
							"        location=location,\r\n",
							"        aggregation=\"average\",\r\n",
							"        api_version=\"2021-05-01\"\r\n",
							"    )\r\n",
							"\r\n",
							"    headers = {\r\n",
							"        'Authorization': 'Bearer ' + access_token\r\n",
							"    }\r\n",
							"\r\n",
							"    response = requests.get(api_endpoint, headers=headers)\r\n",
							"    result = response.json()\r\n",
							"    return result"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Transform source data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"def transform_to_df(json_result):\r\n",
							"    df = spark.createDataFrame(json_result[\"value\"][0]['timeseries'], schema=api_schema)\r\n",
							"\r\n",
							"    df = df.withColumn('resourceReference', F.col('metadatavalues')[0].value.alias('resourceReference'))\r\n",
							"    df = df.withColumn('data', F.explode('data'))\r\n",
							"\r\n",
							"    df = df.select('resourceReference', F.col('data.timeStamp').alias('timestamp'), F.col('data.average').alias('cpu_average'))\r\n",
							"\r\n",
							"    df = df.withColumn('refComponents', F.split(F.col('resourceReference'), '/'))\r\n",
							"    df = df.withColumn('subscriptionId', F.col('refComponents')[2])\r\n",
							"    df = df.withColumn('resourceGroupName', F.col('refComponents')[4])\r\n",
							"    df = df.withColumn('virtualMachineName', F.col('refComponents')[8])\r\n",
							"\r\n",
							"    df = df.withColumn(\"timestamp\", F.to_timestamp(\"timestamp\", \"yyyy-MM-dd'T'HH:mm:ss'Z'\"))\r\n",
							"\r\n",
							"    df = df.drop('resourceReference', 'refComponents')\r\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load transformed data to container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Get all locations that the given subscription has residing VMs\r\n",
							"location_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-by-subscription/{subscriptionId}/locations.csv\"\r\n",
							"locations = read_subscription_locations(location_path)\r\n",
							"\r\n",
							"# Get service principal access token\r\n",
							"access_token = get_access_token()\r\n",
							"\r\n",
							"df = spark.createDataFrame([], schema=parquet_schema)\r\n",
							"\r\n",
							"for location in locations:\r\n",
							"    # Fetch virtual machine utilization metrics in given location\r\n",
							"    metrics = fetch_metrics(access_token, location)\r\n",
							"\r\n",
							"    # Transform metrics json data to dataframe\r\n",
							"    metrics_df = transform_to_df(metrics)\r\n",
							"    \r\n",
							"    # Merge metrics from current location with target\r\n",
							"    df = df.union(metrics_df)\r\n",
							"\r\n",
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-by-subscription/{subscriptionId}/{year}/{month}/{day}/vm_cpu_avg.parquet\"\r\n",
							"df.write.format('parquet').mode('overwrite').save(target_path)"
						],
						"outputs": [],
						"execution_count": 11
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/VM-utilization-historic')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/VMUtilization"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('VM-utilization-historic_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "623bee09-dcec-46e5-8fd7-b23ed08521c8"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('VM-utilization-historic_notebookSparkPoolIdRef')]",
						"name": "[parameters('VM-utilization-historic_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('VM-utilization-historic_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Script Initialization\r\n",
							"##### Set parameters, variables and scehma"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"from datetime import datetime, timedelta\r\n",
							"from azure.identity import ClientSecretCredential, KnownAuthorities\r\n",
							"from notebookutils import mssparkutils\r\n",
							"import requests\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 175
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Parameters\r\n",
							"storageAccount = 's037costmgmt'\r\n",
							"startDate = '2023-10-01'"
						],
						"outputs": [],
						"execution_count": 176
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Constants\r\n",
							"KEY_VAULT_NAME = 'acm-toolkit-kv'\r\n",
							"SCOPE = 'https://management.azure.com/.default'\r\n",
							"BASE_URL = 'https://management.azure.com/'\r\n",
							"LINKED_SERVICE_NAME = 'ACM_Toolkit_kv'"
						],
						"outputs": [],
						"execution_count": 177
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Set Pyspark schema\r\n",
							"\r\n",
							"api_schema = T.StructType([\r\n",
							"    T.StructField(\"metadatavalues\", T.ArrayType(\r\n",
							"        T.StructType([\r\n",
							"            T.StructField(\"name\", T.StructType([\r\n",
							"                T.StructField(\"value\", T.StringType()),\r\n",
							"                T.StructField(\"localizedValue\", T.StringType())\r\n",
							"            ])),\r\n",
							"            T.StructField(\"value\", T.StringType())\r\n",
							"        ])\r\n",
							"    )),\r\n",
							"    T.StructField(\"data\", T.ArrayType(\r\n",
							"        T.StructType([\r\n",
							"            T.StructField(\"timeStamp\", T.StringType()),\r\n",
							"            T.StructField(\"average\", T.DoubleType())\r\n",
							"        ])\r\n",
							"    ))\r\n",
							"])\r\n",
							"\r\n",
							"parquet_schema = T.StructType([\r\n",
							"    T.StructField(\"timestamp\", T.TimestampType(), True),\r\n",
							"    T.StructField(\"cpu_average\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"subscriptionId\", T.StringType(), True),\r\n",
							"    T.StructField(\"resourceGroupName\", T.StringType(), True),\r\n",
							"    T.StructField(\"virtualMachineName\", T.StringType(), True)\r\n",
							"])\r\n",
							"\r\n",
							"subscription_schema = T.StructType([\r\n",
							"    T.StructField(\"subscriptionId\", T.StringType(), True)\r\n",
							"])"
						],
						"outputs": [],
						"execution_count": 178
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Extract data from source"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def read_subscription_locations(location_path):\r\n",
							"    location_df = spark.read.csv(location_path, header=True, inferSchema=True)\r\n",
							"    location_df = location_df.select('location').distinct()\r\n",
							"    location_list = [row['location'] for row in location_df.collect()]\r\n",
							"    unique_locations = [str(value) for value in location_list]\r\n",
							"    return unique_locations"
						],
						"outputs": [],
						"execution_count": 179
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_access_token():\r\n",
							"    tenant_id = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'tenantID', LINKED_SERVICE_NAME)\r\n",
							"    client_id = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'Azure-Cost-Management-Metrics-Reader-Client-Id', LINKED_SERVICE_NAME)\r\n",
							"    client_secret = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'Azure-Cost-Management-Metrics-Reader-secret', LINKED_SERVICE_NAME)\r\n",
							"\r\n",
							"    credential = ClientSecretCredential(\r\n",
							"        authority=KnownAuthorities.AZURE_PUBLIC_CLOUD,\r\n",
							"        tenant_id=tenant_id,\r\n",
							"        client_id=client_id,\r\n",
							"        client_secret=client_secret\r\n",
							"    )\r\n",
							"\r\n",
							"    token = credential.get_token(SCOPE)\r\n",
							"    return token.token"
						],
						"outputs": [],
						"execution_count": 180
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def build_metrics_endpoint(\r\n",
							"    subscription_id, \r\n",
							"    start_date, \r\n",
							"    end_date,\r\n",
							"    interval,\r\n",
							"    metric,\r\n",
							"    location,\r\n",
							"    aggregation,\r\n",
							"    api_version):\r\n",
							"\r\n",
							"    url = BASE_URL\r\n",
							"    url += f\"subscriptions/{subscription_id}/providers/microsoft.Insights/metrics?\"\r\n",
							"    url += f\"timespan={start_date}T00:00:00.000Z/{end_date}T00:00:00.000Z\"\r\n",
							"    url += f\"&interval={interval}\"\r\n",
							"    url += f\"&metricnames={metric}\"\r\n",
							"    url += f\"&region={location}\"\r\n",
							"    url += f\"&aggregation={aggregation}\"\r\n",
							"    url += f\"&api-version={api_version}\"\r\n",
							"    url += f\"&metricNamespace=microsoft.compute/virtualmachines&$filter=Microsoft.ResourceId eq '*'\"\r\n",
							"\r\n",
							"    return url"
						],
						"outputs": [],
						"execution_count": 181
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def fetch_metrics(access_token, location, start_date):\r\n",
							"    # Compute end date for endpoint query\r\n",
							"    next_day = start_date + timedelta(days=1)\r\n",
							"    end_date = next_day.strftime('%Y-%m-%d')\r\n",
							"    start_date = start_date.strftime('%Y-%m-%d')\r\n",
							"\r\n",
							"    # Build Azure management API metric endpoint\r\n",
							"    api_endpoint = build_metrics_endpoint(\r\n",
							"        subscription_id=subscriptionId,\r\n",
							"        start_date=start_date,\r\n",
							"        end_date=end_date,\r\n",
							"        interval=\"PT1H\",\r\n",
							"        metric=\"Percentage CPU\",\r\n",
							"        location=location,\r\n",
							"        aggregation=\"average\",\r\n",
							"        api_version=\"2021-05-01\"\r\n",
							"    )\r\n",
							"\r\n",
							"    headers = {\r\n",
							"        'Authorization': 'Bearer ' + access_token\r\n",
							"    }\r\n",
							"\r\n",
							"    response = requests.get(api_endpoint, headers=headers)\r\n",
							"    result = response.json()\r\n",
							"    return result"
						],
						"outputs": [],
						"execution_count": 182
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def fetch_subscriptions(access_token):\r\n",
							"    api_endpoint = \"https://management.azure.com/subscriptions?api-version=2022-12-01\"\r\n",
							"\r\n",
							"    headers = {\r\n",
							"        'Authorization': 'Bearer ' + access_token\r\n",
							"    }\r\n",
							"\r\n",
							"    response = requests.get(api_endpoint, headers=headers)\r\n",
							"    result = response.json()\r\n",
							"    return result"
						],
						"outputs": [],
						"execution_count": 183
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Transform source data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def transform_metrics_to_df(json_result):\r\n",
							"    df = spark.createDataFrame(json_result[\"value\"][0]['timeseries'], schema=api_schema)\r\n",
							"\r\n",
							"    df = df.withColumn('resourceReference', F.col('metadatavalues')[0].value.alias('resourceReference'))\r\n",
							"    df = df.withColumn('data', F.explode('data'))\r\n",
							"\r\n",
							"    df = df.select('resourceReference', F.col('data.timeStamp').alias('timestamp'), F.col('data.average').alias('cpu_average'))\r\n",
							"\r\n",
							"    df = df.withColumn('refComponents', F.split(F.col('resourceReference'), '/'))\r\n",
							"    df = df.withColumn('subscriptionId', F.col('refComponents')[2])\r\n",
							"    df = df.withColumn('resourceGroupName', F.col('refComponents')[4])\r\n",
							"    df = df.withColumn('virtualMachineName', F.col('refComponents')[8])\r\n",
							"\r\n",
							"    df = df.withColumn(\"timestamp\", F.to_timestamp(\"timestamp\", \"yyyy-MM-dd'T'HH:mm:ss'Z'\"))\r\n",
							"\r\n",
							"    df = df.drop('resourceReference', 'refComponents')\r\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 184
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def transform_subscriptions_to_list(json_result):\r\n",
							"    df = spark.createDataFrame(json_result[\"value\"], schema=subscription_schema)\r\n",
							"    df = df.select('subscriptionId').distinct()\r\n",
							"    sub_list = [row['subscriptionId'] for row in df.collect()]\r\n",
							"    return sub_list"
						],
						"outputs": [],
						"execution_count": 185
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load transformed data to container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Get service principal access token\r\n",
							"access_token = get_access_token()\r\n",
							"\r\n",
							"# Get subscriptions\r\n",
							"subscriptions = fetch_subscriptions(access_token)\r\n",
							"sub_list = transform_subscriptions_to_list(subscriptions)\r\n",
							"\r\n",
							"# Set termination date to today\r\n",
							"end_date = datetime.strptime(str(datetime.now().date()), '%Y-%m-%d')\r\n",
							"\r\n",
							"for subscriptionId in sub_list:\r\n",
							"    #Get all locations that the given subscription has residing VMs\r\n",
							"    location_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-by-subscription/{subscriptionId}/locations.csv\"\r\n",
							"    locations = read_subscription_locations(location_path)\r\n",
							"\r\n",
							"    date_iter = datetime.strptime(startDate, '%Y-%m-%d')\r\n",
							"\r\n",
							"    while(date_iter < end_date):\r\n",
							"        try:\r\n",
							"            df = spark.createDataFrame([], schema=parquet_schema)\r\n",
							"\r\n",
							"            for location in locations:\r\n",
							"                # Fetch virtual machine utilization metrics in given location\r\n",
							"                metrics = fetch_metrics(access_token, location, date_iter.date())\r\n",
							"\r\n",
							"                # Transform metrics json data to dataframe\r\n",
							"                metrics_df = transform_metrics_to_df(metrics)\r\n",
							"                \r\n",
							"                # Merge metrics from current location with target\r\n",
							"                df = df.union(metrics_df)\r\n",
							"\r\n",
							"            target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/metrics/vm-utilization-by-subscription/{subscriptionId}/{date_iter.year}/{str(date_iter.month).zfill(2)}/{str(date_iter.day).zfill(2)}/vm_cpu_avg.parquet\"\r\n",
							"            df.write.format('parquet').mode('overwrite').save(target_path)\r\n",
							"\r\n",
							"            print(f\"Successfully loaded metrics for {date_iter}\")\r\n",
							"            print(f\"path: {target_path}\")\r\n",
							"            \r\n",
							"        except Exception as e:\r\n",
							"            print(f\"Error: {e}\")\r\n",
							"\r\n",
							"        date_iter += timedelta(days=1)"
						],
						"outputs": [],
						"execution_count": 186
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/advisor-recommendations-processing')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Azure"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('advisor-recommendations-processing_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "06ebd69a-1753-4306-ac11-8859dfad3088"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('advisor-recommendations-processing_notebookSparkPoolIdRef')]",
						"name": "[parameters('advisor-recommendations-processing_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('advisor-recommendations-processing_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Parameters\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 15
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 16
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"# Load source\r\n",
							"source_path = \"abfss://usage@\" + storageAccount + \".dfs.core.windows.net/recommendations/advisor-recommendations-subscription-*.parquet\"\r\n",
							"recommendation_df = spark.read.format('parquet').load(source_path)"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Only persist cost recommendations\r\n",
							"recommendation_df = recommendation_df.filter(F.col('category') == 'Cost')"
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Store combined cost recommendation data in a collective file \r\n",
							"optimized_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/recommendations/cost-recommendations.parquet\"\r\n",
							"recommendation_df.write.format('parquet').mode('overwrite').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 19
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/calculate-missing-application-cost')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Utilities"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('calculate-missing-application-cost_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "ff3d28f5-d377-4ead-b8e7-d6067c81dfd9"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('calculate-missing-application-cost_notebookSparkPoolIdRef')]",
						"name": "[parameters('calculate-missing-application-cost_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('calculate-missing-application-cost_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from pyspark.sql import functions as F"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"source": [
							"source_path = \"abfss://usage@s037costmgmt.dfs.core.windows.net/exports/monthly/aggregate/parquet/Extended_ACMMonthlyAmortizedCost_overview_OneYear.parquet\" \r\n",
							"df = spark.read.format('parquet').load(source_path)"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df = df.where(F.col('ApplicationName') == 'Application not defined or not found')"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df = df.withColumnRenamed('SubscriptionServiceNow-App', 'Application')"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df = df.where((F.col('Report_Date') >= '2023-09-01 00:00:00') & (F.col('Report_Date') <= '2023-11-01 00:00:00'))"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.agg(F.sum('CostInBillingCurrency')))"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"df = df \\\r\n",
							"    .select('Report_Date', 'CostInBillingCurrency','SubscriptionName', 'Application') \\\r\n",
							"    .groupBy('Report_Date', 'SubscriptionName', 'Application') \\\r\n",
							"    .agg(F.sum('CostInBillingCurrency').alias('Cost'))"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df)"
						],
						"outputs": [],
						"execution_count": 32
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(df.count())"
						],
						"outputs": [],
						"execution_count": 33
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.select('Application', 'SubscriptionName').distinct())"
						],
						"outputs": [],
						"execution_count": 34
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.select('Application').distinct())"
						],
						"outputs": [],
						"execution_count": 35
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.select('SubscriptionName').distinct())"
						],
						"outputs": [],
						"execution_count": 36
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.select('Cost', 'Application').groupBy('Application').agg(F.sum('Cost').alias('Cost')))"
						],
						"outputs": [],
						"execution_count": 37
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(df.select('Cost', 'SubscriptionName').groupBy('SubscriptionName').agg(F.sum('Cost').alias('Cost')))"
						],
						"outputs": [],
						"execution_count": 38
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"pivot = df.select('SubscriptionName', 'Application', 'Cost').groupBy('SubscriptionName', 'Application').agg(F.sum('Cost').alias('Cost'))\r\n",
							"display(pivot)"
						],
						"outputs": [],
						"execution_count": 39
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"danske = df.where(F.upper(F.col('SubscriptionName')).like('%DANSKE%')).agg(F.sum('Cost').alias('Cost'))\r\n",
							"display(danske)"
						],
						"outputs": [],
						"execution_count": 40
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/check-hub-deployment')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('check-hub-deployment_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": true,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "09fef7be-9d83-4300-b793-2fd6300b6dac"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('check-hub-deployment_notebookSparkPoolIdRef')]",
						"name": "[parameters('check-hub-deployment_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('check-hub-deployment_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Find Windows/SQL HUB Enabled/Eligible cost\r\n",
							"\r\n",
							"### Find number of resources enabled/disabled\r\n",
							"\r\n",
							"### Check hubautomation which should be enabled (and disabled)"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 21
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_path = f'abfss://usage@s037costmgmt.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/20240201-20240229/Extended_v3_ACMMonthlyAmortizedCost_20240201-20240229.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 22
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(cost_df.where((F.col('MeterSubCategory') == 'Managed Instance General Purpose - SQL License') & (F.col('ResourceName') == 's072sqlcdm01p')))"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(cost_df.where(F.col('WindowsAHB') != 'Not Supported').select('Date', 'ResourceName', 'WindowsAHB', 'WindowsAHB_VCPUs').distinct().groupBy('WindowsAHB', 'Date').agg(F.countDistinct('ResourceName'), F.sum('WindowsAHB_VCPUs')))"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(cost_df.where(F.col('SQLAHB') != 'Not Supported').select('Date', 'ResourceName', 'SQLAHB', 'SQLAHB_VCPUs').distinct().groupBy('SQLAHB', 'Date').agg(F.countDistinct('ResourceName'), F.sum('SQLAHB_VCPUs')))"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(cost_df.where(F.col('SQLAHB') == 'Not Enabled').select('ResourceName').distinct().count())"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ',',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sql_deploy_path = 'abfss://sql-hub-logs@hubautomation.dfs.core.windows.net/2024-02-24-AHUB-Deployment.csv'\r\n",
							"sql_deploy_df = spark.read.options(**csv_options).format('csv').load(sql_deploy_path)"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(sql_deploy_df)"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sql_remove_path = 'abfss://sql-hub-logs@hubautomation.dfs.core.windows.net/2024-02-24-AHUB-Removal.csv'\r\n",
							"sql_remove_df = spark.read.options(**csv_options).format('csv').load(sql_remove_path)"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(sql_remove_df.select('ResourceId').distinct().count())"
						],
						"outputs": [],
						"execution_count": 18
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/check-subscription-diff')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Utilities"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('check-subscription-diff_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "a255d334-078d-4d89-8f21-f79fd3eff6d5"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('check-subscription-diff_notebookSparkPoolIdRef')]",
						"name": "[parameters('check-subscription-diff_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('check-subscription-diff_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 101
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"servicenow_path = \"abfss://usage@s037costmgmt.dfs.core.windows.net/subscriptions/servicenow/2023-10-31-optimized.parquet/**\"\r\n",
							"solum_path = \"abfss://usage@s037costmgmt.dfs.core.windows.net/subscriptions/subscriptions_2023-10-31.json\"\r\n",
							"\r\n",
							"snow_df = spark.read.format('parquet').load(servicenow_path)\r\n",
							"solum_df = spark.read.json(solum_path)"
						],
						"outputs": [],
						"execution_count": 102
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"def view_duplicate_rows(df):\r\n",
							"    duplicates = df.where(F.col('SubscriptionId') != '').groupBy(\"SubscriptionId\").count().filter(F.col('count') > 1)\r\n",
							"    result = df.join(duplicates, \"SubscriptionId\", \"inner\")\r\n",
							"    display(result)"
						],
						"outputs": [],
						"execution_count": 103
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"snow_df = snow_df.withColumn('SNOW_WBS', F.upper(F.col('OperationalWBS')))\r\n",
							"snow_df = snow_df.withColumnRenamed('ApplicationName', 'SNOW_APPLICATION')\r\n",
							"snow_df = snow_df.withColumnRenamed('SubscriptionName', 'SNOW_SUBNAME')\r\n",
							"snow_df = snow_df.select('SubscriptionId', 'SNOW_WBS', 'SNOW_APPLICATION', 'SNOW_SUBNAME').where(F.col('SubscriptionId') != '')"
						],
						"outputs": [],
						"execution_count": 104
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"solum_df = solum_df.withColumnRenamed('id', 'SubscriptionId')\r\n",
							"solum_df = solum_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"try:\r\n",
							"    solum_df = solum_df.withColumn('tags', F.from_json(F.col('tags')))\r\n",
							"except:\r\n",
							"    print('Already a json file')\r\n",
							"\r\n",
							"# Expanding the tags list into separate columns\r\n",
							"solum_df = solum_df.withColumn('SOLUM_WBS', F.upper(F.col('tags.WBS')))\r\n",
							"solum_df = solum_df.withColumn('SOLUM_APPLICATION', F.upper(F.col('tags.ServiceNow-App')))\r\n",
							"solum_df = solum_df.withColumnRenamed('name', 'SOLUM_SUBNAME')\r\n",
							"solum_df = solum_df.select('SubscriptionId', 'SOLUM_WBS', 'SOLUM_APPLICATION', 'SOLUM_SUBNAME')"
						],
						"outputs": [],
						"execution_count": 105
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"joined_df = snow_df.join(solum_df, \"SubscriptionId\", \"outer\")"
						],
						"outputs": [],
						"execution_count": 107
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"app_diff_mask = F.col('SNOW_APPLICATION') != F.col('SOLUM_APPLICATION')\r\n",
							"wbs_diff_mask = F.col('SNOW_WBS') != F.col('SOLUM_WBS')\r\n",
							"display(joined_df.where(app_diff_mask))"
						],
						"outputs": [],
						"execution_count": 108
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/check-subscription-quality')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Utilities"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('check-subscription-quality_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "4a957974-7e1a-498a-9332-25de630b2c80"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('check-subscription-quality_notebookSparkPoolIdRef')]",
						"name": "[parameters('check-subscription-quality_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('check-subscription-quality_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 19
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_source_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/*/Extended_v3_ACMMonthlyAmortizedCost_*.parquet/**'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_source_path)"
						],
						"outputs": [],
						"execution_count": 20
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.select('SubscriptionId', 'SubscriptionName').distinct()\r\n",
							"cost_df = cost_df.withColumnRenamed('SubscriptionId', 'CostSubscriptionId')\r\n",
							"cost_df = cost_df.withColumnRenamed('SubscriptionName', 'CostSubscriptionName')"
						],
						"outputs": [],
						"execution_count": 21
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(cost_df)"
						],
						"outputs": [],
						"execution_count": 22
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"subscription_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/latest-optimized.parquet'\r\n",
							"subscription_df = spark.read.format('parquet').load(subscription_path)"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"subscription_df = subscription_df.select('SubscriptionName', 'SubscriptionId').distinct()\r\n",
							"subscription_df = subscription_df.withColumnRenamed('SubscriptionId', 'SnowSubscriptionId')\r\n",
							"subscription_df = subscription_df.withColumnRenamed('SubscriptionName', 'SnowSubscriptionName')"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"joined = cost_df.join(subscription_df, cost_df.CostSubscriptionId == subscription_df.SnowSubscriptionId, 'left')"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(subscription_df.where(F.col('SnowSubscriptionName') == 'S377-Aurora-Development'))"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(joined.where(F.col('SnowSubscriptionName').isNull()))"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"xx = joined.where(F.col('SnowSubscriptionName').isNull()).select('CostSubscriptionName')\r\n",
							"test = xx.join(subscription_df, xx.CostSubscriptionName == subscription_df.SnowSubscriptionName, 'left')"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(test)"
						],
						"outputs": [],
						"execution_count": 29
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/combine-recommendations-and-autofitcombometer')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/RI Recommendations"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('combine-recommendations-and-autofitcombometer_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "a71c40eb-abaf-4c30-93b9-b215f2a4ef56"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('combine-recommendations-and-autofitcombometer_notebookSparkPoolIdRef')]",
						"name": "[parameters('combine-recommendations-and-autofitcombometer_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('combine-recommendations-and-autofitcombometer_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"autofit_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/ccm/autofitcombometer.parquet'\r\n",
							"autofit_df = spark.read.format('parquet').load(autofit_path)"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"rec_path = f'abfss://reservations@{storageAccount}.dfs.core.windows.net/portal-export/FinOps-ReservationRecommendations-VMs-Daily/*/*.csv'\r\n",
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ',',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"rec_df = spark.read.options(**csv_options).csv(rec_path)"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create join keys for each table\r\n",
							"autofit_df = autofit_df.withColumn('AutofitJoinKey', F.concat(F.col('NormalizedSKU'), F.col('HardwareMeter')))\r\n",
							"rec_df = rec_df.withColumn('RecommendationJoinKey', F.concat(F.col('NormalizedSize'), F.col('MeterId')))\r\n",
							"\r\n",
							"autofit_df = autofit_df.select('AutofitJoinKey', 'ResourceLocation', 'ArmSkuName', 'NormalizedSKU')\r\n",
							"\r\n",
							"# Join tables on composite key\r\n",
							"new_df = rec_df.join(autofit_df, rec_df.RecommendationJoinKey == autofit_df.AutofitJoinKey, how='left')\r\n",
							"new_df = new_df.drop('RecommendationJoinKey', 'AutofitJoinKey')"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"new_df = new_df.withColumn(\"NetSavings\", F.col(\"NetSavings\").cast(T.FloatType()))\r\n",
							"new_df = new_df.withColumn(\"RecommendedQuantity\", F.col(\"RecommendedQuantity\").cast(T.FloatType()))\r\n",
							"new_df = new_df.withColumn(\"RecommendedQuantityNormalized\", F.col(\"RecommendedQuantityNormalized\").cast(T.FloatType()))\r\n",
							"new_df = new_df.withColumn(\"TotalCostWithReservedInstances\", F.col(\"TotalCostWithReservedInstances\").cast(T.FloatType()))"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"new_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/ri/ri-recommendations-with-autofit-combometer.parquet\"\r\n",
							"new_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(new_path)"
						],
						"outputs": [],
						"execution_count": 10
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-cumulative-cost')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Prediction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('compute-cumulative-cost_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "4752a462-ba79-45d6-8b32-e1c4806eeed5"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('compute-cumulative-cost_notebookSparkPoolIdRef')]",
						"name": "[parameters('compute-cumulative-cost_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('compute-cumulative-cost_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 22
					},
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.window as W\r\n",
							"import statsmodels.api as sm\r\n",
							"import pandas as pd\r\n",
							"import numpy as np"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define rolling window for accumulation\r\n",
							"window = W.Window.orderBy(\"Date\").rowsBetween(W.Window.unboundedPreceding, 0)"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Prepare Usage data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# # Load usage source\r\n",
							"# cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"# cost_df = spark.read.format('parquet').load(cost_path)\r\n",
							"\r\n",
							"# # Select appropriate columns\r\n",
							"# cost_df = cost_df.select('Date', 'CostInBillingCurrency')\r\n",
							"# cost_df = cost_df.withColumn('Date', F.date_trunc('month', 'Date'))\r\n",
							"# cost_df = cost_df.groupBy('Date').agg(F.sum('CostInBillingCurrency').alias('Cost')).orderBy('Date')\r\n",
							"\r\n",
							"# # Filter away latest month - as we predict cost per month, it will mess up future predictions\r\n",
							"# cost_df = cost_df.filter(F.col('Date') < F.concat(F.date_format(F.current_date(), 'yyyy'), F.lit('-'), F.date_format(F.current_date(), 'MM'), F.lit('-'), F.lit('01')))\r\n",
							"\r\n",
							"# # Compute cumulative cost\r\n",
							"# cost_df = cost_df.withColumn(\"CumulativeCost\", F.sum(\"Cost\").over(window))\r\n",
							"\r\n",
							"# # Convert pyspark df to pandas for OLS model\r\n",
							"# cost_pdf = cost_df.toPandas()\r\n",
							"# cost_pdf.set_index(\"Date\", inplace=True)"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Prepare Billing data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Load billing source\r\n",
							"billing_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/billing/BillingPeriods.parquet'\r\n",
							"billing_df = spark.read.format('parquet').load(billing_path)\r\n",
							"\r\n",
							"# Compute invoiced amount\r\n",
							"billing_df = billing_df \\\r\n",
							"    .withColumn('Cost', F.col('TotalUsage') - F.col('Adjustments') + F.col('AzureMarketplaceServiceCharges')) \\\r\n",
							"    .withColumn('Date', F.to_date(F.col('BillingPeriod'), 'yyyyMM'))\\\r\n",
							"    .select('Cost', 'Date') \\\r\n",
							"    .where(F.col('Date') < '2024-01-01') \\\r\n",
							"    .orderBy('Date')\r\n",
							"\r\n",
							"# Compute cumulative cost\r\n",
							"billing_df = billing_df.withColumn(\"CumulativeCost\", F.sum(\"Cost\").over(window))\r\n",
							"\r\n",
							"# Convert pyspark df to pandas for OLS model\r\n",
							"billing_pdf = billing_df.toPandas()\r\n",
							"billing_pdf.set_index(\"Date\", inplace=True)"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_ols_prediction(input_df, lookback, prediction_interval):\r\n",
							"    input_df['x'] = range(len(input_df))\r\n",
							"\r\n",
							"    # Estimate OLS model\r\n",
							"    y = input_df['Cost'].values if lookback == -1 else input_df['Cost'].tail(lookback)\r\n",
							"    x = input_df['x'].values if lookback == -1 else input_df['x'].tail(lookback)\r\n",
							"    model = sm.OLS(y, sm.add_constant(x))\r\n",
							"    result = model.fit()\r\n",
							"\r\n",
							"    # Configure prediction period\r\n",
							"    future_months = pd.date_range(start=input_df.index[-1], periods=prediction_interval, freq=\"MS\")\r\n",
							"    # future_months = future_months[1:]\r\n",
							"    future_x = np.arange(input_df['x'][-1] + 1, input_df['x'][-1] + prediction_interval + 1)\r\n",
							"\r\n",
							"    # Predict future cost\r\n",
							"    x = sm.add_constant(future_x)\r\n",
							"    predicted_cost = result.predict(x)\r\n",
							"\r\n",
							"    # Create the predicted cost column label\r\n",
							"    column_label = \"FullLookback\" if lookback == -1 else f'{lookback}MonthLookback'\r\n",
							"\r\n",
							"    predicted_df = pd.DataFrame({\"Date\": future_months, f\"PredictedCost{column_label}\": predicted_cost})\r\n",
							"    predicted_df = spark.createDataFrame(predicted_df)\r\n",
							"    predicted_df = predicted_df.withColumn(f'PredictedCumulativeCost{column_label}',  F.sum(f\"PredictedCost{column_label}\").over(window) + input_df['CumulativeCost'][-1])\r\n",
							"    return predicted_df"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"four_month_lookback_df = compute_ols_prediction(billing_pdf, lookback=6, prediction_interval=72)\r\n",
							"eight_month_lookback_df = compute_ols_prediction(billing_pdf, lookback=12, prediction_interval=72)\r\n",
							"twelve_month_lookback_df = compute_ols_prediction(billing_pdf, lookback=24, prediction_interval=72)\r\n",
							"sixteen_month_lookback_df = compute_ols_prediction(billing_pdf, lookback=-1, prediction_interval=72)\r\n",
							"\r\n",
							"billing_df = billing_df.join(four_month_lookback_df, on='Date', how='outer')\r\n",
							"billing_df = billing_df.join(eight_month_lookback_df, on='Date', how='outer')\r\n",
							"billing_df = billing_df.join(twelve_month_lookback_df, on='Date', how='outer')\r\n",
							"billing_df = billing_df.join(sixteen_month_lookback_df, on='Date', how='outer')\r\n",
							"billing_df = billing_df.withColumn('Date', F.to_date('Date'))"
						],
						"outputs": [],
						"execution_count": 28
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Estimate monthly cost of Azure Sentinel once deployed\r\n",
							"COST_OFFSET = 1600000\r\n",
							"\r\n",
							"# Get cumulative cost to date\r\n",
							"cumulative_to_date = billing_df.agg(F.max('CumulativeCost')).collect()[0][0]\r\n",
							"\r\n",
							"\r\n",
							"adjusted_df = billing_df.alias('adjusted_df')\r\n",
							"\r\n",
							"# Rename columns\r\n",
							"for col in adjusted_df.columns:\r\n",
							"    if col.startswith(\"Predicted\"):\r\n",
							"        adjusted_df = adjusted_df.withColumnRenamed(col, \"Adjusted_\" + col)\r\n",
							"\r\n",
							"# Iterate over predicted cost columns\r\n",
							"for col in adjusted_df.columns:\r\n",
							"    if col.startswith(\"Adjusted_PredictedCost\"):\r\n",
							"        adjusted_df = adjusted_df.withColumn(col, \r\n",
							"            F.when(F.col(col).isNull(), None)\r\n",
							"            .when(F.col('Date') <= '2024-04-01', F.col(col))\r\n",
							"            .otherwise(F.col(col) + COST_OFFSET)\r\n",
							"        )\r\n",
							"\r\n",
							"# Iterate over predicted cumulative cost columns\r\n",
							"for col in adjusted_df.columns:\r\n",
							"    if col.startswith(\"Adjusted_PredictedCumulative\"):\r\n",
							"        predicted_cost_col = col.replace('Cumulative', '')\r\n",
							"        adjusted_df = adjusted_df.withColumn(col, F.sum(predicted_cost_col).over(window) + cumulative_to_date)\r\n",
							""
						],
						"outputs": [],
						"execution_count": 29
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/cumulative-cost-prediction.parquet\"\r\n",
							"billing_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": 30
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"adjusted_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/adjusted-cumulative-cost-prediction.parquet\"\r\n",
							"adjusted_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(adjusted_path)"
						],
						"outputs": [],
						"execution_count": 31
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### ARIMA Model"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# def predict_cost(input_df, p, d, q):\r\n",
							"#     model = sm.tsa.ARIMA(input_df[\"Cost\"], order=(p, d, q)).fit()\r\n",
							"#     future_months = pd.date_range(start=input_df.index[-1], periods=72, freq=\"MS\")\r\n",
							"#     predicted_cost = model.predict(start=input_df.index[-1], end=future_months[-1], typ=\"levels\")\r\n",
							"#     predicted_df = pd.DataFrame({\"Date\": future_months, \"PredictedCost\": predicted_cost})\r\n",
							"#     predicted_df = spark.createDataFrame(predicted_df)\r\n",
							"#     return predicted_df"
						],
						"outputs": [],
						"execution_count": 32
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-hub-and-ri-savings')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('compute-hub-and-ri-savings_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "8a60cf0e-7ed6-4072-8d83-9c136c39f479"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('compute-hub-and-ri-savings_notebookSparkPoolIdRef')]",
						"name": "[parameters('compute-hub-and-ri-savings_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('compute-hub-and-ri-savings_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Initialize script"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"from enum import Enum\r\n",
							"from datetime import datetime, timedelta"
						],
						"outputs": [],
						"execution_count": 49
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 50
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"PROD_OFFER_ID = 'MS-AZR-0017P'"
						],
						"outputs": [],
						"execution_count": 51
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"class HUBType(Enum):\r\n",
							"    SQL = \"SQL\"\r\n",
							"    VM = \"VM\"\r\n",
							"\r\n",
							"class HUBCategory(Enum):\r\n",
							"    RI_HUB = \"RI enabled - HUB enabled\"\r\n",
							"    RI_nHUB = \"RI enabled - HUB disabled\"\r\n",
							"    nRI_HUB = \"RI disabled - HUB enabled\"\r\n",
							"    nRI_nHUB = \"RI disabled - HUB disabled\"\r\n",
							"    Unknown = \"Unknown\"\r\n",
							"\r\n",
							"class DBTypes(Enum):\r\n",
							"    DB = \"SQL DB\"\r\n",
							"    MI = \"SQL MI\"\r\n",
							"    VM = \"SQL VM\"\r\n",
							"    Unknown = \"Unknown\"\r\n",
							"\r\n",
							"class LicenseTypes(Enum):\r\n",
							"    Standard = \"Standard License\"\r\n",
							"    Enterprise = \"Enterprise License\"\r\n",
							"    Unknown = \"Unknown\"\r\n",
							"\r\n",
							"class RITypes(Enum):\r\n",
							"    VM = \"VM\"\r\n",
							"    SQL = \"SQL\"\r\n",
							"\r\n",
							"class ReservationType(Enum):\r\n",
							"    S037 = \"S037\"\r\n",
							"    SAP = \"SAP\"\r\n",
							"    Other = \"Other\""
						],
						"outputs": [],
						"execution_count": 52
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load cost data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"date_two_year_ago = datetime.now().date()-timedelta(days=710)"
						],
						"outputs": [],
						"execution_count": 53
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/*/Extended_v3_ACMMonthlyAmortizedCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)\r\n",
							"cost_df = cost_df.where(F.col('Date') >= date_two_year_ago)"
						],
						"outputs": [],
						"execution_count": 54
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.select(\r\n",
							"    'Date', \r\n",
							"    'MeterCategory', \r\n",
							"    'MeterSubCategory', \r\n",
							"    'ResourceName',\r\n",
							"    'ProductName',\r\n",
							"    'CostInBillingCurrency',\r\n",
							"    'Quantity',\r\n",
							"    'UnitOfMeasure', \r\n",
							"    'ResourceId', \r\n",
							"    'ServiceInfo2', \r\n",
							"    'WindowsAHB',\r\n",
							"    'SQLAHB', \r\n",
							"    'benefitName', \r\n",
							"    'WindowsAHB_VCPUS',\r\n",
							"    'SQLAHB_VCPUS',  \r\n",
							"    'ai_DatabaseName',\r\n",
							"    'ai_AHB', \r\n",
							"    'ai_VCPUs',\r\n",
							"    'UnitPrice',\r\n",
							"    'EffectivePrice',\r\n",
							"    'benefitName',\r\n",
							"    'ChargeType'\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df \\\r\n",
							"    .withColumn('Date', F.date_trunc('month', 'Date')) \\\r\n",
							"    .withColumnRenamed('ai_VCPUs', 'VCPUs')"
						],
						"outputs": [],
						"execution_count": 55
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"is_ri_cost = F.col('benefitName').isNotNull()\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('IsRICost', F.when(is_ri_cost, True).otherwise(False))\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('Reservation', \r\n",
							"    F.when(is_ri_cost & F.upper(F.col('benefitName')).like('%S037%'), ReservationType.S037.value)\r\n",
							"    .when(is_ri_cost & F.upper(F.col('benefitName')).like('%S138%'), ReservationType.SAP.value)\r\n",
							"    .when(is_ri_cost, ReservationType.Other.value)\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"cost_df = cost_df.withColumn('RIType', \r\n",
							"    F.when(is_ri_cost & F.col('MeterCategory').like('%Virtual Machines%'), RITypes.VM.value)\r\n",
							"    .when(is_ri_cost & F.col('MeterCategory').like('%SQL%'), RITypes.SQL.value)\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"cost_df = cost_df.withColumn('IsReservationUnused', \r\n",
							"    F.when(is_ri_cost & (F.col('ChargeType') == 'UnusedReservation'), True)\r\n",
							"    .when(is_ri_cost, False)\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('RICostSavings', F.when(is_ri_cost, (F.col('UnitPrice') - F.col('EffectivePrice')) * F.col('Quantity')).otherwise(0))\r\n",
							"cost_df = cost_df.withColumn('RIEffectiveCost', F.when(is_ri_cost, F.col('EffectivePrice') * F.col('Quantity')).otherwise(0))"
						],
						"outputs": [],
						"execution_count": 56
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"is_vm_cost = (F.col('ResourceId').like('%/virtualMachines/%') | F.col('ResourceId').like('%/virtualMachineScaleSets/%')) \\\r\n",
							"    & (F.col('MeterSubCategory').contains('Windows') | (F.col('ServiceInfo2') == 'Windows Server BYOL')) \\\r\n",
							"    & ~F.col('ResourceName').like('CVD-%')\r\n",
							"\r\n",
							"is_sql_cost = (F.col('ResourceId').like('%Microsoft.Sql/servers%') & F.col('MeterCategory').like('SQL%')) \\\r\n",
							"    | (F.col('ResourceId').like('%Microsoft.Sql/managedInstances%') & F.col('MeterCategory').like('SQL%')) \\\r\n",
							"    | ((F.col('MeterCategory') == 'Virtual Machines Licenses') & F.col('MeterSubCategory').like('SQL Server%'))"
						],
						"outputs": [],
						"execution_count": 57
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.withColumn('HUBType',\r\n",
							"    F.when(is_vm_cost, F.lit(HUBType.VM.value))\r\n",
							"    .when(is_sql_cost, F.lit(HUBType.SQL.value))\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('DBType',\r\n",
							"    F.when(is_vm_cost, F.lit(None))\r\n",
							"    .when(is_sql_cost & F.col('ResourceId').like('%Microsoft.Sql/servers%'), DBTypes.DB.value)\r\n",
							"    .when(is_sql_cost & F.col('ResourceId').like('%Microsoft.Sql/managedInstances%'), DBTypes.MI.value)\r\n",
							"    .when(is_sql_cost & F.col('ResourceId').like('%Microsoft.Compute/virtualMachines%'), DBTypes.VM.value)\r\n",
							"    .otherwise(F.lit(None))\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('LicenseType',\r\n",
							"    F.when(is_sql_cost & (F.col('ProductName').like('%Standard%') | F.col('ProductName').like('%General%')), LicenseTypes.Standard.value)\r\n",
							"    .when(is_sql_cost & (F.col('ProductName').like('%Enterprise%') | F.col('ProductName').like('%Critical%')), LicenseTypes.Enterprise.value)\r\n",
							"    .when(is_sql_cost, LicenseTypes.Unknown.value)\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('PricesheetJoinKey', \r\n",
							"    F.when(is_vm_cost,\r\n",
							"        F.concat(\r\n",
							"            F.lit('Windows Server'),\r\n",
							"            F.when(F.col('MeterSubCategory') == 'Windows Server Burst', ' Burst - ').otherwise(' - '), \r\n",
							"            F.col('VCPUs'), \r\n",
							"            F.lit(' vCPU VM License')\r\n",
							"        )\r\n",
							"    )\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.MI.value) & (F.col('LicenseType') == LicenseTypes.Standard.value), 'SQL Managed Instance General Purpose - SQL License - vCore')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.MI.value) & (F.col('LicenseType') == LicenseTypes.Enterprise.value), 'SQL Managed Instance Business Critical - SQL License - vCore')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.DB.value) & (F.col('LicenseType') == LicenseTypes.Standard.value), 'SQL Database Single/Elastic Pool General Purpose - SQL License - vCore')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.DB.value) & (F.col('LicenseType') == LicenseTypes.Enterprise.value), 'SQL Database Single/Elastic Pool Business Critical - SQL License - vCore')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.VM.value) & (F.col('LicenseType') == LicenseTypes.Standard.value) & (F.col('VCPUs') < 5), 'SQL Server Standard - 1-4 vCPU VM License')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.VM.value) & (F.col('LicenseType') == LicenseTypes.Enterprise.value) & (F.col('VCPUs') < 5), 'SQL Server Enterprise - 1-4 vCPU VM License')\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.VM.value) & (F.col('LicenseType') == LicenseTypes.Standard.value) & (F.col('VCPUs') >= 5), F.concat(F.lit('SQL Server Standard - '), F.col('VCPUs'), F.lit(' vCPU VM License')))\r\n",
							"    .when(is_sql_cost & (F.col('DBType') == DBTypes.VM.value) & (F.col('LicenseType') == LicenseTypes.Enterprise.value) & (F.col('VCPUs') >= 5), F.concat(F.lit('SQL Server Enterprise - '), F.col('VCPUs'), F.lit(' vCPU VM License')))\r\n",
							"    .otherwise(None)\r\n",
							")"
						],
						"outputs": [],
						"execution_count": 58
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"is_valid_vm_cost = is_vm_cost & (F.col('VCPUs') != 0)\r\n",
							"is_valid_sql_cost = is_sql_cost & ~F.col('UnitOfMeasure').like('%GB%') & ~F.col('UnitOfMeasure').like('%/Day%') & (F.col('MeterSubCategory') != 'SQL Server Express Edition')\r\n",
							"\r\n",
							"cost_df = cost_df.where(is_ri_cost | is_valid_vm_cost | is_valid_sql_cost)"
						],
						"outputs": [],
						"execution_count": 59
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df \\\r\n",
							"    .select(\r\n",
							"        'Date', \r\n",
							"        'ResourceName', \r\n",
							"        'CostInBillingCurrency', \r\n",
							"        'Quantity', \r\n",
							"        'WindowsAHB', \r\n",
							"        'SQLAHB', \r\n",
							"        'WindowsAHB_VCPUS', \r\n",
							"        'SQLAHB_VCPUS', \r\n",
							"        'VCPUs', \r\n",
							"        'IsRICost', \r\n",
							"        'Reservation', \r\n",
							"        'RIType', \r\n",
							"        'IsReservationUnused', \r\n",
							"        'RICostSavings', \r\n",
							"        'RIEffectiveCost', \r\n",
							"        'HUBType',\r\n",
							"        'DBType', \r\n",
							"        'PricesheetJoinKey'\r\n",
							"    ) \\\r\n",
							"    .groupBy('Date', 'ResourceName', 'WindowsAHB', 'SQLAHB', 'VCPUs', 'WindowsAHB_VCPUS', 'SQLAHB_VCPUS', 'IsRICost', 'Reservation', 'RIType', 'IsReservationUnused', 'HUBType', 'DBType', 'PricesheetJoinKey') \\\r\n",
							"    .agg(F.sum('Quantity').alias('Quantity'), F.sum('CostInBillingCurrency').alias('ResourceCost'), F.sum('RICostSavings').alias('RICostSavings'), F.sum('RIEffectiveCost').alias('RIEffectiveCost'))\\\r\n",
							"    .orderBy('Date')"
						],
						"outputs": [],
						"execution_count": 60
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create dummy date column for pricesheet join operation\r\n",
							"cost_df = cost_df.withColumn(\"TempDate\", F.date_format(\"Date\", \"yyyyMM\"))"
						],
						"outputs": [],
						"execution_count": 61
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"##### Fetch old pricesheet"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"old_pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/v2_schema/pricesheet-2022*.parquet'\r\n",
							"old_pricesheet_df = spark.read.format('parquet').load(old_pricesheet_path)\r\n",
							"old_pricesheet_df = old_pricesheet_df.where(F.col('offerId') == PROD_OFFER_ID)\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumnRenamed('meterName', 'ProductMapping')\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumnRenamed('unitOfMeasure', 'UnitOfMeasure')\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumnRenamed('unitPrice', 'UnitPrice')\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumnRenamed('billingPeriodId', 'BillingPeriodId')\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumn('UnitQuantity', F.split('UnitOfMeasure', ' ')[0])\r\n",
							"old_pricesheet_df = old_pricesheet_df.withColumn('PricePerUnit', F.col('UnitPrice') / F.col('UnitQuantity'))\r\n",
							"old_pricesheet_df = old_pricesheet_df.select('ProductMapping', 'UnitOfMeasure', 'UnitQuantity', 'UnitPrice', 'PricePerUnit', 'BillingPeriodId')"
						],
						"outputs": [],
						"execution_count": 62
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							" ##### Fetch new pricesheet"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"new_pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/FinOps-Pricesheet-Monthly/*/*/*.csv'\r\n",
							"new_pricesheet_df = spark.read.csv(new_pricesheet_path, header=True, inferSchema=True)\r\n",
							"new_pricesheet_df = new_pricesheet_df.where(F.col('OfferId') == PROD_OFFER_ID)\r\n",
							"new_pricesheet_df = new_pricesheet_df.withColumn('FormattedDate', F.to_date(new_pricesheet_df.EffectiveStartDate, 'MM/dd/yyy HH:mm:ss'))\r\n",
							"new_pricesheet_df = new_pricesheet_df.withColumn('BillingPeriodId', F.date_format('FormattedDate', \"yyyyMM\"))\r\n",
							"new_pricesheet_df = new_pricesheet_df.withColumn('UnitQuantity', F.split('UnitOfMeasure', ' ')[0])\r\n",
							"new_pricesheet_df = new_pricesheet_df.withColumn('PricePerUnit', F.col('UnitPrice') / F.col('UnitQuantity'))\r\n",
							"new_pricesheet_df = new_pricesheet_df.withColumnRenamed('Product', 'ProductMapping')\r\n",
							"new_pricesheet_df = new_pricesheet_df.select('ProductMapping', 'UnitOfMeasure', 'UnitQuantity', 'UnitPrice', 'PricePerUnit', 'BillingPeriodId')"
						],
						"outputs": [],
						"execution_count": 63
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"##### Combine pricesheets"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pricesheet_df = new_pricesheet_df.union(old_pricesheet_df)"
						],
						"outputs": [],
						"execution_count": 64
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.join(pricesheet_df, (pricesheet_df.ProductMapping == cost_df.PricesheetJoinKey) & (pricesheet_df.BillingPeriodId == cost_df.TempDate), \"left\")\r\n",
							"cost_df = cost_df.drop('PricesheetJoinKey', 'TempDate')\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('PAYGLicenseCost', F.col('Quantity') * F.col('PricePerUnit'))"
						],
						"outputs": [],
						"execution_count": 65
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.withColumn('CostWithHub', \r\n",
							"    F.when((F.col('WindowsAHB') == 'Enabled') | (F.col('SQLAHB') == 'Enabled'), F.col('ResourceCost'))\r\n",
							"    .when((F.col('WindowsAHB') == 'Not Enabled') | (F.col('SQLAHB') == 'Not Enabled'), F.col('ResourceCost') - F.col('PAYGLicenseCost'))\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.withColumn('UnlockedSavings', F.when((F.col('WindowsAHB') == 'Enabled') | (F.col('SQLAHB') == 'Enabled'), F.col('PAYGLicenseCost')).otherwise(0))\r\n",
							"cost_df = cost_df.withColumn('PotentialSavings', F.when((F.col('WindowsAHB') == 'Not Enabled') | (F.col('SQLAHB') == 'Not Enabled'), F.col('ResourceCost') - F.col('CostWithHub')).otherwise(0))"
						],
						"outputs": [],
						"execution_count": 66
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.drop('UnitOfMeasure', 'UnitQuantity', 'UnitPrice', 'PricePerUnit', 'ProductMapping', 'BillingPeriodId')"
						],
						"outputs": [],
						"execution_count": 67
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Store result in optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/hub/hub-and-ri-savings-past-two-years.parquet\"\r\n",
							"cost_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": 68
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Finding SQL Server related cost\r\n",
							"\r\n",
							"SQL cost are grouped into three categories:\r\n",
							"\r\n",
							"1. SQL Virtual Machine - Cost with _MeterCategory_ like **Virtual Machines Licenses** and _MeterSubCategory_ like **SQL Server%** (besides SQL Server Express)\r\n",
							"2. SQL Managed Instance - Cost with _ResourceId_ like **Microsoft.Sql/managedInstances**\r\n",
							"3. SQL Database - Cost with _ResourceId_ like **Microsoft.Sql/servers**\r\n",
							"\r\n",
							"\r\n",
							"### SQL Database\r\n",
							"\r\n",
							"This category will include _MeterCategories_ like SQL Managed Instance, Microsoft Defender for Cloud, SQL Database and Azure Synapse Analytics.\r\n",
							"\r\n",
							"Should exclude _Microsoft Defender for Cloud_ and _Azure Synapse Analytics_ as these meter categories is not applicable for HUB\r\n",
							"\r\n",
							"### SQL Managed Instance\r\n",
							"\r\n",
							"This category will include _MeterCategories_ like SQL Managed Instance and Microsoft Defender for Cloud.\r\n",
							"\r\n",
							"Should exclude _Microsoft Defender for Cloud_ as this meter category is not applicable for HUB\r\n",
							"\r\n",
							"\r\n",
							"## SQL Cost with VCPU\r\n",
							"\r\n",
							"There is a lot of cost associated with SQL that has VCPUs set to 0. \r\n",
							"If the unit of measure for these cost items is inspected, it varies between _x hours_, _x / day_ and _x GB/month_\r\n",
							"We would only be interested in cost with unit of measure equal to _x hours_ (corresponds to SQL serverless pools), whereas the other corresponds to memory/DTU cost. "
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## VM Related Cost\r\n",
							"\r\n",
							"#### Comparing the two following queries\r\n",
							"\r\n",
							"1. _ResourceId_ includes **/virtualMachines/** or **/virtualMachineScaleSets/** (dataset1)\r\n",
							"2. _MeterCategory_ is **Virtual Machines** or **Virtual Machines Licenses** (dataset2)\r\n",
							"\r\n",
							"Note: both queries also checks that _MeterSubCategory_ includes **Windows** or _ServiceInfo2_ is **Windows Server BYOL** to only account for Windows VMs\r\n",
							"\r\n",
							"Based on the queries above, the resulting counts for november 2023 where:\r\n",
							"\r\n",
							"1. 135,453 cost items\r\n",
							"2. 136,203 cost items\r\n",
							"\r\n",
							"There is a small difference between these two subsets.\r\n",
							"\r\n",
							"Analysis of certain dataset columns yielded the following results:\r\n",
							"\r\n",
							"**MeterSubCategory** column in dataset2 includes the following values that are not present in dataset1\r\n",
							"- Av2 Series Windows\r\n",
							"- Ev3/ESv3 Series Windows\r\n",
							"\r\n",
							"**ProductName** column in dataset2 includes the following values that are not present in dataset1\r\n",
							"- Virtual Machines Ev3/ESv3 Series Windows - E4 v3/E4s v3 - EU North\r\n",
							"- Virtual Machines Av2 Series Windows - A1 v2 - NO East\r\n",
							"- Virtual Machines F/FS Series Windows - F8/F8s - EU North\r\n",
							"\r\n",
							"**MeterName** column in dataset2 includes the following values that are not present in dataset1\r\n",
							"- A1 v2\r\n",
							"\r\n",
							"**ai_ServiceType** column in dataset2 includes the following values that are not present in dataset1\r\n",
							"- Standard_A1_v2\r\n",
							"- Standard_F8\r\n",
							"- Standard_E4_v3\r\n",
							"\r\n",
							"After further inspection of the above dataset differences, all related costs to the odd values for columns in dataset2, they have the following facts in common:\r\n",
							"\r\n",
							"- Very small subset of cost\r\n",
							"- All are PAYG cost (no HUB enabled)\r\n",
							"- The resource id of all these costs have the form: /subscriptions/df89af9f-9074-40b4-a620-1d35c0eea0a4/resourceGroups/rg-observability-dev/providers/Microsoft.Batch/batchAccounts/baobservabilitydev/pools/poolobservabilitydev\r\n",
							"- All costs are associated with Microsoft.Batch consumed service type\r\n",
							"\r\n",
							"This is why it is not covered by the dataset that requires virtualMachines or virtualMachineScaleSets to be part of the resource identifier\r\n",
							"\r\n",
							"\r\n",
							""
						]
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-overcharged-cost')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Pricesheet"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('compute-overcharged-cost_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "9067f396-e573-471d-83ae-5ffe8dbe0495"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('compute-overcharged-cost_notebookSparkPoolIdRef')]",
						"name": "[parameters('compute-overcharged-cost_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('compute-overcharged-cost_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 153
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 154
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"PROD_OFFER_ID = 'MS-AZR-0017P'"
						],
						"outputs": [],
						"execution_count": 155
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"old_pricesheet_cols = ['meterId', 'meterName', 'unitOfMeasure', 'partNumber', 'unitPrice', 'currencyCode', 'includedQuantity', 'offerId']\r\n",
							"new_pricesheet_cols = ['MeterID', 'MeterName', 'UnitOfMeasure', 'PartNumber', 'UnitPrice', 'CurrencyCode', 'IncludedQuantity', 'OfferID']"
						],
						"outputs": [],
						"execution_count": 156
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/v1_schema/pricesheet-*.parquet'\r\n",
							"pricesheet_df = spark.read.format('parquet').load(pricesheet_path)\r\n",
							"pricesheet_df = pricesheet_df.where(F.col('offerId') == PROD_OFFER_ID)\r\n",
							"pricesheet_df = pricesheet_df.select(*old_pricesheet_cols)\r\n",
							"pricesheet_df = pricesheet_df \\\r\n",
							"        .withColumnRenamed('meterId', 'MeterID') \\\r\n",
							"        .withColumnRenamed('meterName', 'MeterName') \\\r\n",
							"        .withColumnRenamed('unitOfMeasure', 'UnitOfMeasure') \\\r\n",
							"        .withColumnRenamed('partNumber', 'PartNumber') \\\r\n",
							"        .withColumnRenamed('unitPrice', 'UnitPrice') \\\r\n",
							"        .withColumnRenamed('currencyCode', 'CurrencyCode') \\\r\n",
							"        .withColumnRenamed('includedQuantity', 'IncludedQuantity') \\\r\n",
							"        .withColumnRenamed('offerId', 'OfferID')"
						],
						"outputs": [],
						"execution_count": 163
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"new_test = pricesheet_df.groupBy('PartNumber', 'OfferID', 'UnitOfMeasure').agg(F.min('UnitPrice').alias('UnitPrice'))"
						],
						"outputs": [],
						"execution_count": 168
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# display(new_test.where(F.col('PartNumber') == 'AAJ-86987'))\r\n",
							"display(new_test.where(F.col('UnitPrice') == 0))"
						],
						"outputs": [],
						"execution_count": 172
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"duplicates = new_test.groupBy('PartNumber').count().filter('count > 1')\r\n",
							"display(duplicates)"
						],
						"outputs": [],
						"execution_count": 170
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(new_test)"
						],
						"outputs": [],
						"execution_count": 169
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(pricesheet_df.where(F.col('PartNumber') == '3Q7-00088'))"
						],
						"outputs": [],
						"execution_count": 165
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from pyspark.sql.functions import min\r\n",
							"\r\n",
							"# assuming your original dataframe is named 'df'\r\n",
							"new_df = df.groupBy('ID').agg(min('price').alias('price')).select('ID', 'price')"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def add_prefix_to_cols(df, prefix):\r\n",
							"    return df.select([F.col(c).alias(f'{prefix}_'+c) for c in df.columns])"
						],
						"outputs": [],
						"execution_count": 141
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_old_pricesheet(year, month):\r\n",
							"    # Read old pricesheet\r\n",
							"    pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/pricesheet-{year}{month:02d}.parquet'\r\n",
							"    pricesheet_df = spark.read.format('parquet').load(pricesheet_path)\r\n",
							"    pricesheet_df = pricesheet_df.where(F.col('offerId') == PROD_OFFER_ID)\r\n",
							"    pricesheet_df = pricesheet_df.select(*old_pricesheet_cols)\r\n",
							"\r\n",
							"    # Convert old schema to new schema\r\n",
							"    pricesheet_df = pricesheet_df \\\r\n",
							"        .withColumnRenamed('meterId', 'MeterID') \\\r\n",
							"        .withColumnRenamed('meterName', 'MeterName') \\\r\n",
							"        .withColumnRenamed('unitOfMeasure', 'UnitOfMeasure') \\\r\n",
							"        .withColumnRenamed('partNumber', 'PartNumber') \\\r\n",
							"        .withColumnRenamed('unitPrice', 'UnitPrice') \\\r\n",
							"        .withColumnRenamed('currencyCode', 'CurrencyCode') \\\r\n",
							"        .withColumnRenamed('includedQuantity', 'IncludedQuantity') \\\r\n",
							"        .withColumnRenamed('offerId', 'OfferID')\r\n",
							"\r\n",
							"    # Prefix pricesheet columns with p to distinguish pricesheet columns when combined with usage file\r\n",
							"    pricesheet_df = add_prefix_to_cols(pricesheet_df, 'p')\r\n",
							"    return pricesheet_df"
						],
						"outputs": [],
						"execution_count": 142
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_new_pricesheet(date_range):\r\n",
							"    # Load new pricesheet\r\n",
							"    new_pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/FinOps-Pricesheet-Monthly/{date_range}/*/*.csv'\r\n",
							"    pricesheet_df = spark.read.csv(new_pricesheet_path, header=True, inferSchema=True)\r\n",
							"    pricesheet_df = pricesheet_df.where(F.col('OfferID') == PROD_OFFER_ID)\r\n",
							"    pricesheet_df = pricesheet_df.select(*new_pricesheet_cols)\r\n",
							"\r\n",
							"    # Prefix pricesheet columns with p to distinguish pricesheet columns when combined with usage file\r\n",
							"    pricesheet_df = add_prefix_to_cols(pricesheet_df, 'p')\r\n",
							"    return pricesheet_df"
						],
						"outputs": [],
						"execution_count": 143
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def merge_cost_and_price(cost_df, price_df):\r\n",
							"    # Rename pricesheet columns to be prefixed with temp\r\n",
							"    price_df = add_prefix_to_cols(price_df, 'temp')\r\n",
							"\r\n",
							"    # Join temporary part number column on usage file part number \r\n",
							"    cost_df = cost_df.join(price_df, (cost_df.PartNumber == price_df.temp_p_PartNumber), how='left')\r\n",
							"\r\n",
							"    # At this point the joined table will contain duplicate pricesheet column (p_ and temp_p_)\r\n",
							"    for col in new_pricesheet_cols:\r\n",
							"        p_col = f\"p_{col}\"\r\n",
							"        temp_col = f\"temp_{p_col}\"\r\n",
							"\r\n",
							"        # Merge individual pricesheet columns\r\n",
							"        cost_df = cost_df.withColumn(p_col, F.coalesce(cost_df[p_col], cost_df[temp_col]))\r\n",
							"\r\n",
							"        # Drop the temp column after merge (only left with p_ column)\r\n",
							"        cost_df = cost_df.drop(temp_col)\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 144
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Load usage file\r\n",
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)\r\n",
							"\r\n",
							"# Only look at usage data from the initial price increase (first of march 2021)\r\n",
							"cost_df = cost_df.where(F.col('Date') >= '2021-02-01')\r\n",
							"\r\n",
							"# Filter out unassigned cost\r\n",
							"cost_df = cost_df.where(F.col('MeterId') != '00000000-0000-0000-0000-000000000000')\r\n",
							"cost_df = cost_df.select('SubscriptionName', 'ResourceGroup', 'ResourceLocation', 'Date', 'ProductName', 'MeterCategory', 'MeterSubCategory', 'MeterId', 'MeterName', 'MeterRegion', 'UnitOfMeasure', 'Quantity', 'EffectivePrice', 'CostInBillingCurrency', 'ResourceName', 'UnitPrice', 'PartNumber')"
						],
						"outputs": [],
						"execution_count": 145
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Set initial pricesheet to February 2021 - The month ahead of 9% price increase\r\n",
							"pricesheet_df = load_old_pricesheet(2021, 2)\r\n",
							"combined_df = cost_df.join(pricesheet_df, cost_df.PartNumber == pricesheet_df.p_PartNumber, how='left')"
						],
						"outputs": [],
						"execution_count": 146
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Merge usage data with old pricesheet data\r\n",
							"\r\n",
							"END_YEAR = 2022\r\n",
							"END_MONTH = 12\r\n",
							"\r\n",
							"INITIAL_YEAR = 2021\r\n",
							"INITIAL_MONTH = 4\r\n",
							"\r\n",
							"year = INITIAL_YEAR\r\n",
							"month = INITIAL_MONTH\r\n",
							"\r\n",
							"while year < END_YEAR or (year == END_YEAR and month <= END_MONTH):\r\n",
							"    print(f\"Loading pricesheet - year: {year} - month: {month}\")\r\n",
							"    next_pricesheet = load_old_pricesheet(year, month)\r\n",
							"    combined_df = merge_cost_and_price(combined_df, next_pricesheet)\r\n",
							"    if (month == 12):\r\n",
							"        year += 1\r\n",
							"        month = 1\r\n",
							"    else:\r\n",
							"        month += 1"
						],
						"outputs": [],
						"execution_count": 147
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Merge usage data with new pricesheet data\r\n",
							"\r\n",
							"new_pricesheet_root = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/FinOps-Pricesheet-Monthly'\r\n",
							"paths = mssparkutils.fs.ls(new_pricesheet_root)\r\n",
							"date_ranges = [files.name for files in paths]\r\n",
							"\r\n",
							"for date_range in date_ranges:\r\n",
							"    print(f\"Loading pricesheet - date range: {date_range}\")\r\n",
							"    next_pricesheet = load_new_pricesheet(date_range)\r\n",
							"    combined_df = merge_cost_and_price(combined_df, next_pricesheet)"
						],
						"outputs": [],
						"execution_count": 149
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"display(combined_df.where(F.col('p_unitPrice').isNull()).count())"
						],
						"outputs": [],
						"execution_count": 150
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(combined_df.columns)"
						],
						"outputs": [],
						"execution_count": 115
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(combined_df.select('UnitOfMeasure', 'p_UnitOfMeasure').limit(100))"
						],
						"outputs": [],
						"execution_count": 135
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"5765059\r\n",
							"\r\n",
							"2646100"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(combined_df.where(F.col('p_unitPrice').isNull() & (F.col('Date') < '2021-03-01')))"
						],
						"outputs": [],
						"execution_count": 83
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"display(combined_df.where(F.col('p_unitPrice').isNull()).select('Date').distinct())"
						],
						"outputs": [],
						"execution_count": 84
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/compute-savings-plan-savings')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('compute-savings-plan-savings_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "383dfd75-f023-476f-9335-c1bb2cf23bee"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('compute-savings-plan-savings_notebookSparkPoolIdRef')]",
						"name": "[parameters('compute-savings-plan-savings_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('compute-savings-plan-savings_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Amortized Cost\r\n",
							"\r\n",
							"### Savings Plan\r\n",
							"\r\n",
							"Looking up cost with **PriceModel** set to _SavingsPlan_ yield two kinds of cost:\r\n",
							"- Has **ChargeType** set to _Usage_ where EffectivePrice < UnitPrice\r\n",
							"- Has **ChargeType** set to _UnusedSavingsPlan_ (MeterCategory = Unassigned) where EffectiveCost is 100 and CostInBillingCurrency is 0 (is this corresponding to the unused parts of the savingsplan?)\r\n",
							"\r\n",
							"### Reservation\r\n",
							"\r\n",
							"Looking at **IsRIUsage** set to _RI Usage_\r\n",
							"\r\n",
							"There are two distinct charge types -> **Usage** and **UnusedReservation**\r\n",
							"\r\n",
							"## Actual Cost\r\n",
							"\r\n",
							"### Savings Plan\r\n",
							"\r\n",
							"Looking up cost with **PriceModel** set to _SavingsPlan_ yield two kinds of cost:\r\n",
							"- Has **ChargeType** set to _Usage_ where EffectivePrice and CostInBillingCurrency are 0\r\n",
							"- Has **ChargeType** set to _Purchase_ (MeterCategory = Unassigned) where CostInBillingCurrency = EffectivePrice = UnitPrice is 73000 which corresponds to 100 NOK/Hour for roughly 30 days\r\n",
							"\r\n",
							"### Reservation\r\n",
							"\r\n",
							"Looking at **IsRIUsage** set to _RI Usage_\r\n",
							"\r\n",
							"There are three distinct charge types -> **Usage**, **Purchase** and **Refund**\r\n",
							"- ChargeType=Purchase --> EffectivePrice=UnitPrice and UnitPrice*Quantity = CostInBillingCurrency -> add up to get total cost for RI purchase\r\n",
							"- ChargeType=Refund --> Same as above, just negative (since its money back) \r\n",
							"- ChargeType=Usage --> cost is always 0 since its covered by RI purchases"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"from datetime import datetime, timedelta"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"PROD_OFFER_ID = 'MS-AZR-0017P'"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 27
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/20240101-20240131/Extended_v3_ACMMonthlyAmortizedCost_20240101-20240131.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 65
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-converted/20240101-20240131.parquet'\r\n",
							"pricesheet_df = spark.read.format('parquet').load(pricesheet_path)\r\n",
							"pricesheet_df = pricesheet_df.where((F.col('OfferID') == PROD_OFFER_ID) & (F.col('PriceType') == 'SavingsPlan'))"
						],
						"outputs": [],
						"execution_count": 64
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"p3y_df = pricesheet_df.where(F.col('Term') == 'P3Y')\r\n",
							"p1y_df = pricesheet_df.where(F.col('Term') == 'P1Y')"
						],
						"outputs": [],
						"execution_count": 66
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"p3y_df = p3y_df.withColumn('NormalizedUnit', F.regexp_extract('UnitOfMeasure', r'^(\\d+)', 1).cast('integer'))\r\n",
							"p3y_df = p3y_df.withColumn('NormalizedMemoryFactor', \r\n",
							"    F.when(F.col('UnitOfMeasure').contains('TiB'), 1024) # Standard measure in usage file is GiB --> convertion factor between TiB and Gib is 1024\r\n",
							"    .when(F.col('UnitOfMeasure').contains(\"PiB\"), 1048576) # Standard measure in usage file is GiB --> convertion factor between PiB and Gib is 1048576\r\n",
							"    .when(F.col('UnitOfMeasure').contains(\"TB\"), 1000) # Standard measure in usage file is GB --> convertion factor between TB and Gb is 1000\r\n",
							"    .when(F.col('UnitOfMeasure').contains(\"PB\"), 1000000) # Standard measure in usage file is GB --> convertion factor between PB and Gib is 1000000\r\n",
							"    .otherwise(1)\r\n",
							")\r\n",
							"p3y_df = p3y_df.withColumn('NormalizedP3YUnitPrice', F.col('UnitPrice') / (F.col('NormalizedUnit') * F.col('NormalizedMemoryFactor')))\r\n",
							"\r\n",
							"p3y_df = p3y_df.select('PartNumber', 'NormalizedP3YUnitPrice')"
						],
						"outputs": [],
						"execution_count": 67
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Find eligible SP cost and compute potential savings\r\n",
							"\r\n",
							"- Virtual Machines cost have unit of measure on format `x Hours` in pricesheet --> must divide UnitPrice by `x`\r\n",
							"- Azure Function cost have unit of measure on format `x TiB Hours` or `x Hours` --> must divide UnitPrice by `x` then if GiB --> leave cost as-is, if TiB --> divide UnitPrice by 1024\r\n",
							"- Azure App Service have unit of measure on format `x Hours` in pricesheet --> must divide UnitPrice by `x`\r\n",
							"- Azure Container Instance cost have unit of measure on format `x TB Hours` or `x Hours` --> must divide UnitPrice by `x` then if GB --> leave cost as-is, if TB --> divide UnitPrice by 1000\r\n",
							"- Azure Container Apps cost have unit of measure on format `x PiB Hours` or `x Seconds` --> must divide UnitPrice by `x` then if GiB --> leave cost as-is, if PiB --> divide UnitPrice by 1 048 576"
						]
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							""
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sp_enabled = (F.col('PricingModel') == 'SavingsPlan') & (F.col('ChargeType') == 'Usage')\r\n",
							"is_ondemand = (F.col('PricingModel') == 'OnDemand') & (F.col('ChargeType') == 'Usage')\r\n",
							"is_vm_compute = (F.col('MeterCategory') == 'Virtual Machines') & ~(F.col('MeterSubCategory').contains('Av1'))\r\n",
							"is_aas_compute = (F.col('MeterCategory') == 'Azure App Service') & (F.col('MeterSubCategory').isin(['Premium v3', 'Isolated v2']))\r\n",
							"is_af_compute = (F.col('MeterCategory') == 'Functions') & (F.col('MeterSubCategory') == 'Premium')\r\n",
							"is_aci_compute = (F.col('MeterCategory') == 'Container Instances')\r\n",
							"is_aca_compute = (F.col('MeterCategory') == 'Azure Container Apps')\r\n",
							"is_sp_eligible = is_vm_compute | is_aas_compute | is_af_compute | is_aci_compute | is_aca_compute\r\n",
							"\r\n",
							"sp_df = cost_df.withColumn('SPStatus', \r\n",
							"    F.when(sp_enabled, SavingsPlanStatus.Enabled.value)\r\n",
							"    .when(is_ondemand & is_sp_eligible, SavingsPlanStatus.NotEnabled.value)\r\n",
							"    .otherwise(SavingsPlanStatus.NotSupported.value)\r\n",
							")\r\n",
							"sp_df = sp_df.join(p3y_df, 'PartNumber', 'left')\r\n",
							"sp_df = sp_df.withColumn('Savings', (F.col('UnitPrice') - F.col('NormalizedP3YUnitPrice')) * F.col('Quantity'))"
						],
						"outputs": [],
						"execution_count": 88
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute existing SP savings"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.where(F.col('PricingModel') == 'SavingsPlan')\r\n",
							"cost_df = cost_df.withColumn('EffectiveCost', F.col('EffectivePrice') * F.col('Quantity'))\r\n",
							"cost_df = cost_df.withColumn('CostSavings', (F.col('UnitPrice') - F.col('EffectivePrice')) * F.col('Quantity'))\r\n",
							"\r\n",
							"# Compute total savings for savings plan\r\n",
							"display(cost_df.where(F.col('ChargeType') == 'Usage').agg(F.sum('CostSavings')))\r\n",
							"\r\n",
							"# Compute cost of unused savings plan\r\n",
							"display(cost_df.where(F.col('ChargeType') == 'UnusedSavingsPlan').agg(F.sum('EffectiveCost')))"
						],
						"outputs": [],
						"execution_count": 28
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/cost-extend-utilities')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Extension"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('cost-extend-utilities_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "6fe357af-f74e-4c5f-a24c-23c65145f59b"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('cost-extend-utilities_notebookSparkPoolIdRef')]",
						"name": "[parameters('cost-extend-utilities_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('cost-extend-utilities_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112,
						"automaticScaleJobs": true
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"from datetime import datetime\r\n",
							"import calendar\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T\r\n",
							"import warnings\r\n",
							"from enum import Enum"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"PROD_OFFER_ID = 'MS-AZR-0017P'"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"class AHBStatus(Enum):\r\n",
							"    Enabled = \"Enabled\"\r\n",
							"    NotEnabled = \"Not Enabled\"\r\n",
							"    NotSupported = \"Not Supported\"\r\n",
							"\r\n",
							"class SavingsPlanStatus(Enum):\r\n",
							"    Enabled = \"Enabled\"\r\n",
							"    NotEnabled = \"Not Enabled\"\r\n",
							"    NotSupported = \"Not Supported\""
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {},
						"source": [
							"def get_last_day_prev_month(to_date):\r\n",
							"    current_month = int(to_date[4:6])\r\n",
							"    current_year = int(to_date[:4])\r\n",
							"\r\n",
							"    previous_month = (current_month - 1) if current_month > 1 else 12\r\n",
							"    previous_year = current_year if current_month > 1 else (current_year - 1)\r\n",
							"\r\n",
							"    # Calculating the last day of the month\r\n",
							"    last_day = calendar.monthrange(previous_year, previous_month)[1]\r\n",
							"\r\n",
							"    # Creating a string date for last month\r\n",
							"    return f\"{previous_year}-{str(previous_month).zfill(2)}-{str(last_day).zfill(2)}\""
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def cost_extend_additional_info(cost_df):\r\n",
							"    # Extend AdditionalInfo Column\r\n",
							"    cost_df = cost_df.withColumn('AdditionalInfo', F.from_json('AdditionalInfo', 'map<string,string>', options={'inferSchema': 'true'}))\r\n",
							"\r\n",
							"    # Creating an ID column\r\n",
							"    cost_df = cost_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    # Creating a list of columns we want to keep\r\n",
							"    cols_to_keep = [\"UsageType\", \r\n",
							"                    \"ImageType\",\r\n",
							"                    \"ServiceType\",\r\n",
							"                    \"VMName\",\r\n",
							"                    \"VMApplicationName\",\r\n",
							"                    \"VMProperties\",\r\n",
							"                    \"VCPUs\",\r\n",
							"                    \"AHB\",\r\n",
							"                    \"vCores\",\r\n",
							"                    \"RINormalizationRatio\",\r\n",
							"                    \"ConsumedQuantity\",\r\n",
							"                    \"DatabaseName\"]\r\n",
							"\r\n",
							"    for col in cols_to_keep:\r\n",
							"        cost_df = cost_df.withColumn('ai_' + col, F.coalesce(F.col(f'AdditionalInfo.{col}'), F.lit(None)))\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def preprocess_pricesheet(pricesheet_df):\r\n",
							"    pricesheet_df = pricesheet_df.where(F.col('OfferID') == PROD_OFFER_ID)\r\n",
							"    pricesheet_df = pricesheet_df.withColumn('NormalizedUnit', F.regexp_extract('UnitOfMeasure', r'^(\\d+)', 1).cast('integer'))\r\n",
							"    pricesheet_df = pricesheet_df.withColumn('NormalizedUnitPrice', F.col('UnitPrice') / F.col('NormalizedUnit'))\r\n",
							"    return pricesheet_df"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_sp_columns(cost_df, pricesheet_df):\r\n",
							"    # Determine if cost is eligible to SP\r\n",
							"    sp_enabled = (F.col('PricingModel') == 'SavingsPlan') & (F.col('ChargeType') == 'Usage')\r\n",
							"    is_ondemand = (F.col('PricingModel') == 'OnDemand') & (F.col('ChargeType') == 'Usage')\r\n",
							"    is_vm_compute = (F.col('MeterCategory') == 'Virtual Machines') & ~(F.col('MeterSubCategory').contains('Av1'))\r\n",
							"    is_aas_compute = (F.col('MeterCategory') == 'Azure App Service') & (F.col('MeterSubCategory').isin(['Premium v3', 'Isolated v2']))\r\n",
							"    is_af_compute = (F.col('MeterCategory') == 'Functions') & (F.col('MeterSubCategory') == 'Premium')\r\n",
							"    is_aci_compute = (F.col('MeterCategory') == 'Container Instances')\r\n",
							"    is_aca_compute = (F.col('MeterCategory') == 'Azure Container Apps')\r\n",
							"    is_sp_eligible = is_vm_compute | is_aas_compute | is_af_compute | is_aci_compute | is_aca_compute\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('SPStatus', \r\n",
							"        F.when(sp_enabled, SavingsPlanStatus.Enabled.value)\r\n",
							"        .when(is_ondemand & is_sp_eligible, SavingsPlanStatus.NotEnabled.value)\r\n",
							"        .otherwise(SavingsPlanStatus.NotSupported.value)\r\n",
							"    )\r\n",
							"\r\n",
							"    # Only use prices for savingsplan for 3 year term\r\n",
							"    pricesheet_df = pricesheet_df.where((F.col('PriceType') == 'SavingsPlan') & (F.col('Term') == 'P3Y'))\r\n",
							"\r\n",
							"    pricesheet_df =  pricesheet_df.withColumn('NormalizedMemoryFactor', \r\n",
							"        F.when(F.col('UnitOfMeasure').contains('TiB'), 1024) # Standard measure in usage file is GiB --> convertion factor between TiB and Gib is 1024\r\n",
							"        .when(F.col('UnitOfMeasure').contains(\"PiB\"), 1048576) # Standard measure in usage file is GiB --> convertion factor between PiB and Gib is 1048576\r\n",
							"        .when(F.col('UnitOfMeasure').contains(\"TB\"), 1000) # Standard measure in usage file is GB --> convertion factor between TB and Gb is 1000\r\n",
							"        .when(F.col('UnitOfMeasure').contains(\"PB\"), 1000000) # Standard measure in usage file is GB --> convertion factor between PB and Gib is 1000000\r\n",
							"        .otherwise(1)\r\n",
							"    )\r\n",
							"    pricesheet_df = pricesheet_df.withColumn('NormalizedP3YSPUnitPrice', F.col('NormalizedUnit') / F.col('NormalizedMemoryFactor'))\r\n",
							"    pricesheet_df = pricesheet_df.select('PartNumber', 'NormalizedP3YSPUnitPrice')\r\n",
							"\r\n",
							"    cost_df = cost_df.join(pricesheet_df, 'PartNumber', 'left')\r\n",
							"\r\n",
							"    # When cost is classified as eligible to SP, but does not av a P3Y Unit Price associated with it - it should not be eligible to SP\r\n",
							"    cost_df = cost_df.withColumn('SPStatus', F.when((F.col('SPStatus') == 'Not Enabled') & F.col('NormalizedP3YSPUnitPrice').isNull(), F.lit(SavingsPlanStatus.NotSupported.value)).otherwise(F.col('SPStatus')))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_AHB_columns(cost_df, pricesheet_df):\r\n",
							"    ## DETERMINE IF WINDOWS/SQL SERVER IS HUB ENABLED/ELIGIBLE\r\n",
							"\r\n",
							"    # Compute if Windows Server has Azure Hybrid Benefit enabled\r\n",
							"    cost_df = cost_df.withColumn('WindowsAHB', F.when(F.col('ServiceInfo2') == 'Windows Server BYOL', AHBStatus.Enabled.value)\\\r\n",
							"                                                            .when(F.col('MeterSubCategory').contains('Windows'), AHBStatus.NotEnabled.value)\\\r\n",
							"                                                            .otherwise(AHBStatus.NotSupported.value))\r\n",
							"\r\n",
							"    # Compute if SQL Server has Azure Hybrid Benefit enabled\r\n",
							"    is_sql_db = (F.col('ResourceId').like('%Microsoft.Sql/servers%')) & (F.col('MeterCategory').like('SQL%'))\r\n",
							"    is_sql_mi = (F.col('ResourceId').like('%Microsoft.Sql/managedInstances%')) & (F.col('MeterCategory').like('SQL%'))\r\n",
							"    is_sql_vm = (F.col('MeterCategory') == 'Virtual Machines Licenses') & (F.col('MeterSubCategory').like('SQL Server%'))\r\n",
							"    is_sql_arc = (F.col('ResourceId').like('%Microsoft.AzureArcData/sqlServerInstances%')) & (F.col('ai_AHB').isNotNull())\r\n",
							"    is_sql_adf = (F.col('MeterCategory') == 'Azure Data Factory v2') & (F.col('MeterSubCategory').like('SSIS%'))\r\n",
							"\r\n",
							"    is_sql_cost = is_sql_db | is_sql_mi | is_sql_vm | is_sql_arc | is_sql_adf\r\n",
							"\r\n",
							"    NOT_SUPPORTED_AHB_SUBCATEGORIES = [\r\n",
							"        'SQL Server Express Edition',\r\n",
							"        'SQL Server Developer Edition',\r\n",
							"        'SQL Server Web',\r\n",
							"        'SingleDB/Elastic Pool Hyperscale - SQL License'\r\n",
							"    ]\r\n",
							"\r\n",
							"    is_not_supported = (F.col('MeterSubCategory').isin(NOT_SUPPORTED_AHB_SUBCATEGORIES))\r\n",
							"\r\n",
							"    is_vm = F.col('ResourceId').like('%Microsoft.Compute/virtualMachines%')\r\n",
							"    is_vm_ahb = is_vm & (F.col('MeterSubCategory') == 'SQL Server Azure Hybrid Benefit')\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('SQLAHB', \r\n",
							"        F.when(is_sql_cost & is_not_supported, AHBStatus.NotSupported.value)\r\n",
							"        .when(is_sql_cost & is_vm_ahb, AHBStatus.Enabled.value)\r\n",
							"        .when(is_sql_cost & is_vm, AHBStatus.NotEnabled.value)\r\n",
							"        .when(is_sql_cost & (F.col('ai_AHB') == True), AHBStatus.Enabled.value)\r\n",
							"        .when(is_sql_cost & (F.col('ai_AHB') == False), AHBStatus.NotEnabled.value)\r\n",
							"        .when(is_sql_adf & F.col('MeterName').like('%AHB%'), AHBStatus.Enabled.value)\r\n",
							"        .when(is_sql_adf & F.col('MeterName').like('%License Included%'), AHBStatus.NotEnabled.value)\r\n",
							"        .otherwise(AHBStatus.NotSupported.value)\r\n",
							"    )\r\n",
							"\r\n",
							"    ## COMPUTE HUB NORMALIZED VCPUS FOR WINDOWS/SQL\r\n",
							"    \r\n",
							"    cost_df = cost_df.withColumn('ai_VCPUs', F.col('ai_VCPUs').cast('int'))\r\n",
							"    cost_df = cost_df.na.fill({'ai_VCPUs' : 0})\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ai_vCores', F.col('ai_vCores').cast('int'))\r\n",
							"    cost_df = cost_df.na.fill({'ai_vCores' : 0})\r\n",
							"\r\n",
							"    is_standard_sql_license = F.col('ProductName').like('%Standard%') | F.col('ProductName').like('%General%') | F.col('ProductName').like('%Std%')\r\n",
							"    is_enterprise_sql_license = F.col('ProductName').like('%Enterprise%') | F.col('ProductName').like('%Critical%') | F.col('ProductName').like('%Ent%')\r\n",
							"\r\n",
							"    # Compute the Windows AHB equivalent VCPUs\r\n",
							"    cost_df = cost_df.withColumn('WindowsAHB_VCPUS', \r\n",
							"        F.when(F.col('ai_VCPUs') == 0, 0)\r\n",
							"        .when(F.col('ai_VCPUs') <= 8, 8)\r\n",
							"        .when(F.col('ai_VCPUs') <= 16, 16)\r\n",
							"        .when(F.col('ai_VCPUs') == 20, 24)\r\n",
							"        .when(F.col('ai_VCPUs') > 20, F.col('ai_VCPUs'))\r\n",
							"        .otherwise(0)\r\n",
							"    )\r\n",
							"\r\n",
							"    # Extract vCore count for ADF SQL resource with this pattern\r\n",
							"    adf_vcore_pattern = r'[A-Za-z](\\d+)'\r\n",
							"    adf_vcores = F.regexp_extract(F.col('MeterName'), adf_vcore_pattern, 1).cast(T.IntegerType())\r\n",
							"\r\n",
							"    # Compute the SQL AHB equivalent VCPUs\r\n",
							"    cost_df = cost_df.withColumn('SQLAHB_VCPUS', \r\n",
							"        F.when(is_sql_vm & (F.col('ai_VCPUs') == 0), 0)\r\n",
							"        .when(is_sql_vm & is_standard_sql_license & (F.col('ai_VCPUs') <= 4), 4)\r\n",
							"        .when(is_sql_vm & is_standard_sql_license & (F.col('ai_VCPUs') > 4), F.col('ai_VCPUs'))\r\n",
							"        .when(is_sql_vm & is_enterprise_sql_license & (F.col('ai_VCPUs') <= 4), 16)\r\n",
							"        .when(is_sql_vm & is_enterprise_sql_license & (F.col('ai_VCPUs') > 4), F.col('ai_VCPUs') * 4)\r\n",
							"        .when((is_sql_mi | is_sql_db | is_sql_arc) & (F.col('ai_vCores') == 0), 0)\r\n",
							"        .when((is_sql_mi | is_sql_db | is_sql_arc) & is_standard_sql_license, F.col('ai_vCores'))\r\n",
							"        .when((is_sql_mi | is_sql_db | is_sql_arc) & is_enterprise_sql_license, F.col('ai_vCores') * 4)\r\n",
							"        .when(is_sql_adf & is_standard_sql_license, adf_vcores)\r\n",
							"        .when(is_sql_adf & is_enterprise_sql_license, adf_vcores * 4)\r\n",
							"        .otherwise(0)\r\n",
							"    )\r\n",
							"\r\n",
							"    ## COMPUTE HUB PAYG LICENSE COST\r\n",
							"\r\n",
							"    is_windows_hub_eligible = (F.col('WindowsAHB') != AHBStatus.NotSupported.value)\r\n",
							"    is_sql_hub_eligible = (F.col('SQLAHB') != AHBStatus.NotSupported.value)\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('PricesheetJoinKey', \r\n",
							"        F.when(is_windows_hub_eligible,\r\n",
							"            F.concat(\r\n",
							"                F.lit('Windows Server'),\r\n",
							"                F.when(F.col('MeterSubCategory') == 'Windows Server Burst', ' Burst - ').otherwise(' - '), \r\n",
							"                F.col('ai_VCPUs'), \r\n",
							"                F.lit(' vCPU VM License')\r\n",
							"            )\r\n",
							"        )\r\n",
							"        .when(is_sql_hub_eligible & is_sql_mi & is_standard_sql_license, 'SQL Managed Instance General Purpose - SQL License - vCore')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_mi & is_enterprise_sql_license, 'SQL Managed Instance Business Critical - SQL License - vCore')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_db & is_standard_sql_license, 'SQL Database Single/Elastic Pool General Purpose - SQL License - vCore')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_db & is_enterprise_sql_license, 'SQL Database Single/Elastic Pool Business Critical - SQL License - vCore')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_vm & is_standard_sql_license & (F.col('ai_VCPUs') < 5), 'SQL Server Standard - 1-4 vCPU VM License')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_vm & is_enterprise_sql_license & (F.col('ai_VCPUs') < 5), 'SQL Server Enterprise - 1-4 vCPU VM License')\r\n",
							"        .when(is_sql_hub_eligible & is_sql_vm & is_standard_sql_license & (F.col('ai_VCPUs') >= 5), F.concat(F.lit('SQL Server Standard - '), F.col('ai_VCPUs'), F.lit(' vCPU VM License')))\r\n",
							"        .when(is_sql_hub_eligible & is_sql_vm & is_enterprise_sql_license & (F.col('ai_VCPUs') >= 5), F.concat(F.lit('SQL Server Enterprise - '), F.col('ai_VCPUs'), F.lit(' vCPU VM License')))\r\n",
							"        .when(is_sql_hub_eligible & is_sql_adf & is_standard_sql_license, F.concat(F.lit('SSIS '), F.split('MeterName', ' ').getItem(0), F.lit(' '), F.split('MeterName', ' ').getItem(1), F.lit(' - Standard')))\r\n",
							"        .when(is_sql_hub_eligible & is_sql_adf & is_enterprise_sql_license, F.concat(F.lit('SSIS '), F.split('MeterName', ' ').getItem(0), F.lit(' '), F.split('MeterName', ' ').getItem(1), F.lit(' - Enterprise')))\r\n",
							"        .otherwise(None)\r\n",
							"    )\r\n",
							"\r\n",
							"    # Compute license priceses for ADF SSIS SQL compute\r\n",
							"    adf_pricesheet = pricesheet_df.where(is_sql_adf)\r\n",
							"\r\n",
							"    pricesheet_df = pricesheet_df \\\r\n",
							"        .select('Product', 'NormalizedUnitPrice') \\\r\n",
							"        .withColumnRenamed('Product', 'PricesheetJoinKey') \\\r\n",
							"        .withColumnRenamed('NormalizedUnitPrice', 'LicensePayGUnitPrice')\r\n",
							"\r\n",
							"    # Only process if adf related rows exists -> if not the pivoting will fail\r\n",
							"    if adf_pricesheet.count() > 0:\r\n",
							"        adf_pricesheet = adf_pricesheet.withColumn('LicenseType', F.split('MeterSubCategory', ' ').getItem(1))\r\n",
							"        adf_pricesheet = adf_pricesheet.withColumn('ComputeResource', F.concat(F.split('MeterName', ' ').getItem(0), F.lit(' '), F.split('MeterName', ' ').getItem(1)))\r\n",
							"        adf_pricesheet = adf_pricesheet.withColumn('PricesheetJoinKey', F.concat(F.lit('SSIS '), F.col('ComputeResource'), F.lit(' - '), F.col('LicenseType')))\r\n",
							"\r\n",
							"        # Each ADF pricesheet entry has an AHB and a PayG counter-part, use pivot to get the corresponding unit prices into a single pricesheet entry\r\n",
							"        adf_pricesheet = adf_pricesheet.withColumn('AHB', F.when(F.col('MeterType').like('%AHB%'), 'AHBUnitPrice').otherwise('PayGUnitPrice'))\r\n",
							"        adf_pricesheet = adf_pricesheet.groupBy('PricesheetJoinKey').pivot('AHB').agg(F.first('NormalizedUnitPrice'))\r\n",
							"        adf_pricesheet = adf_pricesheet.withColumn('LicensePayGUnitPrice', F.col('PayGUnitPrice') - F.col('AHBUnitPrice'))\r\n",
							"        adf_pricesheet = adf_pricesheet.select('PricesheetJoinKey', 'LicensePayGUnitPrice')\r\n",
							"\r\n",
							"        # Add ADF SSIS License costs to pricesheet\r\n",
							"        pricesheet_df = pricesheet_df.union(adf_pricesheet)\r\n",
							"\r\n",
							"    cost_df = cost_df.join(pricesheet_df, 'PricesheetJoinKey', 'left').drop('PricesheetJoinKey')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def cost_cast_column_types(cost_df):\r\n",
							"    cost_df = cost_df.withColumn('UnitPrice', F.col('UnitPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('PayGPrice', F.col('PayGPrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Quantity', F.col('Quantity').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('EffectivePrice', F.col('EffectivePrice').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('CostInBillingCurrency', F.col('CostInBillingCurrency').cast(T.DoubleType()))\\\r\n",
							"                     .withColumn('Date', F.to_date(F.col('Date'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodStartDate', F.to_date(F.col('BillingPeriodStartDate'), 'MM/dd/yyyy'))\\\r\n",
							"                     .withColumn('BillingPeriodEndDate', F.to_date(F.col('BillingPeriodEndDate'), 'MM/dd/yyyy'))\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def expand_cost_tags(cost_df):\r\n",
							"    \r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationType\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_extract(F.col('Tags'), '(?i)costallocationtype\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.regexp_replace(F.col('CostAllocationType'), '(?i)costallocationtype\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.split(F.col('CostAllocationType'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType') == \"\", None).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationTypeTag', F.col('CostAllocationType'))\r\n",
							"\r\n",
							"    # Storing the Tags column in a new column, and cleaning it up to fit with CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_extract(F.col('Tags'), '(?i)costallocationcode\": \"(.*)\"', 0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.regexp_replace(F.col('CostAllocationCode'), '(?i)costallocationcode\": \"', \"\"))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.split(F.col('CostAllocationCode'),'\"', 0).getItem(0))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(F.col('CostAllocationCode') == \"\", None).otherwise(F.col('CostAllocationCode')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCodeTag', F.col('CostAllocationCode'))\r\n",
							"    \r\n",
							"    print(\"Cost Tags expansion complete\")\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def replace_empty_cost_fields_with_subscription_details(cost_df, application_df):\r\n",
							"    print(\"Creating ActiveWBS column, copying over CostAllocationCode, replacing 'TOBESPECIFIED' and empty values then filling gaps with SubscriptionWBS...\")\r\n",
							"\r\n",
							"    # Apply Upper-case for all CostAllocationTypes and Codes\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.upper(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.trim(F.upper(F.col('CostAllocationCode'))))\r\n",
							"\r\n",
							"    # When the tag does not contain CostAllocationCode or CostAllocationType, then we fill/replace the value in ActiveWBSReason\r\n",
							"    invalidCostAllocationMask = F.col('CostAllocationCode').isNull() | F.col('CostAllocationType').isNull()\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(invalidCostAllocationMask, F.lit('CostAllocationType or CostAllocationCode not present in Tags')))\r\n",
							"\r\n",
							"    # When either value in mask appears in AcitveWBS, add invalid reason in new column\r\n",
							"    validCostAllocationType = ['WBS', 'APPID', 'CI']\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('Invalid CostAllocationType: not APPID, CI or WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # When the values in the columns below match the mask and the cost type is WBS, then:\r\n",
							"    # regex pattern states that the string should start with a case insensitive letter, followed by a dot, followed by either letters, numbers or dots\r\n",
							"    pattern = r'^[a-zA-Z]\\.[a-zA-Z0-9.]+$'\r\n",
							"    rmask = F.col('CostAllocationCode').rlike(pattern)\r\n",
							"    cost_wbs = (F.col('CostAllocationType') == 'WBS')\r\n",
							"\r\n",
							"    # Applying valid WBS' as Active WBS'\r\n",
							"    # 1. Where the CostAllocationCode follows the regex and the CostAllocationType is WBS, we apply the CostAllocationCode\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(cost_wbs & rmask, F.col('CostAllocationCode')))\r\n",
							"    # 2. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, we set the ActiveWBSReason to be \"Invalid CostAllocationCode WBS\"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(cost_wbs & ~rmask, F.lit('Invalid CostAllocationCode WBS')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    # 3. Where the CostAllocationCode doesn't follow the regex and the CostAllocationType is WBS, the CostAllocationType is changed to \"SubscriptionWBS\"\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(cost_wbs & ~rmask, F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"\r\n",
							"    # Applying valid AppIDs as Active WBS'\r\n",
							"    # If the CostAllocationCode is empty, we fill/replace the column ActiveWBS with Operational WBS in the application_df\r\n",
							"    map_app = application_df.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'OperationalWBS')\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'APPID') & (cost_df.CostAllocationCode == map_app.AppID), how='left')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.drop('OperationalWBS')\r\n",
							"\r\n",
							"    # Applying valid CIs as Active WBS'\r\n",
							"    # Same here as above, but we merge the dataframes on ApplicationNames rather than AppID\r\n",
							"    map_app = application_df.select('ApplicationName', 'OperationalWBS')\r\n",
							"    # Apply join with case insensitivity\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    joined_df = cost_df.join(map_app, (cost_df.CostAllocationType == 'CI') & (cost_df.CostAllocationCode == map_app.ApplicationName_upper), how='left').drop('ApplicationName_upper')\r\n",
							"    cost_df = joined_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('OperationalWBS')).otherwise(F.col('ActiveWBS')))\r\n",
							"    \r\n",
							"    # Alternative 1 remove \"AppID\" \r\n",
							"    cost_df = cost_df.drop('ApplicationName', 'OperationalWBS')\r\n",
							"\r\n",
							"    # When ActiveWBS value is string 'TOBESPECIFIED', we replace the value with None. # Why this ActiveWBS have TOBSPECIFIED value? \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.upper(F.col('ActiveWBS')) == 'TOBESPECIFIED', F.lit(None)).otherwise(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # When Subscriptions are not attached to the costs (unassigned), we fill the values with Unassigned and state the ActiveWBSReason.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned')).otherwise(F.col('ActiveWBS')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('SubscriptionName') == 'Unassigned', F.lit('Unassigned Subscription, possibly unused RI/SP')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    # Now that we have filled in most places in ActiveWBS, if the rest of ActiveWBS is Null, then we apply the CostCenter WBS\r\n",
							"    # When CostAllocationType is null, we fill it with the value from SubscriptionWBS\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'APPID'), F.lit('AppID CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBS').isNull() & (F.col('CostAllocationType') == 'CI'), F.lit('CI CostAllocationCode Invalid or Missing')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('ActiveWBS').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.when(F.col('ActiveWBS').isNull(), F.col('CostCenter')).otherwise(F.col('ActiveWBS'))) # Cost Center is identical to SubscriptionWBS. So we can remove subscription.json.\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(~F.col('CostAllocationType').isin(validCostAllocationType), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType')))\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationType', F.when(F.col('CostAllocationType').isNull(), F.lit('SubscriptionWBS')).otherwise(F.col('CostAllocationType'))) #  Can be removed.\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('ActiveWBSReason').isNull() & (F.col('CostAllocationType') == 'SubscriptionWBS'), F.lit('No valid AppID, WBS or CI')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    \r\n",
							"\r\n",
							"    # When CostAllocationType is a specific string, we fill/replace the value in ActiveWBSReason \r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'CI', F.lit('CI WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'APPID', F.lit('AppID WBS Lookup from SNOW')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBSReason', F.when(F.col('CostAllocationType') == 'WBS', F.lit('WBS Cost Tag used')).otherwise(F.col('ActiveWBSReason')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('ActiveWBS', F.upper(F.col('ActiveWBS')))\r\n",
							"\r\n",
							"    # For cases that where CostAllocationCode is empty, we will use AppID from SerivceNow and Application from Subscription.json to replace.\r\n",
							"    mask3 = (F.col('CostAllocationType').isin(['APPID']) & F.col('CostAllocationCode').isNull())\r\n",
							"    mask4 = (F.col('CostAllocationType').isin(['CI']) & F.col('CostAllocationCode').isNull())\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode', F.when(mask3, F.col('AppID')) \\\r\n",
							"                                                       .when(mask4, F.col('SubscriptionServiceNow-App')) \\\r\n",
							"                                                       .otherwise(F.col('CostAllocationCode'))).drop('AppID')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_application_names(cost_df, application_df):\r\n",
							"\r\n",
							"    # Masks for CI and AppID\r\n",
							"    ci_mask = F.col('CostAllocationType') == 'CI'\r\n",
							"    appid_mask = F.col('CostAllocationType') == 'APPID'\r\n",
							"\r\n",
							"    # When AppID is present, we use the application name from the Service-Now Application list\r\n",
							"    # First convert AppID to a string, then select the desired columns\r\n",
							"    map_app = application_df.withColumn('AppID', F.col('AppID').cast(T.StringType())).select('AppID', 'ApplicationName')\r\n",
							"\r\n",
							"    # Apply case insensitivity merge by creating upper case columns\r\n",
							"    cost_df = cost_df.withColumn('CostAllocationCode_upper',F.upper(F.col('CostAllocationCode')))\r\n",
							"    map_app = map_app.withColumn('ApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    # Merge CostAllocationCode on APPID\r\n",
							"    cost_df = cost_df.join(map_app, cost_df.CostAllocationCode_upper == map_app.AppID, how='left')\r\n",
							"\r\n",
							"    # Make copy of service now app list for second merge\r\n",
							"    map_app_copy = map_app.alias('map_app_copy').withColumnRenamed('AppID', 'NewAppID').withColumnRenamed('ApplicationName_upper', 'NewApplicationName_upper').withColumnRenamed('ApplicationName', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Merge CostAllicationCode on ApplicationName copy\r\n",
							"    cost_df = cost_df.join(map_app_copy, cost_df.CostAllocationCode_upper == map_app_copy.NewApplicationName_upper, how='left')\r\n",
							"\r\n",
							"    # Populate original AppId and ApplicationName columns from the copied columns\r\n",
							"    cost_df = cost_df.withColumn('AppID', F.when(F.col('AppID').isNull(), F.col('NewAppID')).otherwise(F.col('AppID')))\r\n",
							"    cost_df = cost_df.withColumn('ApplicationName', F.when(F.col('ApplicationName').isNull(), F.col('NewApplicationName')).otherwise(F.col('ApplicationName')))\r\n",
							"\r\n",
							"    cost_df = cost_df.drop('CostAllocationCode_upper', 'ApplicationName_upper', 'NewAppID', 'NewApplicationName_upper', 'NewApplicationName')\r\n",
							"\r\n",
							"    # Create Application_Name column based on Application from ServiceNow to start with.\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.col('ApplicationName'))\r\n",
							"\r\n",
							"    # Resolve CostAllocationCode and CostAllocationType typo by replacing Application_name with SubscriptionServiceNow-App value \r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when((F.col('CostAllocationType') == 'APPID') & F.col('CostAllocationCode').cast('int').isNull(),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                    .when((F.col('CostAllocationType') == 'CI') & F.col('CostAllocationCode').cast('int').isNotNull(),F.col('SubscriptionServiceNow-App')).otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name',F.when(((F.col('CostAllocationType') == \"SubscriptionWBS\") | (F.col('CostAllocationType') == \"WBS\"))&(F.col('Application_Name').isNull()),F.col('SubscriptionServiceNow-App'))\\\r\n",
							"                                                     .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    cost_df = cost_df.withColumn('Application_Name_upper',F.upper(F.col('Application_Name')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowApplicationName_upper',F.upper(F.col('ApplicationName')))\r\n",
							"    map_app = map_app.withColumn('ServiceNowAppID',F.col('AppID')).drop('AppID')\r\n",
							"\r\n",
							"    # Lookup application in ServiceNow. Those applications that can be found will be merged.\r\n",
							"    cost_df = cost_df.join(map_app,cost_df.Application_Name_upper==map_app.ServiceNowApplicationName_upper,how='left')\r\n",
							"\r\n",
							"    # Fill empty AppID with AppID from ServiceNow\r\n",
							"    cost_df = cost_df.withColumn('AppID',F.when(F.col('AppID').isNull(),F.col('ServiceNowAppID'))\\\r\n",
							"                                          .otherwise(F.col('AppID'))) \r\n",
							"\r\n",
							"    # Remove unused Columns\r\n",
							"    cost_df = cost_df.drop('Application_Name_upper','ApplicationName','ServiceNowAppID','ServiceNowApplicationName_upper','ApplicationName_upper')\r\n",
							"\r\n",
							"\r\n",
							"    # Application Name will be \"Unknown\" when SubscriptionServiceNow-App is equal to Application_name as well as AppID is empty.\r\n",
							"    # This indicates that application from subscription.json file can not be found in ServiceNow. One of Application example is DATAHUB - MARKETING AND SUPPLY, not found in ServiceNow.\r\n",
							"    # cost_df = cost_df.withColumn('Application_Name', F.when((F.upper(F.col('SubscriptionServiceNow-App'))==F.upper(F.col('Application_Name'))) & (F.col('AppID').isNull()),F.lit('Uknown'))\\\r\n",
							"    #                                                 .otherwise(F.col('Application_Name')))\r\n",
							"\r\n",
							"    # If Subscription Application is empty or null - set application name to 'Unknown' and AppId to null\r\n",
							"    cost_df = cost_df.withColumn('Application_Name', \r\n",
							"        F.when((F.col('Application_Name').isNull()) | (F.col('Application_Name') == ''), F.lit('Unknown')).otherwise(F.col('Application_Name'))\r\n",
							"    )\r\n",
							"\r\n",
							"    # Setup dummy application reference for Danske Commodities related cost\r\n",
							"    cost_df = cost_df.withColumn('Application_Name', \r\n",
							"        F.when((F.upper(F.col('SubscriptionName')).contains('DANSKE')) & (F.col('Application_Name') == 'Unknown'), 'Danske Commodities')\r\n",
							"        .otherwise(F.col('Application_Name'))\r\n",
							"    )\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def add_azure_service_information(cost_df, service_df):\r\n",
							"    # Remove duplicate rows by groupBy+count\r\n",
							"    service_df = service_df.withColumn('service_ResourceType', F.lower('ResourceType'))\r\n",
							"    service_df = service_df.groupBy('service_ResourceType','ServiceName','ServiceCategory', 'ServiceModel').count().drop('count')\r\n",
							"\r\n",
							"    # Count number of distinct resourcetypes in dataset\r\n",
							"    count_df = service_df.groupBy('service_ResourceType').count()\r\n",
							"\r\n",
							"    # Separate services with unique resource types (unambiguous in terms of service type) - i.e where the count of resource types is 1\r\n",
							"    unambig_df = count_df.filter(count_df['count'] == 1).join(service_df, 'service_ResourceType').drop('count')\r\n",
							"\r\n",
							"    # Separate services with ambiguity in terms of service types - i.e where the count of resource types is greater than 0\r\n",
							"    ambig_df = count_df.filter(count_df['count'] > 1).join(service_df, 'service_ResourceType').drop('count')\r\n",
							"\r\n",
							"    # Add prefix to service datasets for joining purposes\r\n",
							"    unambig_prefix = 'unambig_'\r\n",
							"    for col in unambig_df.columns:\r\n",
							"        unambig_df = unambig_df.withColumnRenamed(col, unambig_prefix + col)\r\n",
							"\r\n",
							"    unambig_prefix = 'ambig_'\r\n",
							"    for col in ambig_df.columns:\r\n",
							"        ambig_df = ambig_df.withColumnRenamed(col, unambig_prefix + col)\r\n",
							"\r\n",
							"    # Extract resource type from resource id\r\n",
							"    cost_df = cost_df.withColumn('temp_resource_id', F.lower(F.col('ResourceId')))\r\n",
							"    cost_df = cost_df.withColumn('ResourceType', F.regexp_extract('temp_resource_id', '/providers/([^/]+/[^/]+)', 1)).drop('temp_resource_id')\r\n",
							"\r\n",
							"    # Join cost resource types on unambiguous resource types\r\n",
							"    cost_df = cost_df.join(unambig_df, cost_df.ResourceType == unambig_df.unambig_service_ResourceType, how='left').drop('unambig_service_ResourceType')\r\n",
							"\r\n",
							"    # Join cost resource types and meter category on ambiguous resource types and service name\r\n",
							"    cost_df = cost_df.join(ambig_df, (cost_df.ResourceType == ambig_df.ambig_service_ResourceType) & (cost_df.MeterCategory == ambig_df.ambig_ServiceName), how='left').drop('ambig_service_ResourceType')\r\n",
							"\r\n",
							"    # Merge joined service columns and drop remaining columns from service datasets \r\n",
							"    cost_df = cost_df.withColumn('ServiceModel', F.when(F.col('unambig_ServiceModel').isNotNull(), F.col('unambig_ServiceModel')).otherwise(F.col('ambig_ServiceModel')))\r\n",
							"    cost_df = cost_df.withColumn('ServiceName', F.when(F.col('unambig_ServiceName').isNotNull(), F.col('unambig_ServiceName')).otherwise(F.col('ambig_ServiceName')))\r\n",
							"    cost_df = cost_df.withColumn('ServiceCategory', F.when(F.col('unambig_ServiceCategory').isNotNull(), F.col('unambig_ServiceCategory')).otherwise(F.col('ambig_ServiceCategory')))\r\n",
							"    cost_df = cost_df.drop('ambig_ServiceModel', 'ambig_ServiceName', 'ambig_ServiceCategory', 'unambig_ServiceModel', 'unambig_ServiceName', 'unambig_ServiceCategory')\r\n",
							"\r\n",
							"    # Join cost resource types and meter sub category on ambiguous resource types and service name\r\n",
							"    cost_df = cost_df.join(ambig_df, (cost_df.ResourceType == ambig_df.ambig_service_ResourceType) & (cost_df.MeterSubCategory == ambig_df.ambig_ServiceName), how='left').drop('ambig_service_ResourceType')\r\n",
							"\r\n",
							"    # Merge joined columns with previously merged service columns\r\n",
							"    cost_df = cost_df.withColumn('ServiceModel', F.when(F.col('ServiceModel').isNotNull(), F.col('ServiceModel')).otherwise(F.col('ambig_ServiceModel')))\r\n",
							"    cost_df = cost_df.withColumn('ServiceName', F.when(F.col('ServiceName').isNotNull(), F.col('ServiceName')).otherwise(F.col('ambig_ServiceName')))\r\n",
							"    cost_df = cost_df.withColumn('ServiceCategory', F.when(F.col('ServiceCategory').isNotNull(), F.col('ServiceCategory')).otherwise(F.col('ambig_ServiceCategory')))\r\n",
							"    cost_df = cost_df.drop('ambig_ServiceModel', 'ambig_ServiceName', 'ambig_ServiceCategory')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 15
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def transform_cost_data(cost_df):\r\n",
							"\r\n",
							"    warnings.simplefilter(action='ignore', category=FutureWarning)\r\n",
							"    cost_df = cost_extend_additional_info(cost_df)\r\n",
							"    cost_df = cost_cast_column_types(cost_df)\r\n",
							"    cost_df = expand_cost_tags(cost_df)\r\n",
							"    cost_df = cost_df.withColumn(\"ResourceLocation\", F.lower(F.trim(F.regexp_replace(F.col('ResourceLocation'), \"\\s+\", \"\"))))\r\n",
							"    \r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 16
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_hub_and_sp(cost_df, pricesheet_df):\r\n",
							"    pricesheet_df = preprocess_pricesheet(pricesheet_df)\r\n",
							"    cost_df = compute_sp_columns(cost_df, pricesheet_df)\r\n",
							"    cost_df = compute_AHB_columns(cost_df, pricesheet_df)\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def combine_subscriptions_and_applications(cost_df, subscription_df, application_df):\r\n",
							"    \r\n",
							"    cost_df = cost_df.join(subscription_df, cost_df.SubscriptionId == subscription_df.SubId, how='left')\r\n",
							"    cost_df = cost_df.drop('SubId')\r\n",
							"\r\n",
							"    cost_df = replace_empty_cost_fields_with_subscription_details(cost_df, application_df)\r\n",
							"    print('WBS population complete. Populating application names')\r\n",
							"    cost_df = get_application_names(cost_df, application_df)    \r\n",
							"    print('App-name population complete')\r\n",
							"\r\n",
							"    return cost_df"
						],
						"outputs": [],
						"execution_count": 18
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/daily-cost-extend-v3')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Extension"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('daily-cost-extend-v3_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "d69238ba-81e2-4e05-a4a7-38a752fd1358"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('daily-cost-extend-v3_notebookSparkPoolIdRef')]",
						"name": "[parameters('daily-cost-extend-v3_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('daily-cost-extend-v3_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Initialize script"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"toDate = '20240331'\n",
							"fromDate = '20240301'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'\n",
							"reportType = 'ActualCost'"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import pyspark.pandas as ps\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings\n",
							"\n",
							"import pyspark.sql.functions as F\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load utility functions"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"%run /cost-extend-utilities"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def pre_process_subscriptions(subscriptions_df):\r\n",
							"    subscriptions_df = subscriptions_df.select('SubscriptionId', 'OperationalWBS', 'Application')\r\n",
							"    subscriptions_df = subscriptions_df.withColumnRenamed('SubscriptionId', 'SubId')\r\n",
							"    subscriptions_df = subscriptions_df.withColumnRenamed('OperationalWBS', 'SubscriptionWBS')\r\n",
							"    subscriptions_df = subscriptions_df.withColumnRenamed('Application', 'SubscriptionServiceNow-App')\r\n",
							"    return subscriptions_df"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"\n",
							"    cost_df = cost_df.drop('id', 'AdditionalInfo') \n",
							"    print('start to write to container')\n",
							"    cost_df.write.format('parquet').mode('overwrite').option('path', destinationFilename).save()\n",
							"    print('File write complete!')"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Execute transformation on cost data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(f'fromDate: {fromDate}')\r\n",
							"print(f'toDate: {toDate}')\r\n",
							"\r\n",
							"print(f\"------ From: {fromDate}, To: {toDate} -----------\")\r\n",
							"\r\n",
							"print(f\"------ {reportType} -----------\")\r\n",
							"date_range = fromDate + '-' + toDate\r\n",
							"print(f'dateRange: {date_range}')\r\n",
							"\r\n",
							"cost_source_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/exports/daily/ACMDaily{reportType}/{date_range}/*.csv'\r\n",
							"cost_target_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthly{reportType}/{date_range}/Extended_v3_ACMMonthly{reportType}_{date_range}.parquet'\r\n",
							"print(f\"Cost data path: {cost_source_path}\")\r\n",
							"print(f\"Cost destination path: {cost_target_path}\")\r\n",
							"\r\n",
							"previous_month_date = get_last_day_prev_month(toDate)\r\n",
							"print(f'Using {previous_month_date} ServiceNow subscription file')\r\n",
							"subscription_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/{previous_month_date}-optimized.parquet'\r\n",
							"print(f\"Subscription path: {subscription_path}\")\r\n",
							"\r\n",
							"application_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/applications/ServiceNow-Application-List-Extended.parquet'\r\n",
							"print(f\"Application path: {application_path}\")\r\n",
							"\r\n",
							"# Load pricesheet data\r\n",
							"pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-converted/{date_range}.parquet'\r\n",
							"pricesheet_df = spark.read.format('parquet').load(pricesheet_path)\r\n",
							"\r\n",
							"# Load cost file\r\n",
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ',',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"cost_df = spark.read.options(**csv_options).csv(cost_source_path)\r\n",
							"\r\n",
							"# Load service file\r\n",
							"service_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/services/services-raw.csv'\r\n",
							"service_df = spark.read.options(**csv_options).csv(service_path)\r\n",
							"\r\n",
							"# Load subscription file\r\n",
							"subscription_df = spark.read.format('parquet').load(subscription_path)\r\n",
							"subscription_df = pre_process_subscriptions(subscription_df)\r\n",
							"\r\n",
							"# Load application file\r\n",
							"application_df = spark.read.format('parquet').load(application_path)\r\n",
							"application_df = application_df.withColumn('AppID', F.col('AppID').cast(\"int\"))\r\n",
							"\r\n",
							"# Transform data\r\n",
							"cost_df = transform_cost_data(cost_df)\r\n",
							"cost_df = combine_subscriptions_and_applications(cost_df, subscription_df, application_df)\r\n",
							"cost_df = compute_hub_and_sp(cost_df, pricesheet_df)\r\n",
							"cost_df = add_azure_service_information(cost_df, service_df)\r\n",
							"write_output_file(cost_df, cost_target_path)\r\n",
							"\r\n",
							"print(' ')"
						],
						"outputs": [],
						"execution_count": 15
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/fetch-billing-periods')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Billing"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('fetch-billing-periods_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "19558068-0d11-49f7-b585-c195a2807896"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('fetch-billing-periods_notebookSparkPoolIdRef')]",
						"name": "[parameters('fetch-billing-periods_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('fetch-billing-periods_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import requests\r\n",
							"import datetime\r\n",
							"import pyspark.sql.types as T\r\n",
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 39
					},
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 40
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"BASE_URL = \"https://management.azure.com/providers/Microsoft.Billing/\"\r\n",
							"BILLING_ACCOUNT_ID = \"57950773\""
						],
						"outputs": [],
						"execution_count": 41
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def generate_billing_periods(initial_year, initial_month):\r\n",
							"    now = datetime.datetime.now()\r\n",
							"    current_year = now.year\r\n",
							"    current_month = now.month\r\n",
							"\r\n",
							"    billing_periods = []\r\n",
							"\r\n",
							"    # Loop through the years and months and add the dates to the list\r\n",
							"    for year in range(initial_year, current_year + 1):\r\n",
							"        start_month = 1 if year > initial_year else initial_month\r\n",
							"        end_month = current_month if year == current_year else 12\r\n",
							"        for month in range(start_month, end_month + 1):\r\n",
							"            date_str = f\"{year}{month:02}\"\r\n",
							"            billing_periods.append(date_str)\r\n",
							"\r\n",
							"    return billing_periods"
						],
						"outputs": [],
						"execution_count": 43
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def fetch_billing_details(billing_account_id, billing_period, api_version, access_token):\r\n",
							"\r\n",
							"    # Build Azure management API billing endpoint\r\n",
							"    endpoint_url = BASE_URL\r\n",
							"    endpoint_url += f\"billingAccounts/{billing_account_id}/\"\r\n",
							"    endpoint_url += f\"billingPeriods/{billing_period}/providers/Microsoft.Consumption/balances?\"\r\n",
							"    endpoint_url += f\"api-version={api_version}\"\r\n",
							"\r\n",
							"    headers = {\r\n",
							"        'Authorization': 'Bearer ' + access_token\r\n",
							"    }\r\n",
							"\r\n",
							"    response = requests.get(endpoint_url, headers=headers)\r\n",
							"    result = response.json()\r\n",
							"    return result"
						],
						"outputs": [],
						"execution_count": 44
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"access_token = \"<insert-your-bearer-token-here>\""
						],
						"outputs": [],
						"execution_count": 45
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"billing_periods = generate_billing_periods(2018, 5)\r\n",
							"\r\n",
							"schema = T.StructType([\r\n",
							"    T.StructField(\"Id\", T.StringType(), True),\r\n",
							"    T.StructField(\"BillingPeriod\", T.StringType(), True),\r\n",
							"    T.StructField(\"BillingAccountId\", T.StringType(), True),\r\n",
							"    T.StructField(\"Currency\", T.StringType(), True),\r\n",
							"    T.StructField(\"BeginningBalance\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"EndingBalance\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"NewPurchases\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"Adjustments\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"Utilized\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"ServiceOverage\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"ChargesBilledSeparately\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"TotalOverage\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"TotalUsage\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"AzureMarketplaceServiceCharges\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"BillingFrequency\", T.StringType(), True),\r\n",
							"    T.StructField(\"PriceHidden\", T.BooleanType(), True)\r\n",
							"])\r\n",
							"df = spark.createDataFrame([], schema)\r\n",
							"\r\n",
							"for billing_period in billing_periods:\r\n",
							"    print(f'Fetching billing period {billing_period}')\r\n",
							"\r\n",
							"    data = fetch_billing_details(BILLING_ACCOUNT_ID, billing_period, '2019-10-01', access_token)\r\n",
							"\r\n",
							"    new_row = [(\r\n",
							"        data['id'],\r\n",
							"        billing_period,\r\n",
							"        BILLING_ACCOUNT_ID,\r\n",
							"        data['properties']['currency'],\r\n",
							"        data['properties']['beginningBalance'],\r\n",
							"        data['properties']['endingBalance'],\r\n",
							"        data['properties']['newPurchases'],\r\n",
							"        data['properties']['adjustments'],\r\n",
							"        data['properties']['utilized'],\r\n",
							"        data['properties']['serviceOverage'],\r\n",
							"        data['properties']['chargesBilledSeparately'],\r\n",
							"        data['properties']['totalOverage'],\r\n",
							"        data['properties']['totalUsage'],\r\n",
							"        data['properties']['azureMarketplaceServiceCharges'],\r\n",
							"        data['properties']['billingFrequency'],\r\n",
							"        data['properties']['priceHidden']\r\n",
							"    )]\r\n",
							"    new_df = spark.createDataFrame(new_row, schema)\r\n",
							"\r\n",
							"    df = df.union(new_df)"
						],
						"outputs": [],
						"execution_count": 48
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/billing/BillingPeriods.parquet\"\r\n",
							"df.write.format('parquet').mode('overwrite').save(target_path)"
						],
						"outputs": [],
						"execution_count": 50
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/monthly-cost-extend-v3')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Extension"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('monthly-cost-extend-v3_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "bfae63e0-183a-40d1-ab94-6811865dc39a"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('monthly-cost-extend-v3_notebookSparkPoolIdRef')]",
						"name": "[parameters('monthly-cost-extend-v3_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('monthly-cost-extend-v3_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112,
						"automaticScaleJobs": true
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Initialize script"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"toDate = '20240131'\n",
							"fromDate = '20240101'\n",
							"container = 'usage'\n",
							"storageAccount = 's037costmgmt'\n",
							"reportType = 'AmortizedCost'"
						],
						"outputs": [],
						"execution_count": 113
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\n",
							"import pyspark.pandas as ps\n",
							"import json\n",
							"import numpy as np\n",
							"from datetime import datetime\n",
							"import calendar\n",
							"import warnings\n",
							"\n",
							"import pyspark.sql.functions as F\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 114
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load utility functions"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"%run /cost-extend-utilities"
						],
						"outputs": [],
						"execution_count": 115
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def load_and_process_solum_subscriptions(subscription_path):\r\n",
							"\r\n",
							"    subscription_df = spark.read.json(subscription_path)\r\n",
							"    subscription_df = subscription_df.withColumnRenamed('id', 'SubId')\r\n",
							"    subscription_df = subscription_df.withColumn('id', F.monotonically_increasing_id())\r\n",
							"\r\n",
							"    try:\r\n",
							"        subscription_df = subscription_df.withColumn('tags', F.from_json(F.col('tags')))\r\n",
							"    except:\r\n",
							"        print('Already a json file')\r\n",
							"\r\n",
							"    # Expanding the tags list into separate columns\r\n",
							"    subscription_df = subscription_df.withColumn('SubscriptionWBS', F.col('tags.WBS'))\r\n",
							"    subscription_df = subscription_df.withColumn('SubscriptionServiceNow-App', F.col('tags.ServiceNow-App'))\r\n",
							"    subscription_df = subscription_df.drop('tags')\r\n",
							"\r\n",
							"    # Dropping unnecessary columns and setting the schema\r\n",
							"    columns_to_keep = ['SubId', 'SubscriptionWBS', 'SubscriptionServiceNow-App']\r\n",
							"    subscription_df = subscription_df.select(columns_to_keep)\r\n",
							"\r\n",
							"    return subscription_df\r\n",
							"\r\n",
							"def load_and_process_servicenow_subscriptions(subscription_path):\r\n",
							"    subscription_df = spark.read.format('parquet').load(subscription_path)\r\n",
							"    subscription_df = subscription_df.select('SubscriptionId', 'OperationalWBS', 'Application')\r\n",
							"    subscription_df = subscription_df.withColumnRenamed('SubscriptionId', 'SubId')\r\n",
							"    subscription_df = subscription_df.withColumnRenamed('OperationalWBS', 'SubscriptionWBS')\r\n",
							"    subscription_df = subscription_df.withColumnRenamed('Application', 'SubscriptionServiceNow-App')\r\n",
							"    return subscription_df\r\n",
							"\r\n",
							"def load_and_process_applications(application_path):\r\n",
							"    application_df = spark.read.format('parquet').load(application_path)\r\n",
							"    application_df = application_df.withColumn('AppID', F.col('AppID').cast(\"int\"))\r\n",
							"    return application_df"
						],
						"outputs": [],
						"execution_count": 116
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def write_output_file(cost_df, destinationFilename):\n",
							"\n",
							"    cost_df = cost_df.drop('id', 'AdditionalInfo') \n",
							"    print('start to write to container')\n",
							"    cost_df.write.format('parquet').mode('overwrite').option('path', destinationFilename).save()\n",
							"    print('File write complete!')"
						],
						"outputs": [],
						"execution_count": 117
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Execute transformation on cost data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"print(f'fromDate: {fromDate}')\n",
							"print(f'toDate: {toDate}')\n",
							"\n",
							"print(f\"------ From: {fromDate}, To: {toDate} -----------\")\n",
							"\n",
							"print(f\"------ {reportType} -----------\")\n",
							"formatted_to_date = f'{toDate[0:4]}-{toDate[4:6]}-{toDate[6:]}'\n",
							"formatted_to_date = '2021-11-30' if str(formatted_to_date) < '2021-11-30' else formatted_to_date\n",
							"\n",
							"print(f'longToDate: {formatted_to_date}')\n",
							"date_range = fromDate + '-' + toDate\n",
							"print(f'dateRange: {date_range}')\n",
							"\n",
							"cost_source_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthly{reportType}/{date_range}/ACMMonthly{reportType}_{date_range}.parquet'\n",
							"cost_target_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthly{reportType}/{date_range}/Extended_v3_ACMMonthly{reportType}_{date_range}.parquet'\n",
							"\n",
							"# Load pricesheet data\n",
							"pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-converted/{date_range}.parquet'\n",
							"try:\n",
							"    pricesheet_df = spark.read.format('parquet').load(pricesheet_path)\n",
							"except:\n",
							"    # Create empty df with pricesheet schema if file doesnt exist\n",
							"    dummy_pricesheet_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-converted/20240101-20240131.parquet'\n",
							"    dummy_df = spark.read.format('parquet').load(dummy_pricesheet_path)\n",
							"    pricesheet_df = spark.createDataFrame([], dummy_df.schema)\n",
							"\n",
							"# Load subcsription data\n",
							"solum_subscription_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/subscriptions/subscriptions_{formatted_to_date}.json'\n",
							"servicenow_subscription_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/{formatted_to_date}-optimized.parquet'\n",
							"\n",
							"try:\n",
							"    subscription_df = load_and_process_servicenow_subscriptions(servicenow_subscription_path)\n",
							"except:\n",
							"    subscription_df = load_and_process_solum_subscriptions(solum_subscription_path)\n",
							"\n",
							"# Load service file\n",
							"service_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/services/services-raw.csv'\n",
							"service_csv_options = {'header' : True,\n",
							"                'delimiter' : ',',\n",
							"                'quote' : '\"',\n",
							"                'escape' : '\"'}\n",
							"service_df = spark.read.options(**service_csv_options).csv(service_path)\n",
							"\n",
							"# Load application data\n",
							"application_path = f'abfss://{container}@{storageAccount}.dfs.core.windows.net/applications/ServiceNow-Application-List-Extended.parquet'\n",
							"application_df = load_and_process_applications(application_path)\n",
							"\n",
							"# Process cost data\n",
							"cost_df = spark.read.format('parquet').load(cost_source_path)\n",
							"cost_df = transform_cost_data(cost_df)\n",
							"cost_df = combine_subscriptions_and_applications(cost_df, subscription_df, application_df)\n",
							"cost_df = compute_hub_and_sp(cost_df, pricesheet_df)\n",
							"cost_df = add_azure_service_information(cost_df, service_df)\n",
							"write_output_file(cost_df, cost_target_path)\n",
							"print(' ')"
						],
						"outputs": [],
						"execution_count": 118
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/persist-latest-pricesheet')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Pricesheet"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('persist-latest-pricesheet_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "c88fc8da-726a-422b-8a19-80439853392f"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('persist-latest-pricesheet_notebookSparkPoolIdRef')]",
						"name": "[parameters('persist-latest-pricesheet_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('persist-latest-pricesheet_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"dateRange = '20231201-20231231'\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"source_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/FinOps-Pricesheet-Monthly/{dateRange}/*/*.csv'\r\n",
							"df = spark.read.csv(source_path, header=True, inferSchema=True)"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-latest'\r\n",
							"df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": 7
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/predict-service-cost')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Prediction"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('predict-service-cost_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "210ce1a4-b237-4a32-9ec6-90f2f0117e06"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('predict-service-cost_notebookSparkPoolIdRef')]",
						"name": "[parameters('predict-service-cost_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('predict-service-cost_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 125
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T\r\n",
							"import pyspark.sql.window as W\r\n",
							"import statsmodels.api as sm\r\n",
							"import pandas as pd\r\n",
							"import numpy as np\r\n",
							"from datetime import datetime, timedelta\r\n",
							"import time\r\n",
							"\r\n",
							"import warnings\r\n",
							"warnings.filterwarnings(\"ignore\", category=FutureWarning)"
						],
						"outputs": [],
						"execution_count": 126
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Integers represent number of months\r\n",
							"PREDICTION_END_DATE = '2029-04-01'\r\n",
							"LOOKBACK = 6"
						],
						"outputs": [],
						"execution_count": 127
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Load usage source\r\n",
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/*/Extended_v3_ACMMonthlyAmortizedCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 128
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"today = datetime.today().replace(day=1)\r\n",
							"\r\n",
							"prediction_end_date = datetime.strptime(PREDICTION_END_DATE, '%Y-%m-%d')\r\n",
							"prediction_interval = (prediction_end_date.year - today.year) * 12 + (prediction_end_date.month - today.month)\r\n",
							"\r\n",
							"lookback_date = (today - timedelta(days=LOOKBACK*30)).replace(day=1)\r\n",
							"lookback_date_formatted = lookback_date.strftime('%Y-%m-%d')\r\n",
							"lookback_diff = (today.year - lookback_date.year) * 12 + (today.month - lookback_date.month)"
						],
						"outputs": [],
						"execution_count": 129
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Select appropriate columns\r\n",
							"cost_df = cost_df.select('Date', 'CostInBillingCurrency', 'MeterCategory')\r\n",
							"cost_df = cost_df.withColumn('Date', F.date_trunc('month', 'Date'))\r\n",
							"cost_df = cost_df.groupBy('Date', 'MeterCategory').agg(F.sum('CostInBillingCurrency').alias('Cost')).orderBy('Date')\r\n",
							"\r\n",
							"# Filter away latest month - as we predict cost per month, it will mess up future predictions\r\n",
							"cost_df = cost_df.filter(F.col('Date') < F.concat(F.date_format(F.current_date(), 'yyyy'), F.lit('-'), F.date_format(F.current_date(), 'MM'), F.lit('-'), F.lit('01')))"
						],
						"outputs": [],
						"execution_count": 130
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create window for iterating over meter categories\r\n",
							"window = W.Window.partitionBy(\"MeterCategory\")\r\n",
							"\r\n",
							"# Only look at data within the lookback period\r\n",
							"count_df = cost_df.where((F.col('Cost') > 0) & (F.col('Date') >= lookback_date_formatted))\r\n",
							"\r\n",
							"# Calculate the number of month between cost date and today\r\n",
							"count_df = count_df.withColumn('months_from_today', F.months_between(F.lit(today), 'Date'))\r\n",
							"\r\n",
							"# Find the lowest month difference across each meter category\r\n",
							"count_df = count_df.withColumn('min_month_diff', F.min('months_from_today').over(window))\r\n",
							"\r\n",
							"# Keep meter categories where lowest diff is 1 month - this means it has cost last month - candidate for forecasting\r\n",
							"count_df = count_df.withColumn('keep_service', F.when(F.col('min_month_diff') == 1, True).otherwise(False))\r\n",
							"\r\n",
							"# Remove duplicates and prepare for join operation\r\n",
							"count_df = count_df.select('MeterCategory', 'keep_service').dropDuplicates(subset=[\"MeterCategory\", \"keep_service\"])"
						],
						"outputs": [],
						"execution_count": 131
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# # Counting the meter category groups to check if categories have cost in entire time period\r\n",
							"# count_df = cost_df.filter((F.col('Cost') > 0) & (F.col('Date') >= lookback_date_formatted)).groupBy(\"MeterCategory\").count()\r\n",
							"\r\n",
							"# # Only keeping meter categories with cost in every month\r\n",
							"# cost_df = cost_df.join(count_df, \"MeterCategory\").filter(count_df[\"count\"] == lookback_diff).drop('count')"
						],
						"outputs": [],
						"execution_count": 132
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.join(count_df, 'MeterCategory').where(F.col('keep_service') == True).drop('keep_service')"
						],
						"outputs": [],
						"execution_count": 133
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Create schema for resulting df\r\n",
							"schema = T.StructType([\r\n",
							"    T.StructField(\"Date\", T.TimestampType(), True),\r\n",
							"    T.StructField(\"Cost\", T.DoubleType(), True),\r\n",
							"    T.StructField(\"MeterCategory\", T.StringType(), True)\r\n",
							"])\r\n",
							"\r\n",
							"df = spark.createDataFrame([], schema)"
						],
						"outputs": [],
						"execution_count": 134
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"distinct_meter_categories = [row[0] for row in cost_df.select('MeterCategory').distinct().collect()]"
						],
						"outputs": [],
						"execution_count": 135
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"for meter_category in distinct_meter_categories:\r\n",
							"    print(f'Processing {meter_category} cost')\r\n",
							"    start_time = time.time()\r\n",
							"    temp_df = cost_df.where(F.col('MeterCategory') == meter_category).orderBy(F.asc('Date')).select('Date', 'Cost', 'MeterCategory')\r\n",
							"\r\n",
							"    # Convert pyspark df to pandas for OLS model\r\n",
							"    temp_pdf = temp_df.toPandas()\r\n",
							"    temp_pdf.set_index(\"Date\", inplace=True)\r\n",
							"\r\n",
							"    temp_pdf['x'] = range(len(temp_pdf))\r\n",
							"\r\n",
							"    # Estimate OLS model\r\n",
							"    if LOOKBACK > len(temp_pdf['Cost']):\r\n",
							"        y = temp_pdf['Cost'].values\r\n",
							"        x = temp_pdf['x'].values\r\n",
							"    else:\r\n",
							"        y = temp_pdf['Cost'].tail(LOOKBACK)\r\n",
							"        x = temp_pdf['x'].tail(LOOKBACK)\r\n",
							"        \r\n",
							"    model = sm.OLS(y, sm.add_constant(x))\r\n",
							"    result = model.fit()\r\n",
							"\r\n",
							"    # Configure prediction period\r\n",
							"    future_months = pd.date_range(start=temp_pdf.index[-1], periods=prediction_interval, freq=\"MS\")[1:]\r\n",
							"    future_x = np.arange(temp_pdf['x'][-1] + 1, temp_pdf['x'][-1] + prediction_interval)\r\n",
							"\r\n",
							"    # Predict future cost\r\n",
							"    x = sm.add_constant(future_x)\r\n",
							"    predicted_cost = result.predict(x)\r\n",
							"\r\n",
							"    predicted_df = pd.DataFrame({\"Date\": future_months, \"Cost\": predicted_cost})\r\n",
							"    predicted_df = spark.createDataFrame(predicted_df).withColumn('MeterCategory', F.lit(meter_category))\r\n",
							"    updated_df = temp_df.union(predicted_df)\r\n",
							"    df = df.union(updated_df)\r\n",
							"    end_time = time.time()\r\n",
							"    print(f'Successfully processed {meter_category} cost in {round(end_time - start_time, 2)} seconds.')"
						],
						"outputs": [],
						"execution_count": 136
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Set predicted Cost to 0 if negative\r\n",
							"df = df.withColumn('Cost', F.when(F.col('Cost') >= 0, F.col('Cost')).otherwise(0))"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/service-cost-prediction.parquet\"\r\n",
							"df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-azure-services')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Azure"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('process-azure-services_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "e04b1dbd-4137-4bc5-84ff-65f129688a4d"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('process-azure-services_notebookSparkPoolIdRef')]",
						"name": "[parameters('process-azure-services_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('process-azure-services_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 16
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "code",
						"source": [
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyAmortizedCost/*/Extended_v3_ACMMonthlyAmortizedCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"service_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/services/services-raw.csv'\r\n",
							"\r\n",
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ';',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"service_df = spark.read.options(**csv_options).csv(service_path)"
						],
						"outputs": [],
						"execution_count": 18
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Remove duplicate rows by groupBy+count\r\n",
							"service_df = service_df.withColumn('service_ResourceType', F.lower('ResourceType'))\r\n",
							"service_df = service_df.groupBy('service_ResourceType','ServiceName','ServiceCategory', 'ServiceModel').count().drop('count')"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Count number of distinct resourcetypes in dataset\r\n",
							"count_df = service_df.groupBy('service_ResourceType').count()\r\n",
							"\r\n",
							"# Separate services with unique resource types (unambiguous in terms of service type) - i.e where the count of resource types is 1\r\n",
							"unambig_df = count_df.filter(count_df['count'] == 1).join(service_df, 'service_ResourceType').drop('count')\r\n",
							"\r\n",
							"# Separate services with ambiguity in terms of service types - i.e where the count of resource types is greater than 0\r\n",
							"ambig_df = count_df.filter(count_df['count'] > 1).join(service_df, 'service_ResourceType').drop('count')\r\n",
							"\r\n",
							"# Add prefix to service datasets for joining purposes\r\n",
							"unambig_prefix = 'unambig_'\r\n",
							"for col in unambig_df.columns:\r\n",
							"    unambig_df = unambig_df.withColumnRenamed(col, unambig_prefix + col)\r\n",
							"\r\n",
							"unambig_prefix = 'ambig_'\r\n",
							"for col in ambig_df.columns:\r\n",
							"    ambig_df = ambig_df.withColumnRenamed(col, unambig_prefix + col)"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Extract resource type from resource id\r\n",
							"cost_df = cost_df.withColumn('temp_resource_id', F.lower(F.col('ResourceId')))\r\n",
							"cost_df = cost_df.withColumn('ResourceType', F.regexp_extract('temp_resource_id', '/providers/([^/]+/[^/]+)', 1)).drop('temp_resource_id')"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Join cost resource types on unambiguous resource types\r\n",
							"cost_df = cost_df.join(unambig_df, cost_df.ResourceType == unambig_df.unambig_service_ResourceType, how='left').drop('unambig_service_ResourceType')\r\n",
							"\r\n",
							"# Join cost resource types and meter category on ambiguous resource types and service name\r\n",
							"cost_df = cost_df.join(ambig_df, (cost_df.ResourceType == ambig_df.ambig_service_ResourceType) & (cost_df.MeterCategory == ambig_df.ambig_ServiceName), how='left').drop('ambig_service_ResourceType')\r\n",
							"\r\n",
							"# Merge joined service columns and drop remaining columns from service datasets \r\n",
							"cost_df = cost_df.withColumn('ServiceModel', F.when(F.col('unambig_ServiceModel').isNotNull(), F.col('unambig_ServiceModel')).otherwise(F.col('ambig_ServiceModel')))\r\n",
							"cost_df = cost_df.withColumn('ServiceName', F.when(F.col('unambig_ServiceName').isNotNull(), F.col('unambig_ServiceName')).otherwise(F.col('ambig_ServiceName')))\r\n",
							"cost_df = cost_df.withColumn('ServiceCategory', F.when(F.col('unambig_ServiceCategory').isNotNull(), F.col('unambig_ServiceCategory')).otherwise(F.col('ambig_ServiceCategory')))\r\n",
							"cost_df = cost_df.drop('ambig_ServiceModel', 'ambig_ServiceName', 'ambig_ServiceCategory', 'unambig_ServiceModel', 'unambig_ServiceName', 'unambig_ServiceCategory')\r\n",
							"\r\n",
							"# Join cost resource types and meter sub category on ambiguous resource types and service name\r\n",
							"cost_df = cost_df.join(ambig_df, (cost_df.ResourceType == ambig_df.ambig_service_ResourceType) & (cost_df.MeterSubCategory == ambig_df.ambig_ServiceName), how='left').drop('ambig_service_ResourceType')\r\n",
							"\r\n",
							"# Merge joined columns with previously merged service columns\r\n",
							"cost_df = cost_df.withColumn('ServiceModel', F.when(F.col('ServiceModel').isNotNull(), F.col('ServiceModel')).otherwise(F.col('ambig_ServiceModel')))\r\n",
							"cost_df = cost_df.withColumn('ServiceName', F.when(F.col('ServiceName').isNotNull(), F.col('ServiceName')).otherwise(F.col('ambig_ServiceName')))\r\n",
							"cost_df = cost_df.withColumn('ServiceCategory', F.when(F.col('ServiceCategory').isNotNull(), F.col('ServiceCategory')).otherwise(F.col('ambig_ServiceCategory')))\r\n",
							"cost_df = cost_df.drop('ambig_ServiceModel', 'ambig_ServiceName', 'ambig_ServiceCategory')"
						],
						"outputs": [],
						"execution_count": 13
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/process-benefit-purchases')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/Cost Extension"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('process-benefit-purchases_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "32311bee-fecc-4625-b1cd-9370eaff9bd3"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('process-benefit-purchases_notebookSparkPoolIdRef')]",
						"name": "[parameters('process-benefit-purchases_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('process-benefit-purchases_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Retrieve a list of all benefit purchases - mainly targeting Reservations and Savings Plan"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "code",
						"source": [
							"cost_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.where((F.col('ChargeType') == 'Purchase') & (F.col('PricingModel') != 'OnDemand'))"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.select('Date', 'SubscriptionName', 'ResourceLocation', 'MeterCategory', 'MeterSubCategory', 'Quantity', 'EffectivePrice', 'CostInBillingCurrency', 'UnitPrice', 'PricingModel', 'benefitName')"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/benefit-purchases.parquet\"\r\n",
							"cost_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": 13
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/servicenow-application-processing')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/ServiceNow"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('servicenow-application-processing_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "4",
						"spark.autotune.trackingId": "d8dccc24-d89f-4902-b9e2-caaa216e469a"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('servicenow-application-processing_notebookSparkPoolIdRef')]",
						"name": "[parameters('servicenow-application-processing_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('servicenow-application-processing_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Script initialization"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"source": [
							"import pandas as pd \r\n",
							"from pyspark.sql import SparkSession\r\n",
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Extract data from source"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"source_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/applications/NewServiceNowDataset.csv\"\r\n",
							"df = spark.read.csv(source_path, header=True, inferSchema=True)"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Validate data quality"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# According to the feedback from BPA team (Daniel Lee), we have to filter out all those records that have \"Ignored\" in OperationalStatus field.\r\n",
							"# df = application_df.where(application_df.OperationalStatus != 'Ignored')"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Transform the data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Transform string fields into integer format, and if there are empty entries, set them to 0\r\n",
							"df = df.withColumn('AppID', F.col('AppID').cast(\"int\")).fillna(0, subset=['AppID'])\r\n",
							"df = df.withColumn('IsOmniaSubscription', F.col('IsOmniaSubscription').cast(\"int\")).fillna(0, subset=['IsOmniaSubscription'])\r\n",
							"df = df.withColumn('ProductOwnerNo', F.col('ProductOwnerNo').cast(\"int\")).fillna(0, subset=['ProductOwnerNo'])\r\n",
							"df = df.withColumn('OperationalUnitManagerNo', F.col('OperationalUnitManagerNo').cast(\"int\")).fillna(0, subset=['OperationalUnitManagerNo'])\r\n",
							"\r\n",
							"# Transform string fields into date format\r\n",
							"df = df.withColumn('Created', F.to_timestamp('Created'))\r\n",
							"df = df.withColumn('Updated', F.to_timestamp('Updated'))\r\n",
							"df = df.withColumn('EndOfLifeDate', F.to_timestamp('EndOfLifeDate'))"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Mitigate email part from shortname string such that only employee initials remains\r\n",
							"df = df.withColumn(\"ProductOwnerUserName\", F.split(df[\"ProductOwnerShortName\"], \"@\").getItem(0))\r\n",
							"df = df.withColumn(\"OperationalManagerUserName\", F.split(df[\"OperationalManagerShortName\"], \"@\").getItem(0))\r\n",
							"df = df.drop('ProductOwnerShortName', 'OperationalManagerShortName')"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Split org unit string into three substrings\r\n",
							"split_col = F.split(F.col('OperationalUnitOrgUnit'), \" \")\r\n",
							"df = df.withColumn(\"OrgUnitLevel0\", split_col.getItem(0))\r\n",
							"df = df.withColumn(\"OrgUnitLevel1\", F.concat(split_col.getItem(0), F.lit(\" \"), split_col.getItem(1)))\r\n",
							"df = df.withColumn(\"OrgUnitLevel2\", F.concat(split_col.getItem(0), F.lit(\" \"), split_col.getItem(1), F.lit(\" \"), split_col.getItem(2)))"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Save it to Optimized Container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Define optimized path to save the data\r\n",
							"optimized_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/applications/ServiceNow-Application-List-Extended.parquet\"\r\n",
							"\r\n",
							"#Save the data with partitioned by time\r\n",
							"df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 13
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/servicenow-subscription-processing')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/ServiceNow"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('servicenow-subscription-processing_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "7e419aa2-26d1-4175-9607-4e215981d359"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('servicenow-subscription-processing_notebookSparkPoolIdRef')]",
						"name": "[parameters('servicenow-subscription-processing_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('servicenow-subscription-processing_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Script initialization"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 2
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F\r\n",
							"import calendar\r\n",
							"import datetime"
						],
						"outputs": [],
						"execution_count": 3
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def get_today_formatted():\r\n",
							"    today = datetime.date.today()\r\n",
							"    formattedDate = f\"{today.year}-{str(today.month).zfill(2)}-{str(today.day).zfill(2)}\"\r\n",
							"    return formattedDate\r\n",
							"\r\n",
							"def is_last_day_of_month():\r\n",
							"    today = datetime.date.today()\r\n",
							"    last_day_of_month = calendar.monthrange(today.year, today.month)[1]\r\n",
							"    return today.day == last_day_of_month"
						],
						"outputs": [],
						"execution_count": 4
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load data from source"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"source_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/latest.csv\"\r\n",
							"subscription_df = spark.read.csv(source_path, header=True, inferSchema=True)"
						],
						"outputs": [],
						"execution_count": 5
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Transform data"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# subscription_df = subscription_df.where(subscription_df.OperationalStatus != 'Ignored')"
						],
						"outputs": [],
						"execution_count": 6
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"subscription_df = subscription_df.withColumn(\"ProductOwnerUserName\", F.split(subscription_df[\"ProductOwnerEmail\"], \"@\").getItem(0))\r\n",
							"subscription_df = subscription_df.withColumn(\"TechnicalOwnerUserName\", F.split(subscription_df[\"TechnicalOwnerEmail\"], \"@\").getItem(0))\r\n",
							"subscription_df = subscription_df.drop(\"ProductOwnerEmail\", \"TechnicalOwnerEmail\")"
						],
						"outputs": [],
						"execution_count": 7
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"subscription_df = subscription_df.where(F.col('SubscriptionId').isNotNull())"
						],
						"outputs": [],
						"execution_count": 8
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Compute duplicates\r\n",
							"# duplicates = subscription_df.groupBy('SubscriptionId').count().filter(F.col('count') > 1)"
						],
						"outputs": [],
						"execution_count": 9
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Store data in optimized container"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/latest-optimized.parquet\"\r\n",
							"subscription_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)"
						],
						"outputs": [],
						"execution_count": 10
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Store snapshot of subscriptions if last day of month\r\n",
							"if (is_last_day_of_month()):\r\n",
							"    formattedDate = get_today_formatted()\r\n",
							"    target_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/subscriptions/servicenow/{formattedDate}-optimized.parquet\"\r\n",
							"    subscription_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(target_path)\r\n",
							""
						],
						"outputs": [],
						"execution_count": 11
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/sql-hub-deployments')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('sql-hub-deployments_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "c1a2d6d4-ff1e-41e8-b361-b5c040ff4df0"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('sql-hub-deployments_notebookSparkPoolIdRef')]",
						"name": "[parameters('sql-hub-deployments_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('sql-hub-deployments_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112,
						"automaticScaleJobs": true
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Initialize script"
						]
					},
					{
						"cell_type": "code",
						"metadata": {},
						"source": [
							"from datetime import timedelta, datetime\r\n",
							"from dateutil.relativedelta import relativedelta\r\n",
							"import calendar\r\n",
							"import json\r\n",
							"from notebookutils import mssparkutils\r\n",
							"from azure.storage.blob import BlobServiceClient\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.window as W\r\n",
							"from pyspark.sql import Row"
						],
						"outputs": [],
						"execution_count": 155
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 156
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Constants\r\n",
							"KEY_VAULT_NAME = 'acm-toolkit-kv'\r\n",
							"LINKED_SERVICE_NAME = 'ACM_Toolkit_kv'\r\n",
							"hubAutomationConnectionString = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'hubautomation-sa-connectionstring', LINKED_SERVICE_NAME)"
						],
						"outputs": [],
						"execution_count": 157
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Lookup HUB SQL configuration"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"blob_service_client = BlobServiceClient.from_connection_string(hubAutomationConnectionString)\r\n",
							"\r\n",
							"# get a reference to the blob container and file of the SQL HUB configuration\r\n",
							"container_name = 'sql-config'\r\n",
							"blob_name = 'config.json'\r\n",
							"container_client = blob_service_client.get_container_client(container_name)\r\n",
							"blob_client = container_client.get_blob_client(blob_name)\r\n",
							"\r\n",
							"# download the blob content as a string\r\n",
							"blob_content = blob_client.download_blob().content_as_text()\r\n",
							"\r\n",
							"# parse the JSON string into a Python dictionary\r\n",
							"sql_config = json.loads(blob_content)\r\n",
							"\r\n",
							"# Compute the variable determining if results should be written to file\r\n",
							"day_name = datetime.now().strftime(\"%A\")\r\n",
							"should_run = sql_config['runDays'][day_name]\r\n",
							"\r\n",
							"sql_metersubcategory_array = sql_config['MeterSubCategory']\r\n",
							"sql_days_back_from = sql_config['daysBackFrom']\r\n",
							"sql_days_back_to = sql_config['daysBackTo']\r\n",
							"sql_enterprise_licence_cores = sql_config['enterprise_licence_cores']\r\n",
							"sql_standard_licence_cores = sql_config['enterprise_licence_cores']\r\n",
							"\r\n",
							"sql_normalized_licence_cores = (4 * sql_enterprise_licence_cores) + sql_standard_licence_cores"
						],
						"outputs": [],
						"execution_count": 158
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load and filter usage "
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"columns_to_keep = [\r\n",
							"    'SubscriptionId',\r\n",
							"    'SubscriptionName',\r\n",
							"    'Date',\r\n",
							"    'ResourceGroup', \r\n",
							"    'ResourceName', \r\n",
							"    'ResourceId', \r\n",
							"    'MeterCategory', \r\n",
							"    'MeterSubCategory', \r\n",
							"    'MeterName',\r\n",
							"    'UnitOfMeasure',\r\n",
							"    'Quantity',\r\n",
							"    'UnitPrice',\r\n",
							"    'EffectivePrice',\r\n",
							"    'CostInBillingCurrency', \r\n",
							"    'ServiceInfo2',\r\n",
							"    'PartNumber',\r\n",
							"    'ProductName', \r\n",
							"    'ai_VCPUs',\r\n",
							"    'ai_AHB'\r\n",
							"]\r\n",
							"\r\n",
							"sql_columns = columns_to_keep + [\r\n",
							"    'SQLAHB',\r\n",
							"    'SQLAHB_VCPUs',\r\n",
							"    'ai_vCores'\r\n",
							"]"
						],
						"outputs": [],
						"execution_count": 159
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_path = monthly_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 160
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Only select usage from the period specified in the configuration file\r\n",
							"sql_start_date = (datetime.now() - timedelta(days=sql_days_back_from+3)).strftime('%Y-%m-%d')\r\n",
							"sql_end_date = (datetime.now() - timedelta(days=sql_days_back_to)).strftime('%Y-%m-%d')\r\n",
							"cost_df = cost_df.where((F.col('Date') >= sql_start_date) & (F.col('Date') <= sql_end_date))\r\n",
							"\r\n",
							"# Compute the interval in days and hours of the specified interval\r\n",
							"sql_max_date = cost_df.agg(F.max('Date')).collect()[0][0]\r\n",
							"sql_min_date = cost_df.agg(F.min('Date')).collect()[0][0]\r\n",
							"sql_interval_days = (sql_max_date - sql_min_date).days + 1\r\n",
							"sql_interval_hours = sql_interval_days * 24"
						],
						"outputs": [],
						"execution_count": 162
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_df = cost_df.select(*sql_columns)\r\n",
							"cost_df = cost_df.where(F.col('MeterSubCategory').isin(sql_metersubcategory_array))\r\n",
							"cost_df = cost_df.where(~F.upper(F.col('ResourceName')).startswith('CVD-'))\r\n",
							"\r\n",
							"is_sql_vm = (F.col('MeterCategory') == 'Virtual Machines Licenses') & (F.col('MeterSubCategory').like('SQL Server%'))\r\n",
							"is_sql_db = (F.col('ResourceId').like('%Microsoft.Sql/servers%')) & (F.col('MeterCategory').like('SQL%'))\r\n",
							"is_sql_mi = (F.col('ResourceId').like('%Microsoft.Sql/managedInstances%')) & (F.col('MeterCategory').like('SQL%'))\r\n",
							"\r\n",
							"# Split SQL usage into different categories\r\n",
							"cost_df = cost_df.withColumn('SQLType', \r\n",
							"    F.when(is_sql_vm, 'VM')\r\n",
							"    .when(is_sql_mi, 'MI')\r\n",
							"    .when(is_sql_db, 'DB')\r\n",
							"    .otherwise(None)\r\n",
							")\r\n",
							"\r\n",
							"# Determine priority of SQL instances of getting HUB enabled - higher number indicates higher priority\r\n",
							"cost_df = cost_df.withColumn('Priority',\r\n",
							"    F.when(is_sql_mi & (F.col('ProductName').contains('General Purpose')), 6)\r\n",
							"    .when(is_sql_mi & (F.col('ProductName').contains('Business Critical')), 5)\r\n",
							"    .when(is_sql_db & (F.col('ProductName').contains('General Purpose')), 4)\r\n",
							"    .when(is_sql_vm & (F.col('ProductName').startswith('SQL Server Enterprise') | (F.col('ProductName') == 'SQL Server Azure Hybrid Benefit - Enterprise Edition License')), 3)\r\n",
							"    .when(is_sql_db & (F.col('ProductName').contains('Business Critical')), 2)\r\n",
							"    .when(is_sql_vm & (F.col('ProductName').startswith('SQL Server Standard') | (F.col('ProductName') == 'SQL Server Azure Hybrid Benefit - Standard Edition License')), 1)\r\n",
							"    .otherwise(0)\r\n",
							")\r\n",
							"\r\n",
							"cost_df = cost_df.where(F.col('SQLType').isNotNull())\r\n",
							"cost_copy_df = cost_df.alias('cost_copy_df')"
						],
						"outputs": [],
						"execution_count": 163
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute set of SQL instances getting HUB enabled"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Max aggregation on vCores are used to mitigate duplicate instances, as they can occur if # of vCores are altered on a given day\r\n",
							"sql_enable_df = cost_df \\\r\n",
							"    .select('ResourceId', 'SubscriptionId', 'ResourceGroup', 'ResourceName', 'Quantity', 'ai_VCPUs', 'ai_vCores', 'SQLAHB_VCPUs', 'SQLType', 'Priority') \\\r\n",
							"    .groupBy('ResourceId', 'SubscriptionId', 'ResourceGroup', 'ResourceName', 'ai_VCPUs', 'SQLType', 'Priority') \\\r\n",
							"    .agg(F.sum('Quantity').alias('ResourceHours'), F.max('ai_vCores').alias('vCores'), F.max('SQLAHB_VCPUs').alias('SQLAHB_VCPUs')) \r\n",
							"\r\n",
							"# SQL VM instances will have a quantity per resource per day at 0-24 hours\r\n",
							"vm_utilization = F.col('ResourceHours') / sql_interval_hours\r\n",
							"\r\n",
							"# SQL MI and DB instances will have a quantity per resource per day at 0-24 hours * vCores\r\n",
							"resource_hours_per_core = F.col('ResourceHours') / F.col('vCores')\r\n",
							"\r\n",
							"mi_utilization = resource_hours_per_core / sql_interval_hours\r\n",
							"db_utilization = resource_hours_per_core / sql_interval_hours\r\n",
							"\r\n",
							"sql_enable_df = sql_enable_df.withColumn('Utilization',\r\n",
							"    F.when(F.col('SQLType') == 'VM', vm_utilization)\r\n",
							"    .when(F.col('SQLType') == 'DB', db_utilization)\r\n",
							"    .when(F.col('SQLType') == 'MI', mi_utilization)\r\n",
							"    .otherwise(0)\r\n",
							")\r\n",
							"\r\n",
							"# Sort resources according to which we want to enable HUB for first\r\n",
							"sql_enable_df = sql_enable_df.orderBy(F.desc('Priority'), F.desc('Utilization'))\r\n",
							"\r\n",
							"window = W.Window.rowsBetween(W.Window.unboundedPreceding, 0)\r\n",
							"sql_enable_df = sql_enable_df.withColumn(\"TotalNormalizedCores\", F.sum(\"SQLAHB_VCPUs\").over(window))\r\n",
							"\r\n",
							"# Only include instances that doesnt overshoot the number of available license cores\r\n",
							"sql_enable_df = sql_enable_df.where(F.col('TotalNormalizedCores') <= sql_normalized_licence_cores)\r\n",
							"\r\n",
							"# Persist copy for activity log computation\r\n",
							"enable_copy_df = sql_enable_df.alias('enable_copy_df')\r\n",
							"\r\n",
							"# Remove redundant columns from results\r\n",
							"sql_enable_df = sql_enable_df.select('ResourceId', 'SubscriptionId', 'ResourceName', 'ResourceGroup')"
						],
						"outputs": [],
						"execution_count": 164
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute set of SQL instances getting HUB disabled"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Compute list of disabled instances by removing references from the enabled liste\r\n",
							"sql_disable_df = cost_copy_df.where(F.col('SQLAHB') == 'Enabled')\r\n",
							"sql_disable_df = sql_disable_df.select('ResourceId', 'SubscriptionId', 'ResourceName', 'ResourceGroup')\r\n",
							"sql_disable_df = sql_disable_df.dropDuplicates([\"ResourceId\"])\r\n",
							"sql_disable_df = sql_disable_df.join(sql_enable_df, 'ResourceId', 'left_anti')"
						],
						"outputs": [],
						"execution_count": 165
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Store HUB deployment results and update activity log"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_activity_log_entry(activity_path):\r\n",
							"    csv_options = {'header' : True,\r\n",
							"                'delimiter' : ',',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"    activity_df = spark.read.options(**csv_options).csv(activity_path)\r\n",
							"\r\n",
							"    # Compute the number of cores ACTUALLY assigned\r\n",
							"    sql_assigned_cores = enable_copy_df.agg(F.max('TotalNormalizedCores')).collect()[0][0]\r\n",
							"\r\n",
							"    # Aggregate normalized core per priority level \r\n",
							"    normalized_cores_by_priority = enable_copy_df.select('SQLAHB_VCPUs', 'Priority').groupBy('Priority').agg(F.sum('SQLAHB_VCPUs').alias('TotalCores')).collect()\r\n",
							"\r\n",
							"    # Loop through aggregations and persist values in array \r\n",
							"    activity_values = [0, 0, 0, 0, 0, 0]\r\n",
							"    index = 0\r\n",
							"    for value in normalized_cores_by_priority:\r\n",
							"        activity_values[index] = value['TotalCores']\r\n",
							"        index+=1\r\n",
							"\r\n",
							"    today = (datetime.now().strftime('%Y-%m-%d'))\r\n",
							"    new_activity_row = spark.createDataFrame([(today, *activity_values, sql_normalized_licence_cores, sql_assigned_cores)], activity_df.columns)\r\n",
							"    activity_df = activity_df.union(new_activity_row)\r\n",
							"\r\n",
							"    return activity_df"
						],
						"outputs": [],
						"execution_count": 148
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"enable_path = 'abfss://sql-hub-logs-v2@hubautomation.dfs.core.windows.net/LATEST-AHUB-Deployment.csv'\r\n",
							"disable_path = 'abfss://sql-hub-logs-v2@hubautomation.dfs.core.windows.net/LATEST-AHUB-Removal.csv'\r\n",
							"activity_path = 'abfss://sql-activity-v2@hubautomation.dfs.core.windows.net/activity.csv'\r\n",
							"\r\n",
							"if should_run:\r\n",
							"    # Store enabled list in storage account\r\n",
							"    sql_enable_df.toPandas().to_csv(enable_path)\r\n",
							"\r\n",
							"    # Store disabled list in storage account\r\n",
							"    sql_disable_df.toPandas().to_csv(disable_path)\r\n",
							"\r\n",
							"    # Compute activity log entry and write back to file\r\n",
							"    activity_df = compute_activity_log_entry(activity_path)\r\n",
							"    activity_df.toPandas().to_csv(activity_path, index=False)"
						],
						"outputs": [],
						"execution_count": 149
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Output 'should_run' indication when running in pipeline\r\n",
							"mssparkutils.notebook.exit(should_run)"
						],
						"outputs": [],
						"execution_count": 150
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/test-core-assignment')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('test-core-assignment_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "ba52a84c-b785-4f63-a166-d9fb13d4c25d"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('test-core-assignment_notebookSparkPoolIdRef')]",
						"name": "[parameters('test-core-assignment_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('test-core-assignment_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 47
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 48
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pre_date = '2024-03-12'\r\n",
							"post_date = '2024-03-14'\r\n",
							"deploy_date = '2024-03-13'\r\n",
							"start_of_month = '2024-03-01'\r\n",
							"end_of_month = '2024-03-31'"
						],
						"outputs": [],
						"execution_count": 49
					},
					{
						"cell_type": "code",
						"source": [
							"test_path = f'abfss://win-hub-logs@hubautomation.dfs.core.windows.net/{deploy_date}-AHUB-Deployment.csv'\r\n",
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ';',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"add_df = spark.read.options(**csv_options).csv(test_path)\r\n",
							"\r\n",
							"add_ids = [row[0] for row in add_df.select(\"ResourceId\").collect()]\r\n",
							"\r\n",
							"test_path = f'abfss://win-hub-logs@hubautomation.dfs.core.windows.net/{deploy_date}-AHUB-Removal.csv'\r\n",
							"csv_options = {'header' : True,\r\n",
							"                'delimiter' : ';',\r\n",
							"                'quote' : '\"',\r\n",
							"                'escape' : '\"'}\r\n",
							"rm_df = spark.read.options(**csv_options).csv(test_path)\r\n",
							"\r\n",
							"rm_ids = [row[0] for row in rm_df.select(\"ResourceId\").collect()]\r\n",
							"\r\n",
							"cost_path = monthly_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/{start_of_month.replace(\"-\", \"\")}-{end_of_month.replace(\"-\", \"\")}/Extended_v3_ACMMonthlyActualCost_{start_of_month.replace(\"-\", \"\")}-{end_of_month.replace(\"-\", \"\")}.parquet'\r\n",
							"test_cost = spark.read.format('parquet').load(cost_path)\r\n",
							"\r\n",
							"cost_pre = test_cost.where(F.col('Date') == pre_date)\r\n",
							"cost_pre_ne = cost_pre.where(F.col('WindowsAHB') == 'Not Enabled').dropDuplicates(['ResourceId'])\r\n",
							"cost_pre = cost_pre.where(F.col('WindowsAHB') == 'Enabled').dropDuplicates(['ResourceId'])\r\n",
							"\r\n",
							"cost_today = test_cost.where(F.col('Date') >= start_of_month)\r\n",
							"cost_today_ne = cost_today.where(F.col('WindowsAHB') == 'Not Enabled').dropDuplicates(['ResourceId'])\r\n",
							"cost_today = cost_today.where(F.col('WindowsAHB') == 'Enabled').dropDuplicates(['ResourceId'])\r\n",
							"\r\n",
							"cost_post = test_cost.where(F.col('Date') == post_date)\r\n",
							"cost_post_ne = cost_post.where(F.col('WindowsAHB') == 'Not Enabled').dropDuplicates(['ResourceId'])\r\n",
							"cost_post = cost_post.where(F.col('WindowsAHB') == 'Enabled').dropDuplicates(['ResourceId'])\r\n",
							"\r\n",
							"pre_ids = [row[0] for row in cost_pre.select(\"ResourceId\").collect()]\r\n",
							"post_ids = [row[0] for row in cost_post.select(\"ResourceId\").collect()]\r\n",
							"\r\n",
							"pre = set(pre_ids)\r\n",
							"post = set(post_ids)\r\n",
							"added = set(add_ids)\r\n",
							"removed = set(rm_ids)\r\n",
							"\r\n",
							"kept = pre.intersection(post)\r\n",
							"diff = added.intersection(pre)\r\n",
							"\r\n",
							"add_w_vcpu = add_df.join(cost_today, 'ResourceId', 'left')\r\n",
							"rm_w_vcpu = rm_df.join(cost_today, 'ResourceId', 'left')"
						],
						"outputs": [],
						"execution_count": 51
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Calculate over/under assignment of HUB\r\n",
							"1. Compute # of resources with HUB and # of VCPUs on 12th of March (pre) **318** (2025)\r\n",
							"2. Compute # of resources with HUB and # of VCPUs on 14th of March (post) **294** (2689)\r\n",
							"3. Compute # of resources with HUB enabled and # of VCPUs on 13th of March (added) **313** (1341)\r\n",
							"\r\n",
							"- **11** of these resources does not exist any longer, and deployment fails for these. These account for **80** normalized cores\r\n",
							"\r\n",
							"4. Compute # of resources with HUB disabled and # of VCPUs on 13th of March (removed) **50** (528)\r\n",
							"5. How many resources/vCPUs was included kept from 12th to 14th (kept)? **243** (1289)\r\n",
							"\r\n",
							"- **9** of the resources marked as _HUB Enabled_ is not reflected in the normalized core column. These are **Azure Arc-Enabled SQL Server** instances and amount to **184** normalized cores (but are not reflected in the extend files)\r\n",
							" \r\n",
							"6. How many resources/vCPUs was similar on the 12th and the enabled list? (1199)\r\n",
							"7. How many resources/vCPUs was similar on the 14th and the enabled list?\r\n",
							"8. How many resources in the disabled list was enabled on the 12th? (should be all)\r\n",
							"9. How many resources in the disabled list was enabled on the 14th? (should be none)\r\n",
							"10. How many resources on the enable list was not enabled on the 14th?\r\n",
							"11. How many enabled resources on the 14th was not in the enable list?\r\n",
							"12. How many resources was failed to enabled/diabled on the 13th?\r\n",
							"\r\n",
							"\r\n",
							"- Are more/less normalized cores being enabled than available licenses?\r\n",
							"- Get list of resources not being enabled that should be enabled\r\n",
							"- Get list of resources that are enabled but are not in the enabled list\r\n",
							"- Do the same for Windows HUB\r\n",
							"\r\n",
							"### SUMMARY\r\n",
							"\r\n",
							"HOW MANY RESOURCES ON 12th\r\n",
							"\r\n",
							"HOW MANY ENABLED ON 13th\r\n",
							"\r\n",
							"HOW MANY RESOURCE ON 14th\r\n",
							"\r\n",
							"HOW MANY RESOURCES ON 12th NOT IN ENABLED LIST\r\n",
							"\r\n",
							"HOW MANY RESOURCES ON 14th NOT IN ENABLED LIST"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pre_count = cost_pre.count()\r\n",
							"pre_cores = cost_pre.agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]\r\n",
							"post_count = cost_post.count()\r\n",
							"post_cores = cost_post.agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 52
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"added_count = add_w_vcpu.count()\r\n",
							"added_cores = add_w_vcpu.agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]\r\n",
							"added_not_exists_count = add_w_vcpu.where(F.col('WindowsAHB').isNull()).count() or 0\r\n",
							"added_not_exists_cores = add_w_vcpu.where(F.col('WindowsAHB').isNull()).agg(F.sum('ai_VCPUs')).collect()[0][0] or 0 # Not normalized"
						],
						"outputs": [],
						"execution_count": 64
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"rm_count = rm_w_vcpu.count()\r\n",
							"rm_cores = rm_w_vcpu.agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 55
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"kept_count = cost_today.where(F.col('ResourceId').isin(kept)).count()\r\n",
							"kept_cores = cost_today.where(F.col('ResourceId').isin(kept)).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 56
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pre_added_count = cost_today.where(F.col('ResourceId').isin(pre.intersection(added))).count()\r\n",
							"pre_added_cores = cost_today.where(F.col('ResourceId').isin(pre.intersection(added))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 57
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"post_added_count = cost_today.where(F.col('ResourceId').isin(post.intersection(added))).count()\r\n",
							"post_added_cores = cost_today.where(F.col('ResourceId').isin(post.intersection(added))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 58
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pre_removed_count = cost_today.where(F.col('ResourceId').isin(pre.intersection(removed))).count()\r\n",
							"pre_removed_cores = cost_today.where(F.col('ResourceId').isin(pre.intersection(removed))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]\r\n",
							"\r\n",
							"post_removed_count = cost_today.where(F.col('ResourceId').isin(post.intersection(removed))).count()\r\n",
							"post_removed_cores = cost_today.where(F.col('ResourceId').isin(post.intersection(removed))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0] or 0"
						],
						"outputs": [],
						"execution_count": 59
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"post_added_ne_count = cost_post_ne.where(F.col('ResourceId').isin(added)).count()\r\n",
							"post_added_ne_cores = cost_post_ne.where(F.col('ResourceId').isin(added)).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 60
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"post_not_in_added_count = cost_post.where(F.col('ResourceId').isin(post.difference(added))).count()\r\n",
							"post_not_in_added_cores = cost_post.where(F.col('ResourceId').isin(post.difference(added))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 61
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pre_not_in_added_count = cost_pre.where(F.col('ResourceId').isin(pre.difference(added))).count()\r\n",
							"pre_not_in_added_cores = cost_pre.where(F.col('ResourceId').isin(pre.difference(added))).agg(F.sum('WindowsAHB_VCPUS')).collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 62
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(f\"Number of resources with HUB on date before deployment {pre_date}: {pre_count} ({pre_cores} normalized cores)\")\r\n",
							"print(f\"Number of resources in HUB deployment on {deploy_date}: {added_count} ({added_cores} normalized cores)\")\r\n",
							"print(f\"Number of resource with HUB on date after deployment {post_date}: {post_count} ({post_cores} normalized cores)\")\r\n",
							"print(' ')\r\n",
							"print(f\"Expected number of HUB resources on {post_date}: {added_count} ({added_cores} normalized cores)\")\r\n",
							"print(f\"Actual number of HUB resources on {post_date}: {post_count} ({post_cores} normalized cores)\")\r\n",
							"print(' ')\r\n",
							"print(f\"Number of resources scheduled for HUB deployment that doesn't exist per {deploy_date}: {added_not_exists_count} ({added_not_exists_cores} NOT normalized cores)\")\r\n",
							"print(f\"The new expected number of HUB resources on {post_date}: {added_count - added_not_exists_count} ({added_cores - added_not_exists_cores} NOT normalized cores)\")\r\n",
							"print(' ')\r\n",
							"print(f\"Out of the {pre_count} HUB resources day before deployment, {rm_count} were scheduled for removal ({rm_cores} normalized cores)\")\r\n",
							"print(f\"Out of the {rm_count} HUB resources scheduled for removal on {deploy_date}, {pre_removed_count} ({pre_removed_cores} normalized cores) resources had HUB deployed on {pre_date}\")\r\n",
							"print('')\r\n",
							"print(f\"Out of the {pre_count} HUB resources from {pre_date}, {kept_count} ({kept_cores} normalized cores) of the same resources still had HUB applied {post_date}\")\r\n",
							"print(f\"Out of the {pre_count} HUB resources from {pre_date}, {pre_added_count} ({pre_added_cores} normalized cores) of the same resources were in the deploy list on {deploy_date}\")\r\n",
							"print(f\"Out of the {post_count} HUB resources from {post_date}, {post_added_count} ({post_added_cores} normalized cores) of the same resources were in the deploy list on {deploy_date}\")\r\n",
							"print(' ')\r\n",
							"print(f\"{post_added_ne_count} ({post_added_ne_cores} normalized cores) resources that were scheduled for deployment on {deploy_date}, did not have HUB enabled on {post_date}\")\r\n",
							"print(' ')\r\n",
							"print(f\"Out of the {post_count} HUB resources on {post_date}, there are {post_not_in_added_count} ({post_not_in_added_cores} normalized cores) that are not referenced on the deployment list on {deploy_date}\")\r\n",
							"print(f\"Out of the {pre_count} HUB resources on {pre_date}, there are {pre_not_in_added_count} ({pre_not_in_added_cores} normalized cores) that are not referenced on the deployment list on {deploy_date}\")\r\n",
							"print(\" \")\r\n",
							"\r\n",
							"expected_count = added_count\r\n",
							"expected_cores = added_cores\r\n",
							"print(f\"Having {expected_count} ({expected_cores} normalized cores) resources scheduled for deployment, but there are {post_count} ({post_cores} normalized cores) HUB resources day after deployment\")\r\n",
							"\r\n",
							"expected_count -= added_not_exists_count\r\n",
							"expected_cores -= added_not_exists_cores\r\n",
							"print(f\"Subtracting the scheduled resources that doesent exist {added_not_exists_count} ({added_not_exists_cores} NOT normalized cores), we can expect {expected_count} ({expected_cores} normalized cores) resources for deployment\")\r\n",
							"\r\n",
							"expected_post_count = post_not_in_added_count + expected_count\r\n",
							"expected_post_cores = post_not_in_added_cores + expected_cores\r\n",
							"print(f\"Taking into account the resources with HUB post deployment that weren't referenced in HUB schedule {post_not_in_added_count} ({post_not_in_added_cores} normalized cores), the expected number of HUB resources day after deployment should be {expected_post_count} ({expected_post_cores} normalized cores)\")\r\n",
							"\r\n",
							"expected_diff_count = expected_post_count - post_count \r\n",
							"expected_diff_cores = expected_post_cores - post_cores\r\n",
							"print(f\"Conclusion: there are being deployed {expected_diff_count} ({expected_diff_cores} normalized cores) less HUB resources than expected\")"
						],
						"outputs": [],
						"execution_count": 65
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/usersWithBusinessAreaSnapshot_v1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/MicrosoftGraph_AzureAD"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('usersWithBusinessAreaSnapshot_v1_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "28g",
					"driverCores": 4,
					"executorMemory": "28g",
					"executorCores": 4,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "10a1aa61-123b-4c32-8109-ab9acd0a01aa"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('usersWithBusinessAreaSnapshot_v1_notebookSparkPoolIdRef')]",
						"name": "[parameters('usersWithBusinessAreaSnapshot_v1_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('usersWithBusinessAreaSnapshot_v1_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"This notebook creates a dataset of employee ID, shortname, Business Area and sub-Business Area (e.g. BA: PDP, subBA: PDP PSR). The BA and subBA is found from the employee's manager at level 2 and 3. The employee hierarchy has been made in another notebook (usersWithManagerSnapshot_v1). Both notebooks use the same inital raw-dataset from ADLS from graphAPI (AzureADUsersWithManager_)."
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"source": [
							"# %pip install -U pandas==1.5.3"
						],
						"outputs": [],
						"execution_count": 118
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd\r\n",
							"from pyspark.sql import SparkSession"
						],
						"outputs": [],
						"execution_count": 1
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"container = 'usage'\r\n",
							"file_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + 'AzureAD_BusinessAreaLevel/bronze/AzureAD_EmployeesManagersSnapshot.parquet'\r\n",
							"\r\n",
							"df_users = spark.read.format('parquet').load(file_path).toPandas()\r\n",
							"# df_users.head(10)"
						],
						"outputs": [],
						"execution_count": 120
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"#### Load Hierarchy-dataframe from ADLS optimized"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Get Hierarchy-dataframe from ADLS\n",
							"file_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + 'AzureAD_BusinessAreaLevel/silver/usersWithManagerSnapshot_v1.parquet'\n",
							"\n",
							"employees = spark.read.format('parquet').load(file_path).toPandas()\n",
							"# employees.head(10)"
						],
						"outputs": [],
						"execution_count": 121
					},
					{
						"cell_type": "markdown",
						"source": [
							"# Transforming Azure AD raw-data"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_users.shape[0]}\")\n",
							"\n",
							"# Filter out disabled accounts\n",
							"df_users = df_users[df_users.accountEnabled == True]\n",
							"\n",
							"# Drop rows with no employee ID\n",
							"df_users = df_users.dropna(subset=['employeeId'])\n",
							"\n",
							"print(f\"New length of the dataset is: {df_users.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 122
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Split email and filter out equinor-domain\n",
							"cannot call on NoneType, need to rename first:\n",
							"df_users = df_users.fillna({'department': 'missing'})"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Getting the username by splitting e-mail name before \"@\"-symbol\n",
							"df_users['userName'] = [email[:email.find('@')] for email in df_users['userPrincipalName']]\n",
							"\n",
							"# Getting the domain name by splitting e-mail after \"@\"-symbol\n",
							"df_users['domain'] = [email[email.find('@'):] for email in df_users['userPrincipalName']]"
						],
						"outputs": [],
						"execution_count": 123
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_users.shape[0]}\")\n",
							"\n",
							"# Only include empoyees who has a email address with domain-name equinor.com\n",
							"df_users = df_users[df_users.domain == '@equinor.com']\n",
							"\n",
							"# Delete non-valid employeeIDs\n",
							"df_users = df_users[df_users['employeeId'] != 'FunctionKey']\n",
							"\n",
							"print(f\"New length of the dataset is: {df_users.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 124
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Dropping and store duplicates"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# # Display the duplicates\n",
							"# df_users[df_users['employeeId'].isin(df_users.employeeId.value_counts().loc[lambda x: x>1].index)].sort_values(by=['employeeId'])"
						],
						"outputs": [],
						"execution_count": 125
					},
					{
						"cell_type": "code",
						"source": [
							"# First isolate all duplicates that we want to remove. In this instance there is one duplicate that contains employee information, and another that does not.\n",
							"# All duplicates without information will be isolated in a variable and removed from the dataset\n",
							"\n",
							"# Where employeeId don't occur more than once \n",
							"mask1 = df_users['employeeId'].isin(df_users.employeeId.value_counts().loc[lambda x: x>1].index)\n",
							"\n",
							"# Where users have empty values in the columns specified\n",
							"mask2 = df_users['department'].isna()\n",
							"mask3 = df_users['manager_employeeId'].isna()\n",
							"mask4 = df_users['manager_displayName'].isna()\n",
							"mask5 = df_users['manager_userPrincipalName'].isna()\n",
							"mask6 = df_users['manager_department'].isna()\n",
							"\n",
							"# Where the username contains sub-string 'ja_'\n",
							"mask7 = df_users['userName'].str.contains('ja_')\n",
							"\n",
							"duplicates = df_users[mask1 & mask2 & mask3 & mask4 & mask5 | mask6 & mask7]\n",
							"\n",
							"df_users = df_users.drop(duplicates.index)"
						],
						"outputs": [],
						"execution_count": 126
					},
					{
						"cell_type": "code",
						"source": [
							"# some users are registrered with two different employeeId and corresponding department, manager etc. but the same displayName\n",
							"# df_users[df_users['displayName'].isin(df_users.displayName.value_counts().loc[lambda x: x>1].index)].sort_values(by=['displayName'])"
						],
						"outputs": [],
						"execution_count": 127
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Merge Hierarchy-dataframe from ADLS-opt to raw-data\n",
							"Only looking at employeeID - managerID and find all corresponding departments (business area)"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# merge employeeId+department to the user hierarchy for employee and manager 2, 3, 4\n",
							"employees = employees.merge(df_users[['employeeId', 'department']],\n",
							"                            left_on='employeeId_0',\n",
							"                            right_on='employeeId',\n",
							"                            how='left').drop(columns={'employeeId'}).rename(columns={'department':'departmentEmployee'})\n",
							"\n",
							"employees = employees.merge(df_users[['employeeId', 'department']],\n",
							"                            left_on='Manager2',\n",
							"                            right_on='employeeId',\n",
							"                            how='left').drop(columns={'employeeId'}).rename(columns={'department':'departmentManager2'})\n",
							"\n",
							"employees = employees.merge(df_users[['employeeId', 'department']],\n",
							"                            left_on='Manager3', \n",
							"                            right_on='employeeId',\n",
							"                            how='left').drop(columns={'employeeId'}).rename(columns={'department':'departmentManager3'})\n",
							"\n",
							"employees = employees.merge(df_users[['employeeId', 'department']],\n",
							"                            left_on='Manager4',\n",
							"                            right_on='employeeId',\n",
							"                            how='left').drop(columns={'employeeId'}).rename(columns={'department':'departmentManager4'})"
						],
						"outputs": [],
						"execution_count": 128
					},
					{
						"cell_type": "code",
						"source": [
							"# Due to poor data quality, multiple employeers will have the wrong Manager1 for two reasons:\n",
							"# employeeId has itself listed as manager OR two employees have each other listed as managers\n",
							"# in these cases Manager1 has been sat to '0'\n",
							"# Rename these instances to \"No data\"\n",
							"employees['departmentManager2'] = employees.apply(lambda x: 'No data' if x['Manager1'] =='0' else x['departmentManager2'], axis=1)\n",
							"employees['departmentManager3'] = employees.apply(lambda x: 'No data' if x['Manager1'] =='0' else x['departmentManager3'], axis=1)\n",
							"employees['departmentManager4'] = employees.apply(lambda x: 'No data' if x['Manager1'] =='0' else x['departmentManager4'], axis=1)"
						],
						"outputs": [],
						"execution_count": 129
					},
					{
						"cell_type": "code",
						"source": [
							"# # Azure AD users with no information about their department/business area due to data quality\n",
							"# employees[employees.Manager1 == '0'].display()"
						],
						"outputs": [],
						"execution_count": 130
					},
					{
						"cell_type": "code",
						"source": [
							"# # Count number of employees under each Business Area (on Manager level 2)\n",
							"# df_grouped= employees.groupby(['departmentManager2'])['departmentManager2'].count()\n",
							"# df_grouped_sorted = df_grouped.sort_values()\n",
							"# print(df_grouped_sorted)"
						],
						"outputs": [],
						"execution_count": 131
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Set Business Area, Business Area Level 1 and Business Area Level 2 "
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Set BusinessArea equal to each employees level 2 managers department\n",
							"employees['businessArea'] = employees['departmentManager2'].apply(lambda x: x)"
						],
						"outputs": [],
						"execution_count": 132
					},
					{
						"cell_type": "code",
						"source": [
							"# Set BusinessArea Level 1 equal to each employees level 3 managers department\n",
							"employees['businessAreaLevel1'] = employees['departmentManager3'].apply(lambda x: x)"
						],
						"outputs": [],
						"execution_count": 133
					},
					{
						"cell_type": "code",
						"source": [
							"# Set BusinessArea Level 2 equal to each employees level 4 managers department\n",
							"employees['businessAreaLevel2'] = employees['departmentManager4'].apply(lambda x: x)"
						],
						"outputs": [],
						"execution_count": 134
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"### Special cases\n",
							"Save for later just in case"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# # Set BusinessArea for FLX\n",
							"# employees['businessArea']= employees.apply(lambda x: x['departmentManager3'] if x['departmentManager3'] =='FLX' else x['businessArea'], axis=1)\n",
							"\n",
							"# # Set subBusinessArea for FLX\n",
							"# employees['subBusinessArea']= employees.apply(lambda x: x['departmentManager4'] if x['businessArea'] =='FLX' else x['subBusinessArea'], axis=1)"
						],
						"outputs": [],
						"execution_count": 135
					},
					{
						"cell_type": "code",
						"source": [
							"# # Set BusinessArea for \"CFO FCoE\"\n",
							"# employees['businessArea']= employees.apply(lambda x: 'CFO FCOE' if ('CFO FCOE' in str(x['departmentManager3'])) else x['businessArea'], axis=1)\n",
							"\n",
							"# # Set subBusinessArea for \"CFO FCoE\"\n",
							"# employees['subBusinessArea']= employees.apply(lambda x: x['departmentManager4'] if ('CFO FCOE' in str(x['businessArea'])) else x['subBusinessArea'], axis=1)"
						],
						"outputs": [],
						"execution_count": 136
					},
					{
						"cell_type": "code",
						"source": [
							"# # Set BusinessArea for \"PDP DW\"\n",
							"# employees['BusinessArea']= employees.apply(lambda x: 'PDP DW' if ('PDP DW' in str(x['Manager3_department'])) else x['BusinessArea'], axis=1)\n",
							"\n",
							"# # Set BusinessArea for \"PDP PSR\"\n",
							"# employees['BusinessArea']= employees.apply(lambda x: 'PDP PSR' if ('PDP PSR' in str(x['Manager3_department'])) else x['BusinessArea'], axis=1)\n",
							"\n",
							"# # Set BusinessArea for \"PDP PRD\"\n",
							"# employees['BusinessArea']= employees.apply(lambda x: 'PDP PRD' if ('PDP PRD' in str(x['Manager3_department'])) else x['BusinessArea'], axis=1)"
						],
						"outputs": [],
						"execution_count": 137
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Cleanup, add username/shortname"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# add username/shortname to dataframe\n",
							"employees = employees.merge(df_users[['employeeId', 'userName', 'userPrincipalName']],\n",
							"                            left_on='employeeId_0',\n",
							"                            right_on='employeeId',\n",
							"                            how='left')"
						],
						"outputs": [],
						"execution_count": 138
					},
					{
						"cell_type": "code",
						"source": [
							"# only keep relevant columns\n",
							"employees_short = employees[['employeeId',\n",
							"                             'userName',\n",
							"                             'userPrincipalName',\n",
							"                             'businessArea',\n",
							"                             'businessAreaLevel1',\n",
							"                             'businessAreaLevel2']].copy()\n",
							"\n",
							"employees_short = employees_short.rename(columns={'userPrincipalName' : 'email'})\n",
							"\n",
							"employees_short['email'] = employees_short['email'].str.lower()\n",
							"employees_short['userName'] = employees_short['userName'].str.upper()"
						],
						"outputs": [],
						"execution_count": 139
					},
					{
						"cell_type": "code",
						"metadata": {
							"collapsed": false
						},
						"source": [
							"finops = ['TSC', 'DFLOO', 'TCNY', 'JOMT']\r\n",
							"\r\n",
							"display(employees_short[employees_short['userName'].isin(finops)])"
						],
						"outputs": [],
						"execution_count": 142
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"print(f\" Duplicated usernames: {len(employees_short['userName'].value_counts().loc[lambda x: x>1])}\")\r\n",
							"\r\n",
							"print(f\" Duplicated employee IDs: {len(employees_short['employeeId'].value_counts().loc[lambda x: x>1])}\")\r\n",
							"\r\n",
							"print(f\" Duplicated e-mails: {len(employees_short['email'].value_counts().loc[lambda x: x>1])}\")"
						],
						"outputs": [],
						"execution_count": 141
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Write to optimized"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"#Set optimized path\n",
							"optimized_path = file_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/' + 'AzureAD_BusinessAreaLevel/gold/usersWithBusinessAreaSnapshot_v1.parquet'\n",
							"\n",
							"df_spark = spark.createDataFrame(employees_short)\n",
							"\n",
							"df_spark.write.format('parquet').mode('overwrite').save(optimized_path)\n",
							"#df_spark.write.format('parquet').mode('overwrite').option('overwriteSchema', 'True').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 108
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Clear cache in Spark session"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"currentSparkSession = SparkSession.builder.getOrCreate()\r\n",
							"spark.catalog.clearCache()"
						],
						"outputs": [],
						"execution_count": 2
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/usersWithManagerSnapshot_v1')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/MicrosoftGraph_AzureAD"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('usersWithManagerSnapshot_v1_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"runAsWorkspaceSystemIdentity": false,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "f674e7f4-c77c-436b-91cd-d4afe0ff1698"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('usersWithManagerSnapshot_v1_notebookSparkPoolIdRef')]",
						"name": "[parameters('usersWithManagerSnapshot_v1_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('usersWithManagerSnapshot_v1_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"container = 'usage'\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "markdown",
						"source": [
							"# Transforming Azure AD user-hierarchy"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"import numpy as np\n",
							"import pandas as pd"
						],
						"outputs": [],
						"execution_count": 100
					},
					{
						"cell_type": "markdown",
						"source": [
							"### Importing the raw data"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"file_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/AzureAD_BusinessAreaLevel/bronze/AzureAD_EmployeesManagersSnapshot.parquet'\n",
							"\n",
							"# Read in the dataframe using Spark and transform it into a Pandas-core DataFrame\n",
							"df_users = spark.read.format('parquet').load(file_path).toPandas()\n",
							"# df_users.head(10)"
						],
						"outputs": [],
						"execution_count": 101
					},
					{
						"cell_type": "markdown",
						"source": [
							"### Cleaning the data"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_users.shape[0]}\")\n",
							"\n",
							"# Filter out disabled accounts\n",
							"df_users = df_users[df_users.accountEnabled == True]\n",
							"\n",
							"# Drop rows with no employee ID\n",
							"df_users = df_users.dropna(subset=['employeeId'])\n",
							"\n",
							"print(f\"New length of the dataset is: {df_users.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 102
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Split email and filter out Equinor-domain\n",
							"cannot call on NoneType, need to rename first: \n",
							"df_users = df_users.fillna({'department': 'missing'})"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Getting the username by splitting e-mail name before \"@\"-symbol\n",
							"df_users['userName'] = [email[:email.find('@')] for email in df_users['userPrincipalName']]\n",
							"\n",
							"# Getting the domain name by splitting e-mail after \"@\"-symbol\n",
							"df_users['domain'] = [email[email.find('@'):] for email in df_users['userPrincipalName']]"
						],
						"outputs": [],
						"execution_count": 103
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_users.shape[0]}\")\n",
							"\n",
							"# Only include empoyees who has a email address with domain-name equinor.com\n",
							"df_users = df_users[df_users.domain == '@equinor.com']\n",
							"\n",
							"# Delete non-valid employeeIDs\n",
							"df_users = df_users[df_users['employeeId'] != 'FunctionKey']\n",
							"\n",
							"print(f\"New length of the dataset is: {df_users.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 104
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Dropping duplicates"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# # Display the duplicates\n",
							"# display(df_users[df_users['employeeId'].isin(df_users.employeeId.value_counts().loc[lambda x: x>1].index)].sort_values(by=['employeeId']))"
						],
						"outputs": [],
						"execution_count": 105
					},
					{
						"cell_type": "code",
						"source": [
							"# # some users are registrered with two different employeeId and corresponding department, manager etc. but the same displayName\n",
							"# display(df_users[df_users['displayName'].isin(df_users.displayName.value_counts().loc[lambda x: x>1].index)].sort_values(by=['displayName']))"
						],
						"outputs": [],
						"execution_count": 106
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_users.shape[0]}\")\n",
							"\n",
							"# First isolate all duplicates that we want to remove. In this instance there is one duplicate that contains employee information, and another that does not.\n",
							"# All duplicates without information will be isolated in a variable and removed from the dataset\n",
							"\n",
							"duplicates = df_users[(df_users['employeeId'].isin(df_users.employeeId.value_counts().loc[lambda x: x>1].index)) & (df_users['department'].isna()) & (df_users['manager_employeeId'].isna()) & (df_users['manager_displayName'].isna()) & (df_users['manager_userPrincipalName'].isna()) | (df_users['userName'].str.contains('ja_')) & (df_users['manager_department'].isna())]\n",
							"\n",
							"df_users = df_users.drop(duplicates.index)\n",
							"\n",
							"print(f\"New length of the dataset is: {df_users.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 107
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Hierarchy-table\n",
							"The hierarchy-table will only connect employeeID to the managerIDs above"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Make df of employeeId and managerId\n",
							"df_id = df_users[['employeeId', 'manager_employeeId']].copy()\n",
							"\n",
							"# Store employeeID who has them self as manager\n",
							"df_id_wrong_format = df_id[df_id['employeeId'] == df_id['manager_employeeId']]"
						],
						"outputs": [],
						"execution_count": 108
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Merge df\n",
							"Create a total df that connect the employeeID to its closest manager. Merge df_id to itself untill only 1 unique employeeID is at the top.\n",
							"\n",
							"\n",
							"**Note:** there are two possibilities of poor data quality that we need to address since they cause infinate loops or wrong information about level in hierarchy as well as connection to the correct top leader.\n",
							"1. An employee has itself listed as a manger: employeeId: X, managerId: X\n",
							"2. Two employees has each other listed as manager: employeeId: X, managerId: Y and employeeId: Y, managerId: X"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Start with copy the first two columns of employeeId and managerId\n",
							"df_total = df_id.copy()\n",
							"\n",
							"# Connect the manager to the next manager and drop the duplicate column\n",
							"df_total = df_total.merge(df_id,\n",
							"                          left_on='manager_employeeId',\n",
							"                          right_on='employeeId',\n",
							"                          how='left',\n",
							"                          suffixes=['_0','_1'])\n",
							"\n",
							"df_total = df_total.drop(columns=['employeeId_1'])\n",
							"\n",
							"# if an employee has itself listed as the manager, replace manager_id to be '0' for tracking and further handling in the future\n",
							"df_total['manager_employeeId_1'] = df_total.apply(lambda x: '0' \\\n",
							"                                                    if (x['manager_employeeId_1'] == x['manager_employeeId_0']) \\\n",
							"                                                    else x['manager_employeeId_1'], axis=1)"
						],
						"outputs": [],
						"execution_count": 109
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"We're now moving up the hierarchy tree to find the managers of each employee. If we haven't hit the top of the tree within hitting the threshold, we can ignore those employees."
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Set a threshold for how far up the tree we want to go.\n",
							"thres = 10\n",
							"\n",
							"for n in range(1, thres):\n",
							"    # Merge the employee with the n-th manager above the employee\n",
							"    df_total = df_total.merge(df_id, left_on = f'manager_employeeId_{n}', right_on = 'employeeId', how = 'left')\n",
							"    # Drop the employeeId-column so as not to create duplicated columns\n",
							"    df_total = df_total.drop(columns = ['employeeId'])\n",
							"    # Rename the merged manager_employeeId to the next level of manager (n + 1)\n",
							"    df_total = df_total.rename(columns = {'manager_employeeId' : f'manager_employeeId_{n+1}'})\n",
							"\n",
							"    #To avoid loops caused by poor data quality:\n",
							"    #If two employees have each other as their manager, this will cause a never ending loop.\n",
							"    #This is the case if e.g. manager 3 = manager 1. In this case we set the manager_Id to be 0, so that it can be easily picked up and further handled in the future.\n",
							"    df_total[f'manager_employeeId_{n+1}'] = df_total.apply(lambda x: '0' \\\n",
							"                                                            if (x[f'manager_employeeId_{n+1}'] == x[f'manager_employeeId_{n}']) \\\n",
							"                                                            or (x[f'manager_employeeId_{n+1}'] == x[f'manager_employeeId_{n-1}']) \\\n",
							"                                                            else x[f'manager_employeeId_{n+1}'], axis=1)\n",
							"\n",
							"    # Iterate untill only 1 unique person at the top of hierarchy\n",
							"    if df_total[f'manager_employeeId_{n+1}'].nunique() == 1:\n",
							"        break"
						],
						"outputs": [],
						"execution_count": 110
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Add level-column\n",
							"Define a level indicating how many managers is above. E.g. vp has normally 3 managers and will be at level 4"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# Count total number of columns in hierarchy and substract number of empty-cells\n",
							"num_columns = df_total.shape[1]\n",
							"df_total['level'] = df_total.apply(lambda x: num_columns - x.isnull().sum(), axis='columns')"
						],
						"outputs": [],
						"execution_count": 111
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Locate employeeID with missing information"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"print(f\"Old length of the dataset is: {df_total.shape[0]}\")\n",
							"\n",
							"# Extract employees with no department etc.\n",
							"df_removeId = df_users[(df_users['department'].isna()) & (df_users['manager_employeeId'].isna()) & (df_users['manager_displayName'].isna()) & (df_users['manager_userPrincipalName'].isna()) & (df_users['manager_department'].isna())]\n",
							"df_removeId = df_removeId[['employeeId', 'manager_employeeId']]\n",
							"\n",
							"# Store IDs in df for easy access if needed\n",
							"df_id_wrong_format = df_id_wrong_format.append(df_removeId)\n",
							"\n",
							"# Remove from hierarchy-table\n",
							"df_total = df_total[~df_total['employeeId_0'].isin(df_id_wrong_format['employeeId'])]\n",
							"\n",
							"print(f\"New length of the dataset is: {df_total.shape[0]}\")"
						],
						"outputs": [],
						"execution_count": 112
					},
					{
						"cell_type": "code",
						"source": [
							"# Check that wrong ID is no longer in hierarchy\n",
							"id_list = df_removeId['employeeId'].sort_values().unique()\n",
							"\n",
							"for id in id_list:\n",
							"    print(id)\n",
							"    if id in df_total.employeeId_0:\n",
							"        print('Yes')\n",
							"    else:\n",
							"        print('No')"
						],
						"outputs": [],
						"execution_count": 113
					},
					{
						"cell_type": "markdown",
						"source": [
							"#### Final steps to hierarchy of employeeID and corresponding Managers for all levels"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"# List of all levels in decreasing order\n",
							"level_list = df_total.level.sort_values().unique()\n",
							"\n",
							"# Empty list to be filled by for-loop\n",
							"df_list = []\n",
							"\n",
							"# Create df for each level and store in list df_list\n",
							"for level in level_list:\n",
							"    vars()[f'df_level{level}'] = df_total[df_total['level']== level].copy()\n",
							"    df_list.append(vars()[f'df_level{level}'])\n",
							"\n",
							"# Tuple of level and corresponding df, i.e. ( (1, df_level1), (2, df_level2), ...)\n",
							"combined_tuple = list(zip(level_list, df_list))"
						],
						"outputs": [],
						"execution_count": 114
					},
					{
						"cell_type": "code",
						"source": [
							"# Apply Manager 1, 2, ... according to which level the employee is at\n",
							"for level, df in combined_tuple:\n",
							"    if level != 1:\n",
							"        for i in range(level-1):\n",
							"            df[f'Manager{level - i - 1}'] = df[[f'manager_employeeId_{i}']]"
						],
						"outputs": [],
						"execution_count": 115
					},
					{
						"cell_type": "code",
						"source": [
							"df_hierarchy = df_list[0].copy()\n",
							"\n",
							"# Append all df_levels 2-8\n",
							"for df in df_list[1:]:\n",
							"    df_hierarchy = df_hierarchy.append(df)\n",
							"\n",
							"# Remove redundant columns manager_employeeId 0-6\n",
							"for level in level_list[:-1]:\n",
							"    df_hierarchy = df_hierarchy.drop(columns = {f'manager_employeeId_{level-1}'})"
						],
						"outputs": [],
						"execution_count": 116
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# print(df_hierarchy.shape)\r\n",
							"# df_hierarchy.head(10)"
						],
						"outputs": [],
						"execution_count": 118
					},
					{
						"cell_type": "markdown",
						"source": [
							"### Dataframes in the notebook\n",
							"1. df_hierarchy shows employeeID, level, Manager1, Manager2 etc. NB! Those employees which have Manager1=0 is not correctly linked to the top leader of the company due to poor data quality. They are included so that one can link to a person registrered in Azure AD, but information about level (or business area/department) will not be accurate.\n",
							"2. df_users All info about employeeID, department, manager, etc\n",
							"3. df_id_wrong_format employeeID with wrong info: missing info or them self as manager"
						]
					},
					{
						"cell_type": "markdown",
						"source": [
							"## Write to optimized"
						]
					},
					{
						"cell_type": "code",
						"source": [
							"#Set optimized path\n",
							"\n",
							"optimized_path = 'abfss://' + container + '@' + storageAccount + '.dfs.core.windows.net/AzureAD_BusinessAreaLevel/silver/usersWithManagerSnapshot_v1.parquet'\n",
							"\n",
							"df_spark = spark.createDataFrame(df_hierarchy)\n",
							"\n",
							"df_spark.write.format('parquet').mode('overwrite').save(optimized_path)\n",
							"# df_spark.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(optimized_path)"
						],
						"outputs": [],
						"execution_count": 96
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/validate-historic-total-cost')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"description": "This notebook aggregates the cost from the csv cost file and compares it to the aggregated cost of the extended parquet cost file.",
				"folder": {
					"name": "NotebookInProduction/Utilities"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('validate-historic-total-cost_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "56g",
					"driverCores": 8,
					"executorMemory": "56g",
					"executorCores": 8,
					"numExecutors": 2,
					"conf": {
						"spark.dynamicAllocation.enabled": "false",
						"spark.dynamicAllocation.minExecutors": "2",
						"spark.dynamicAllocation.maxExecutors": "2",
						"spark.autotune.trackingId": "decd9a07-d080-4f82-a30a-f7e0c609fd14"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('validate-historic-total-cost_notebookSparkPoolIdRef')]",
						"name": "[parameters('validate-historic-total-cost_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('validate-historic-total-cost_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.2",
						"nodeCount": 3,
						"cores": 8,
						"memory": 56
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"import pandas as pd \r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.types as T"
						],
						"outputs": [],
						"execution_count": 19
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"# Input data\r\n",
							"container = 'usage'\r\n",
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 20
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Aggregate the entire cost history for both raw and processed data based on cost type ('AmortizedCost' or 'ActualCost')\r\n",
							"\r\n",
							"def aggregate_cost_data(cost_type):\r\n",
							"    # Create schema for cost aggregation\r\n",
							"    schema = T.StructType([\r\n",
							"        T.StructField(\"Date\", T.TimestampType(), True),\r\n",
							"        T.StructField(\"RawDataTotalCost\", T.DoubleType(), True),\r\n",
							"        T.StructField(\"ProcessedDataTotalCost\", T.DoubleType(), True),\r\n",
							"        T.StructField(\"TotalCostDiff\", T.IntegerType(), True),\r\n",
							"        T.StructField(\"CostType\", T.StringType(), True)\r\n",
							"    ])\r\n",
							"\r\n",
							"    # Create an empty DataFrame with the specified schema\r\n",
							"    df = spark.createDataFrame([], schema=schema)\r\n",
							"\r\n",
							"    # Define the root path\r\n",
							"    root_path = f\"abfss://{container}@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthly{cost_type}\"\r\n",
							"\r\n",
							"    # Collect all the folders under this root path\r\n",
							"    folders = mssparkutils.fs.ls(root_path)\r\n",
							"\r\n",
							"    for folder in folders:\r\n",
							"        # List all file paths in current folder\r\n",
							"        files = mssparkutils.fs.ls(root_path +'/'+ str(folder.name))\r\n",
							"        file_paths = [file.path for file in files]\r\n",
							"\r\n",
							"        # Find the raw data file (csv) and processed data (extended data file - parquet)\r\n",
							"        csv_file = next(filter(lambda file_path: \"csv\" in file_path, file_paths), None)\r\n",
							"        extended_file = next(filter(lambda file_path: \"Extended_v2\" in file_path, file_paths), None)\r\n",
							"        \r\n",
							"        try:\r\n",
							"            # Extract date for current folder\r\n",
							"            date = pd.to_datetime(folder.path.split('/')[-1].split('-')[0],format=\"%Y/%m/%d\")\r\n",
							"\r\n",
							"            # Read raw data and transformed fata\r\n",
							"            csv_df = spark.read.format('csv').load(csv_file, header=True)\r\n",
							"            extended_df = spark.read.format('parquet').load(extended_file)\r\n",
							"\r\n",
							"            # Aggregate on cost for raw data file\r\n",
							"            agg_csv_df = csv_df.select(F.sum(F.col('CostInBillingCurrency')).alias('RawDataTotalCost'))\r\n",
							"            agg_csv_df = agg_csv_df.withColumn(\"Date\", F.lit(date).cast(T.TimestampType()))\r\n",
							"\r\n",
							"            # Aggregate on cost for processed data file\r\n",
							"            agg_extended_df = extended_df.select(F.sum(F.col('CostInBillingCurrency')).alias('ProcessedDataTotalCost'))\r\n",
							"            agg_extended_df = agg_extended_df.withColumn(\"Date\", F.lit(date).cast(T.TimestampType()))\r\n",
							"\r\n",
							"            # Combine aggregated cost data into one dataframe\r\n",
							"            combined_df = agg_csv_df.join(agg_extended_df, on=\"Date\", how=\"left\")\r\n",
							"\r\n",
							"            # Compute difference between the raw and processed total cost\r\n",
							"            combined_df = combined_df.withColumn(\"TotalCostDiff\", F.expr(\"FLOOR(ABS(ProcessedDataTotalCost - RawDataTotalCost))\"))\r\n",
							"\r\n",
							"            combined_df = combined_df.withColumn(\"CostType\", F.lit(cost_type))\r\n",
							"\r\n",
							"            # Add aggregated cost to historic aggregations\r\n",
							"            df = df.union(combined_df)\r\n",
							"\r\n",
							"        except Exception as e:\r\n",
							"            print(f\"Error processing the {folder.name} folder contents: {e}\")\r\n",
							"\r\n",
							"    return df"
						],
						"outputs": [],
						"execution_count": 23
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Aggregate actual cost data\r\n",
							"actual_cost_df = aggregate_cost_data(\"ActualCost\")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"collapsed": false
						},
						"source": [
							"# Aggregate amortized cost data\r\n",
							"amortized_cost_df = aggregate_cost_data(\"AmortizedCost\")"
						],
						"outputs": [],
						"execution_count": null
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Combine aggregated amortized and actual cost into a single dataframe\r\n",
							"total_cost_df = actual_cost_df.union(amortized_cost_df)\r\n",
							"\r\n",
							"# Display the total aggregated cost difference of the entire cost data history\r\n",
							"# The computed value should always be 0 when historic data has been processed properly\r\n",
							"# If the aggregated cost diff is greater than 0, the extend script is erroneous and produces inconsistent data\r\n",
							"total_cost_df.select(F.sum(F.col(\"TotalCostDiff\")).alias(\"AggregatedCostDiff\")).show()"
						],
						"outputs": [],
						"execution_count": 29
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/vm-hub-deployments')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/HUB and RI Savings"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('vm-hub-deployments_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "37792f10-899c-47b4-8478-ff2e48b9ab32"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('vm-hub-deployments_notebookSparkPoolIdRef')]",
						"name": "[parameters('vm-hub-deployments_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('vm-hub-deployments_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112,
						"automaticScaleJobs": true
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Initialize script"
						]
					},
					{
						"cell_type": "code",
						"metadata": {},
						"source": [
							"from datetime import timedelta, datetime\r\n",
							"from dateutil.relativedelta import relativedelta\r\n",
							"import calendar\r\n",
							"import json\r\n",
							"from notebookutils import mssparkutils\r\n",
							"from azure.storage.blob import BlobServiceClient\r\n",
							"import pyspark.sql.functions as F\r\n",
							"import pyspark.sql.window as W\r\n",
							"from pyspark.sql import Row"
						],
						"outputs": [],
						"execution_count": 102
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 103
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Constants\r\n",
							"HOURS_PER_YEAR = 8760\r\n",
							"VCPUS_PER_LICENSE = 16\r\n",
							"PROD_OFFER_ID = 'MS-AZR-0017P'\r\n",
							"KEY_VAULT_NAME = 'acm-toolkit-kv'\r\n",
							"LINKED_SERVICE_NAME = 'ACM_Toolkit_kv'\r\n",
							"hubAutomationConnectionString = mssparkutils.credentials.getSecret(KEY_VAULT_NAME , 'hubautomation-sa-connectionstring', LINKED_SERVICE_NAME)"
						],
						"outputs": [],
						"execution_count": 104
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Name of resource groups containing terminal server (TS) virtual machines\r\n",
							"# The TS VMs have a pre-allocated set of HUB licenses, and should be excluded from the calculation in this script\r\n",
							"TS_VM_RG = [\r\n",
							"    'RG-TERMINAL_SERVERS-NOE',\r\n",
							"    'RG-TERMINAL_SERVERS-NOW',\r\n",
							"    'RG-TERMINAL_SERVERS-SCUS'\r\n",
							"]"
						],
						"outputs": [],
						"execution_count": 105
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Fetch pricesheet"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Load pricesheet\r\n",
							"pricesheet_source_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/pricesheet/portal-export/pricesheet-latest'\r\n",
							"pricesheet_df = spark.read.format('parquet').load(pricesheet_source_path)"
						],
						"outputs": [],
						"execution_count": 106
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"pricesheet_columns = [\r\n",
							"    'MeterName', \r\n",
							"    'MeterCategory', \r\n",
							"    'MeterSubCategory', \r\n",
							"    'UnitOfMeasure', \r\n",
							"    'PartNumber', \r\n",
							"    'UnitPrice', \r\n",
							"    'CurrencyCode', \r\n",
							"    'OfferID', \r\n",
							"    'PriceType'\r\n",
							"]\r\n",
							"\r\n",
							"pricesheet_df = pricesheet_df.select(*pricesheet_columns)\r\n",
							"\r\n",
							"pricesheet_df = pricesheet_df.where(\r\n",
							"    (F.col('OfferID') == PROD_OFFER_ID) &\r\n",
							"    (F.col('MeterName').endswith('License')) &\r\n",
							"    (F.col('MeterSubCategory') == 'Windows Server') &\r\n",
							"    (F.col('PriceType') == 'Consumption')\r\n",
							")\r\n",
							"\r\n",
							"# Compute normalized units based on the given unit of measure\r\n",
							"pricesheet_df = pricesheet_df.withColumn('BaseUnits', F.split(F.col('UnitOfMeasure'), ' ').getItem(0).cast('int'))\r\n",
							"pricesheet_df = pricesheet_df.withColumn('BaseUnitPrice', F.col('UnitPrice') / F.col('BaseUnits'))\r\n",
							"pricesheet_df = pricesheet_df.withColumn('VCPUs', F.split(F.col('MeterName'), ' ').getItem(0).cast('int'))\r\n",
							"pricesheet_df = pricesheet_df.withColumn('VCPUBaseUnitPrice', F.col('BaseUnitPrice') / F.col('VCPUs'))\r\n",
							"\r\n",
							"# Get license cost for 1 vCPU\r\n",
							"VCPUBASEUNITPRICE = pricesheet_df.where(F.col('MeterName') == '1 vCPU VM License').select('VCPUBaseUnitPrice').collect()[0][0]"
						],
						"outputs": [],
						"execution_count": 90
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Lookup HUB Windows configuration"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"blob_service_client = BlobServiceClient.from_connection_string(hubAutomationConnectionString)\r\n",
							"\r\n",
							"# Get a reference to the blob container and file of the VM HUB configuration\r\n",
							"container_name = 'win-config'\r\n",
							"blob_name = 'config.json'\r\n",
							"container_client = blob_service_client.get_container_client(container_name)\r\n",
							"blob_client = container_client.get_blob_client(blob_name)\r\n",
							"\r\n",
							"# Download the blob content as a string\r\n",
							"blob_content = blob_client.download_blob().content_as_text()\r\n",
							"\r\n",
							"# Parse downloaded blob as json\r\n",
							"vm_config = json.loads(blob_content)\r\n",
							"\r\n",
							"# Compute the variable determining if results should be written to file\r\n",
							"day_name = datetime.now().strftime(\"%A\")\r\n",
							"should_run = vm_config['runDays'][day_name]\r\n",
							"\r\n",
							"license_count = vm_config['lic_count']\r\n",
							"ts_vms = vm_config['ts_vms']\r\n",
							"timespan = vm_config['timespan']\r\n",
							"yearly_license_cost = vm_config['lic_cost_yearly']\r\n",
							"available_licenses = license_count - ts_vms\r\n",
							"\r\n",
							"# Hourly cost of license per vCPU\r\n",
							"hourly_vcpu_cost = yearly_license_cost / (license_count * HOURS_PER_YEAR * VCPUS_PER_LICENSE)"
						],
						"outputs": [],
						"execution_count": 93
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Load and filter usage "
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"columns_to_keep = [\r\n",
							"    'SubscriptionId',\r\n",
							"    'SubscriptionName',\r\n",
							"    'Date',\r\n",
							"    'ResourceGroup', \r\n",
							"    'ResourceName', \r\n",
							"    'ResourceId', \r\n",
							"    'MeterCategory', \r\n",
							"    'MeterSubCategory', \r\n",
							"    'MeterName',\r\n",
							"    'UnitOfMeasure',\r\n",
							"    'Quantity',\r\n",
							"    'UnitPrice',\r\n",
							"    'EffectivePrice',\r\n",
							"    'CostInBillingCurrency', \r\n",
							"    'ServiceInfo2',\r\n",
							"    'PartNumber',\r\n",
							"    'ProductName', \r\n",
							"    'ai_VCPUs'\r\n",
							"]\r\n",
							"\r\n",
							"vm_columns = columns_to_keep + [\r\n",
							"    'WindowsAHB',\r\n",
							"    'WindowsAHB_VCPUs',\r\n",
							"    'ai_VMName'\r\n",
							"]"
						],
						"outputs": [],
						"execution_count": 92
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"cost_path = monthly_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/exports/monthly/ACMMonthlyActualCost/*/Extended_v3_ACMMonthlyActualCost_*.parquet'\r\n",
							"cost_df = spark.read.format('parquet').load(cost_path)"
						],
						"outputs": [],
						"execution_count": 112
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Filter usage to timespan defined in configuration file\r\n",
							"vm_start_date = (datetime.now() - timedelta(days=timespan)).strftime('%Y-%m-%d')\r\n",
							"cost_df = cost_df.where(F.col('Date') >= vm_start_date)\r\n",
							"\r\n",
							"# Use only VM related cost\r\n",
							"is_vm_cost = ((F.col('ResourceId').contains('/virtualMachines/')) | (F.col('ResourceId').contains('/virtualMachineScaleSets/'))) \\\r\n",
							"    & ((F.col('MeterSubCategory').contains('Windows')) | (F.col('ServiceInfo2').contains('Windows Server BYOL'))) \\\r\n",
							"    & ((F.col('MeterCategory') == 'Virtual Machines') | (F.col('MeterCategory') == 'Virtual Machines Licenses')) \\\r\n",
							"    & (F.col('ai_VCPUs').isNotNull())\r\n",
							"\r\n",
							"cost_df = cost_df.where(is_vm_cost).select(*vm_columns)\r\n",
							"\r\n",
							"# Exclude terminal server VMs (as their HUB assignment are managed separately)\r\n",
							"cost_df = cost_df.where(~F.col('ResourceGroup').isin(TS_VM_RG))\r\n",
							"\r\n",
							"# Removing the VMs who's ResourceName begins with 'CVD-' as these are Windows Client VM's and not relevant for consideration of a Windows Server licence\r\n",
							"cost_df = cost_df.where(~F.upper(F.col('ResourceName')).startswith('CVD-'))\r\n",
							"\r\n",
							"# Persist a df copy for disable list calculation\r\n",
							"cost_copy_df = cost_df.alias('cost_copy_df')"
						],
						"outputs": [],
						"execution_count": 94
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute set VMs getting HUB Enabled"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Columns used for aggregated result\r\n",
							"selected_columns = [\r\n",
							"    'ResourceId',\r\n",
							"    'SubscriptionId',\r\n",
							"    'ResourceGroup',\r\n",
							"    'ResourceName',\r\n",
							"    'WindowsAHB_VCPUs',\r\n",
							"    'ai_VCPUs'\r\n",
							"]\r\n",
							"\r\n",
							"# Scalesets and virtual machines is different in how the licence cost is calculated\r\n",
							"# In order to retain the correct number of vCPUs when later grouping by ResourceId the Quantity needs to be divided by the \r\n",
							"# number of nodes in the scaleset before multiplying by vCPUs and price per hour\r\n",
							"cost_df = cost_df.withColumn('NodeCount',\r\n",
							"    F.when(F.col('ResourceId').contains('/virtualMachineScaleSets/'), 1)\r\n",
							"    .otherwise(0)\r\n",
							")\r\n",
							"\r\n",
							"# Aggregate quantities and node counts in order to make HUB savings calculation simpler\r\n",
							"cost_df = cost_df \\\r\n",
							"    .select(*selected_columns, 'NodeCount', 'Quantity') \\\r\n",
							"    .groupBy(*selected_columns)\\\r\n",
							"    .agg(F.sum('Quantity').alias('Quantity'), F.sum('NodeCount').alias('NodeCount'))\r\n",
							"\r\n",
							"# Compute hourly PAYG license cost\r\n",
							"cost_df = cost_df.withColumn('PAYGLicenseCost', F.col('Quantity') * F.col('ai_VCPUs') * VCPUBASEUNITPRICE)\r\n",
							"\r\n",
							"# If cost is related to scaleset, the license cost must be divided by the number of nodes\r\n",
							"cost_df = cost_df.withColumn('PAYGLicenseCost', F.when(F.col('NodeCount') > 0, F.col('PAYGLicenseCost') / F.col('NodeCount')).otherwise(F.col('PAYGLicenseCost')))\r\n",
							"\r\n",
							"# Compute hourly HUB license cost \r\n",
							"cost_df = cost_df.withColumn('HUBLicenseCost', F.col('Quantity') * F.col('WindowsAHB_VCPUs') * hourly_vcpu_cost)\r\n",
							"\r\n",
							"# If cost is related to scaleset, the license cost must be divided by the number of nodes\r\n",
							"cost_df = cost_df.withColumn('HUBLicenseCost', F.when(F.col('NodeCount') > 0, F.col('HUBLicenseCost') / F.col('NodeCount')).otherwise(F.col('HUBLicenseCost')))\r\n",
							"\r\n",
							"# Compute savings per VCPU\r\n",
							"cost_df = cost_df.withColumn('HUBSavingsPerVCPU', (F.col('PAYGLicenseCost') - F.col('HUBLicenseCost')) / F.col('WindowsAHB_VCPUs'))\r\n",
							"\r\n",
							"cost_df = cost_df.drop('NodeCount')\r\n",
							"cost_df = cost_df.orderBy(F.desc('HUBSavingsPerVCPU'))\r\n",
							"\r\n",
							"# Compute the cumulative number of normalized VCPUs\r\n",
							"window = W.Window.rowsBetween(W.Window.unboundedPreceding, 0)\r\n",
							"cost_df = cost_df.withColumn(\"TotalNormalizedCores\", F.sum(\"WindowsAHB_VCPUs\").over(window))\r\n",
							"\r\n",
							"# Only include the highest yielding resources up until the cumulative normalized cores equals the equivalent amount of available licenses\r\n",
							"vm_enable_df = cost_df.where(F.col('TotalNormalizedCores') / VCPUS_PER_LICENSE <= available_licenses)\r\n",
							"\r\n",
							"# # Remove redundant columns\r\n",
							"vm_enable_df = vm_enable_df.select(*selected_columns)"
						],
						"outputs": [],
						"execution_count": 86
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Compute set of VMs getting HUB disabled"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Only VMs with HUB enabled are eligible to being disabled\r\n",
							"vm_disable_df = cost_copy_df.where(F.col('WindowsAHB') == 'Enabled')\r\n",
							"\r\n",
							"vm_disable_df = vm_disable_df \\\r\n",
							"    .select(*selected_columns) \\\r\n",
							"    .groupBy(selected_columns) \\\r\n",
							"    .count().drop('count')\r\n",
							"\r\n",
							"# Exclude VMs that are already in the list of enabled VMs\r\n",
							"vm_disable_df = vm_disable_df.join(vm_enable_df, 'ResourceId', 'left_anti')"
						],
						"outputs": [],
						"execution_count": 24
					},
					{
						"cell_type": "markdown",
						"metadata": {
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"## Store HUB deployment results and update activity log"
						]
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"def compute_activity_log_entry(activity_path):\r\n",
							"    # Load existing log\r\n",
							"    csv_options = {'header' : True,\r\n",
							"                    'delimiter' : ',',\r\n",
							"                    'quote' : '\"',\r\n",
							"                    'escape' : '\"'}\r\n",
							"    activity_df = spark.read.options(**csv_options).csv(activity_path)\r\n",
							"\r\n",
							"    today = (datetime.now().strftime('%Y-%m-%d'))\r\n",
							"    disabled_vms_count = vm_disable_df.count()\r\n",
							"    enabled_vms_count = vm_enable_df.count()\r\n",
							"    normalized_cores_disabled = vm_disable_df.select('WindowsAHB_VCPUs').agg(F.sum('WindowsAHB_VCPUs')).collect()[0][0] or 0\r\n",
							"    normalized_cores_enabled = vm_enable_df.select('WindowsAHB_VCPUs').agg(F.sum('WindowsAHB_VCPUs')).collect()[0][0] or 0\r\n",
							"    licenses_removed = normalized_cores_disabled / VCPUS_PER_LICENSE\r\n",
							"    licenses_applied = normalized_cores_enabled / VCPUS_PER_LICENSE\r\n",
							"\r\n",
							"    row_values = [ \r\n",
							"        disabled_vms_count, \r\n",
							"        enabled_vms_count, \r\n",
							"        normalized_cores_disabled, \r\n",
							"        normalized_cores_enabled, \r\n",
							"        licenses_removed, \r\n",
							"        licenses_applied,\r\n",
							"        license_count,\r\n",
							"        ts_vms,\r\n",
							"        available_licenses\r\n",
							"    ]\r\n",
							"\r\n",
							"    new_activity_row = spark.createDataFrame([(today, *row_values)], activity_df.columns)\r\n",
							"    activity_df = activity_df.union(new_activity_row)\r\n",
							"    return activity_df"
						],
						"outputs": [],
						"execution_count": 25
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"enable_path = f'abfss://win-hub-logs-v2@hubautomation.dfs.core.windows.net/LATEST-AHUB-Deployment.csv'\r\n",
							"disable_path = f'abfss://win-hub-logs-v2@hubautomation.dfs.core.windows.net/LATEST-AHUB-Removal.csv'\r\n",
							"\r\n",
							"# Only persist result according to storage account configuration\r\n",
							"if should_run:\r\n",
							"    # Write enabled list to storage account\r\n",
							"    vm_enable_df.toPandas().to_csv(enable_path)\r\n",
							"\r\n",
							"    # Write disabled list to storage account\r\n",
							"    vm_disable_df.toPandas().to_csv(disable_path)\r\n",
							"\r\n",
							"    # Compute updated activity log and write back to file\r\n",
							"    activity_path = 'abfss://win-activity-v2@hubautomation.dfs.core.windows.net/activity.csv'\r\n",
							"    activity_df = compute_activity_log_entry(activity_path)\r\n",
							"    activity_df.toPandas().to_csv(activity_path, index=False)"
						],
						"outputs": [],
						"execution_count": 26
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"# Output 'should_run' indication when running in pipeline\r\n",
							"mssparkutils.notebook.exit(should_run)"
						],
						"outputs": [],
						"execution_count": null
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/wbs-owner-lookup')]",
			"type": "Microsoft.Synapse/workspaces/notebooks",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"folder": {
					"name": "NotebookInProduction/SAP"
				},
				"nbformat": 4,
				"nbformat_minor": 2,
				"bigDataPool": {
					"referenceName": "[parameters('wbs-owner-lookup_notebookSparkPoolNameRef')]",
					"type": "BigDataPoolReference"
				},
				"sessionProperties": {
					"driverMemory": "112g",
					"driverCores": 16,
					"executorMemory": "112g",
					"executorCores": 16,
					"numExecutors": 1,
					"conf": {
						"spark.dynamicAllocation.enabled": "true",
						"spark.dynamicAllocation.minExecutors": "1",
						"spark.dynamicAllocation.maxExecutors": "5",
						"spark.autotune.trackingId": "d7b04fe9-512f-49be-9ae9-8c329e6cf5b2"
					}
				},
				"metadata": {
					"saveOutput": true,
					"enableDebugMode": false,
					"kernelspec": {
						"name": "synapse_pyspark",
						"display_name": "Synapse PySpark"
					},
					"language_info": {
						"name": "python"
					},
					"a365ComputeOptions": {
						"id": "[parameters('wbs-owner-lookup_notebookSparkPoolIdRef')]",
						"name": "[parameters('wbs-owner-lookup_notebookSparkPoolNameRef')]",
						"type": "Spark",
						"endpoint": "[parameters('wbs-owner-lookup_notebookSparkPoolEndpointRef')]",
						"auth": {
							"type": "AAD",
							"authResource": "https://dev.azuresynapse.net"
						},
						"sparkVersion": "3.3",
						"nodeCount": 3,
						"cores": 16,
						"memory": 112
					},
					"sessionKeepAliveTimeout": 30
				},
				"cells": [
					{
						"cell_type": "code",
						"source": [
							"import pyspark.sql.functions as F"
						],
						"outputs": [],
						"execution_count": 11
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							},
							"tags": [
								"parameters"
							]
						},
						"source": [
							"storageAccount = 's037costmgmt'"
						],
						"outputs": [],
						"execution_count": 12
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"graph_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/AzureAD_BusinessAreaLevel/gold/usersWithBusinessAreaSnapshot_v1.parquet'\r\n",
							"graph_df = spark.read.format('parquet').load(graph_path)"
						],
						"outputs": [],
						"execution_count": 13
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sap_path = f'abfss://usage@{storageAccount}.dfs.core.windows.net/sap/sap-wbs-latest.parquet'\r\n",
							"sap_df = spark.read.format('parquet').load(sap_path)"
						],
						"outputs": [],
						"execution_count": 14
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sap_df = sap_df.withColumn('WBS_Owner_ID', F.when(F.length(F.col('WBS_Owner_ID')) == 5, F.lpad(F.col('WBS_Owner_ID'), 6, '0')).otherwise(F.col('WBS_Owner_ID')))"
						],
						"outputs": [],
						"execution_count": 15
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"sap_df = sap_df.join(graph_df, sap_df.WBS_Owner_ID == graph_df.employeeId, \"left\")\r\n",
							"sap_df = sap_df.drop('WBS_Owner_ID')"
						],
						"outputs": [],
						"execution_count": 17
					},
					{
						"cell_type": "code",
						"metadata": {
							"jupyter": {
								"source_hidden": false,
								"outputs_hidden": false
							},
							"nteract": {
								"transient": {
									"deleting": false
								}
							}
						},
						"source": [
							"wbs_path = f\"abfss://usage@{storageAccount}.dfs.core.windows.net/sap/wbs-owner-latest.parquet\"\r\n",
							"sap_df.write.format('parquet').mode('overwrite').option('overwriteSchema', 'true').save(wbs_path)"
						],
						"outputs": [],
						"execution_count": 18
					}
				]
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('workspaceName'), '/sparkpool32')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": "[parameters('sparkpool32_delayInMinutes')]"
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": "[parameters('sparkpool32_maxNodeCount')]",
					"minNodeCount": "[parameters('sparkpool32_minNodeCount')]"
				},
				"nodeCount": "[parameters('sparkpool32_nodeCount')]",
				"nodeSize": "[parameters('sparkpool32_nodeSize')]",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "[parameters('sparkpool32_sparkVersion')]",
				"libraryRequirements": {
					"content": "azure.mgmt.billing\nazure.mgmt.consumption\nazure.mgmt.resource\nazure.identity\nazure.keyvault\n\n",
					"filename": "requirements.txt",
					"time": "2023-01-25T09:06:41.7702231Z"
				},
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": true,
				"annotations": []
			},
			"dependsOn": [],
			"location": "northeurope"
		},
		{
			"name": "[concat(parameters('workspaceName'), '/sprkpool33large')]",
			"type": "Microsoft.Synapse/workspaces/bigDataPools",
			"apiVersion": "2019-06-01-preview",
			"properties": {
				"autoPause": {
					"enabled": true,
					"delayInMinutes": "[parameters('sprkpool33large_delayInMinutes')]"
				},
				"autoScale": {
					"enabled": true,
					"maxNodeCount": "[parameters('sprkpool33large_maxNodeCount')]",
					"minNodeCount": "[parameters('sprkpool33large_minNodeCount')]"
				},
				"nodeCount": "[parameters('sprkpool33large_nodeCount')]",
				"nodeSize": "[parameters('sprkpool33large_nodeSize')]",
				"nodeSizeFamily": "MemoryOptimized",
				"sparkVersion": "[parameters('sprkpool33large_sparkVersion')]",
				"isComputeIsolationEnabled": false,
				"sessionLevelPackagesEnabled": true,
				"annotations": []
			},
			"dependsOn": [],
			"location": "northeurope"
		}
	]
}